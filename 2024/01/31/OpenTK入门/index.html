

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="bjx">
  <meta name="keywords" content="">
  
    <meta name="description" content="介绍 官网：OpenTK - OpenTK 官方文档：LearnOpenTK - OpenTK 以下内容，采用版本为OpenTK 4.x 出于在C#中使用OpenGL的需求，发现一个封装库OpenTK，以下为该封装库在Winform开发中的使用过程  下载 在NuGet包管理器中下载OpenTK和OpenTK.WinForms  入门使用 在工具箱中将GLControl控件拖入窗口，即可在窗口中添">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenTK入门">
<meta property="og:url" content="https://strive-c.github.io/2024/01/31/OpenTK%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="strive-C blog">
<meta property="og:description" content="介绍 官网：OpenTK - OpenTK 官方文档：LearnOpenTK - OpenTK 以下内容，采用版本为OpenTK 4.x 出于在C#中使用OpenGL的需求，发现一个封装库OpenTK，以下为该封装库在Winform开发中的使用过程  下载 在NuGet包管理器中下载OpenTK和OpenTK.WinForms  入门使用 在工具箱中将GLControl控件拖入窗口，即可在窗口中添">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://strive-c.github.io/pipeline.png">
<meta property="og:image" content="https://strive-c.github.io/2-ndc.png">
<meta property="og:image" content="https://strive-c.github.io/2-vertex_attribute_pointer.png">
<meta property="og:image" content="https://strive-c.github.io/2-vertex_array_objects.png">
<meta property="og:image" content="https://strive-c.github.io/hellotriangle.png">
<meta property="og:image" content="https://strive-c.github.io/4-vertex_attribute_pointer_interleaved.png">
<meta property="og:image" content="https://strive-c.github.io/%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7.png">
<meta property="og:image" content="https://strive-c.github.io/wall.jpg">
<meta property="og:image" content="https://strive-c.github.io/5-tex_coords.png">
<meta property="og:image" content="https://strive-c.github.io/5-texture_wrapping.png">
<meta property="og:image" content="https://strive-c.github.io/5-texture_filter_nearest.png">
<meta property="og:image" content="https://strive-c.github.io/5-texture_filter_linear.png">
<meta property="og:image" content="https://strive-c.github.io/5-texture_filtering.png">
<meta property="og:image" content="https://strive-c.github.io/5-mipmaps.png">
<meta property="og:image" content="https://strive-c.github.io/texture_result.png">
<meta property="og:image" content="https://strive-c.github.io/8-coordinate_systems.png">
<meta property="og:image" content="https://strive-c.github.io/8-orthographic_frustum.png">
<meta property="og:image" content="https://strive-c.github.io/8-perspective.png">
<meta property="og:image" content="https://strive-c.github.io/8-perspective_frustum.png">
<meta property="og:image" content="https://strive-c.github.io/8-perspective_orthographic.png">
<meta property="og:image" content="https://strive-c.github.io/9-camera_axes.png">
<meta property="article:published_time" content="2024-01-31T06:30:17.000Z">
<meta property="article:modified_time" content="2024-03-19T11:54:18.201Z">
<meta property="article:author" content="bjx">
<meta property="article:tag" content="OpenTK">
<meta property="article:tag" content="OpenGL">
<meta property="article:tag" content="图像渲染">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://strive-c.github.io/pipeline.png">
  
  
  
  <title>OpenTK入门 - strive-C blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"strive-c.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="OpenTK入门"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-31 14:30" pubdate>
          2024年1月31日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          203 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">OpenTK入门</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>官网：<a target="_blank" rel="noopener" href="https://opentk.net/">OpenTK - OpenTK</a></li>
<li>官方文档：<a target="_blank" rel="noopener" href="https://opentk.net/learn/index.html">LearnOpenTK - OpenTK</a></li>
<li>以下内容，采用版本为<strong>OpenTK 4.x</strong></li>
<li>出于在C#中使用OpenGL的需求，发现一个封装库OpenTK，以下为该封装库在Winform开发中的使用过程</li>
</ul>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><ul>
<li>在NuGet包管理器中下载<code>OpenTK</code>和<code>OpenTK.WinForms</code></li>
</ul>
<h1 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h1><ul>
<li><p>在工具箱中将<code>GLControl</code>控件拖入窗口，即可在窗口中添加渲染组件。</p>
</li>
<li><p>在程序上方引入包：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p><img src="/pipeline.png" srcset="/img/loading.gif" lazyload alt="Pipeline graph"></p>
<ul>
<li>VERTEX DATA[]：顶点数据</li>
<li>VERTEX SHADER：将顶点移动到其位置。这是应用模型位置等操作的阶段。</li>
<li>SHAPE ASSEMBLY：OpenGL通过将顶点组合成三角形来工作；这个阶段就是实现这个过程的阶段。</li>
<li>GEOMETRY SHADER：一个可选的阶段。允许你对形状组装的结果进行微调。</li>
<li>RASTERIZATION：将三角形转换为片段的过程。</li>
<li>FRAGMENT SHADER：修改片段以包括颜色数据等内容。这是应用纹理和光照等操作的阶段。</li>
<li>TESTS AND BLENDING：片段着色器的结果与场景的其他部分集成的阶段。</li>
</ul>
<p>蓝色背景的部分是可编程的，灰色背景的部分是可以使用功能进行轻微自定义</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><p>在<code>glControl1_Load</code>函数中添加如下代码</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GL</span>.ClearColor(<span class="hljs-number">0</span>.<span class="hljs-number">2</span>f, <span class="hljs-number">0</span>.<span class="hljs-number">3</span>f, <span class="hljs-number">0</span>.<span class="hljs-number">3</span>f, <span class="hljs-number">1</span>.<span class="hljs-number">0</span>f);<br></code></pre></td></tr></table></figure>

<p>该函数是控件第一次加载的函数，任何与初始化有关的函数都应该放在<code>glControl1_Load</code>中间。</p>
<p><code>GL.ClearColor</code>接收四个0~1的浮点数，用于决定窗口在帧之间清除后的颜色。</p>
<hr>
<p>在<code>glControl1_Paint</code>函数中添加如下代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.Clear(ClearBufferMask.ColorBufferBit);<br><span class="hljs-comment">//Code goes here.</span><br>glControl1.SwapBuffers();<br></code></pre></td></tr></table></figure>

<p>该函数是控件的绘制代码</p>
<p>GL.Clear清除了屏幕，并且使用GL.ClearColor设置的对应颜色刷新屏幕</p>
<p>Code goes here.为渲染代码</p>
<p>几乎任何现代 OpenGL 都是所谓的“双缓冲”，先绘制绘制完成后再交换缓冲区</p>
<hr>
<p>在<code>glControl1_SizeChanged</code>函数中添加如下代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br></code></pre></td></tr></table></figure>

<p>该函数是用于尺寸变更时重新设置视角</p>
<h3 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h3><p>OpenGL是一个3D图形库，因此我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z坐标）。并且OpenGL仅在（x、y和z）处于-1.0到1.0之间的特定范围内时才处理 3D 坐标</p>
<p>以下是一个简单的顶点坐标示例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">float</span>[] vertices = &#123;<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">//Bottom-left vertex</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">//Bottom-right vertex</span><br>     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>  <span class="hljs-comment">//Top vertex</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="归一化设备坐标"><a href="#归一化设备坐标" class="headerlink" title="归一化设备坐标"></a>归一化设备坐标</h3><ul>
<li>Normalized Device Coordinates (NDC)</li>
<li>在顶点着色器中处理顶点坐标后，它们应位于归一化设备坐标中，这是一个小空间，其中 x、y 和 z 值从 -1.0 到 1.0 不等。任何超出此范围的坐标都将被丢弃&#x2F;裁剪，并且在屏幕上不可见。</li>
<li>与普通的屏幕坐标系不同，坐标系如下图所示</li>
</ul>
<p><img src="/2-ndc.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>在上面定义完顶点数据后，我们需要进行渲染管线的第一步，顶点着色器。我们需要完成以下任务：在GPU上创建内存；配置OpenGL如何解释内存；指定如何将数据发送到GPU。完成以上设置后，顶点着色器会处理我们提供给它的任意数量的顶点</p>
<p>我们通过顶点缓冲区对象（VBO）来管理这些内存，该对象可以在 GPU 的内存中存储大量顶点。使用这些缓冲区对象的优点是，我们可以一次将大批量数据发送到显卡，而不必一次发送一个顶点的数据。从CPU向显卡发送数据相对较慢，因此只要有可能，我们都会尝试一次发送尽可能多的数据。一旦数据进入显卡的内存中，顶点着色器几乎可以立即访问顶点，使其速度非常快。</p>
<p>顶点缓冲区对象有一个与该缓冲区对应的唯一ID，因此我们可以使用<code>GL.GenBuffers</code>生成一个缓冲器并返回该缓冲区的ID。</p>
<p>在<code>glControl1_Load</code>函数中添加如下代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> VertexBufferObject;<br>VertexBufferObject = GL.GenBuffer();<br></code></pre></td></tr></table></figure>

<p>OpenGL有多种类型的缓冲区对象，顶点缓冲区对象的缓冲区类型为<code>BufferTarget.ArrayBuffer</code>，balabalabala</p>
<p>我们可以使用<code>GL.BindBuffer</code>函数将新创建的缓冲区绑定到<code>BufferTarget.ArrayBuffer</code>类型上，代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br></code></pre></td></tr></table></figure>

<p>绑定完成后，我们可以通过<code>GL.BufferData</code>函数向缓冲区中放入之前定义的顶点数据：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>该函数用于将顶点数据放入缓冲区</p>
</li>
<li><p>第一个参数为要赋值到缓冲区的类型</p>
</li>
<li><p>第二个参数是传递给缓冲区的对象大小，以字节为单位</p>
</li>
<li><p>第三个参数是发送的实际数据</p>
</li>
<li><p>第四个参数是<code>BufferUsageHint</code>，用于指示显卡如何管理给定数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">StaticDraw：数据很可能根本不会改变或很少改变。<br>DynamicDraw：数据可能会发生很大变化。<br>StreamDraw：每次绘制数据时都会发生变化。<br></code></pre></td></tr></table></figure></li>
</ul>
<p>程序结束时会释放所有资源，但是如何出于某种原因需要手动释放缓冲区，可以调用如下代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.BindBuffer(BufferTarget.ArrayBuffer, <span class="hljs-number">0</span>);<br>GL.DeleteBuffer(VertexBufferObject);<br></code></pre></td></tr></table></figure>

<p>以上，我们完成了将顶点数据存储在显卡的内存中，由名为VBO的顶点缓冲区对象管理。接下来，我们要创建一个顶点和片段着色器来实际处理这些数据。</p>
<h3 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h3><p>如果我们想做一些渲染，OpenGL要求我们至少设置一个顶点和片段着色器。</p>
<p>我们需要做的第一件事是用着色器语言GLSL（OpenGL着色语言）编写顶点着色器，然后编译这个着色器，以便我们可以在我们的应用程序中使用它。下面是 GLSL 中一个非常基本的顶点着色器的源代码：</p>
<p>顶点着色器代码：shader.vert</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>GLSL看起来类似于C。每个着色器都以声明其版本开头。从OpenGL3.3及更高版本开始，GLSL的版本号与 OpenGL的版本匹配（例如，GLSL版本420对应于OpenGL版本4.2）。</p>
<p>接下来，在顶点着色器中用关键字<code>in</code>声明所有输入顶点属性。目前我们只关心位置数据，因此我们只需要一个顶点属性。GLSL具有矢量数据类型，根据其后缀数字包含1到4个浮点数。由于每个顶点都有一个3D坐标，我们使用名称<code>aPosition</code>创建一个<code>vec3</code>输入变量。我们还通过<code>layout(location = 0)</code>明确设置了输入变量的位置，稍后你会看到我们为什么需要这个位置。</p>
<p>每个着色器的入口点是<code>void main()</code>函数。这是你可以进行任何处理的地方。然而，在这里，我们只是将输入数据分配给了<code>gl_Position</code>，这是顶点着色器的内置变量，表示该顶点的最终位置。然而，<code>gl_Position</code>是一个<code>vec4</code>，但我们的输入顶点是<code>vec3</code>。为此，我们使用<code>vec4</code>函数使向量变得足够长。</p>
<p>当前的顶点着色器可能是我们能想象的最简单的顶点着色器，因为我们对输入数据没有进行任何处理，只是将其转发到着色器的输出。在实际应用中，输入数据通常不是已经在标准化设备坐标中，因此我们首先必须将输入数据转换为在OpenGL可见区域内的坐标。</p>
</blockquote>
<p>片段着色器代码：shader.frag</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> vec4 FragColor;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    FragColor = vec4(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.2f</span>, <span class="hljs-number">1.0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>片段着色器是我们将为渲染三角形创建的第二个也是最后一个着色器。片段着色器主要是关于计算像素的颜色输出。为了保持简单，片段着色器将始终输出一种橙色。</p>
<p>在计算机图形中，颜色表示为一个包含4个值的向量：红色、绿色、蓝色和alpha（不透明度）分量，通常缩写为RGBA。在OpenGL或GLSL中定义颜色时，我们将每个分量的强度设置为介于0.0和1.0之间的值。例如，如果我们将红色设置为1.0f并将绿色设置为1.0f，我们将获得混合了两种颜色并得到黄色的颜色。给定这三个颜色分量，我们可以生成超过1600万种不同的颜色！</p>
<p>片段着色器只需要一个输出变量，那就是一个大小为4的向量，定义了我们自己要计算的最终颜色输出。我们可以使用关键字<code>out</code>声明输出值，这里我们迅速命名为<code>FragColor</code>。接下来，我们只需将一个<code>vec4</code>分配给颜色输出，作为橙色，并且alpha值为1.0（1.0表示完全不透明）。</p>
</blockquote>
<h3 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h3><p>有了着色器源代码，现在需要编译着色器。这是在运行时完成的；预先编译着色器并将其与程序打包在一起是不可能的，因为编译后的着色器取决于许多因素，比如显卡型号、制造商和驱动程序。相反，我们在程序开始时包含着色器源代码并对其进行编译。</p>
<p>我们将通过创建一个Shader类来实现这一点，该类编译着色器并封装了我们稍后将看到的几个函数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shader</span><br>&#123;<br>    <span class="hljs-built_in">int</span> Handle;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shader</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> vertexPath, <span class="hljs-built_in">string</span> fragmentPath</span>)</span><br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在构造函数中，handle将代表着我们最终着色器程序编译完成后的位置。我们将在构造函数中进行所有初始化工作。</p>
<p>首先，在构造函数中定义两个整数：VertexShader和FragmentShader。这些是各个着色器的句柄。它们在构造函数中定义，因为在完整的着色器程序完成后，我们不再需要各个着色器。</p>
<p>接下来，我们需要从各个着色器文件中加载源代码。我们可以这样做：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> VertexShaderSource = File.ReadAllText(vertexPath);<br><span class="hljs-built_in">string</span> FragmentShaderSource = File.ReadAllText(fragmentPath);<br></code></pre></td></tr></table></figure>

<p>然后，我们生成我们的着色器，并将源代码绑定到着色器上。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">VertexShader = GL.CreateShader(ShaderType.VertexShader);<br>GL.ShaderSource(VertexShader, VertexShaderSource);<br><br>FragmentShader = GL.CreateShader(ShaderType.FragmentShader);<br>GL.ShaderSource(FragmentShader, FragmentShaderSource);<br></code></pre></td></tr></table></figure>

<p>接下来，我们编译着色器并检查是否有错误。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.CompileShader(VertexShader);<br><br>GL.GetShader(VertexShader, ShaderParameter.CompileStatus, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> success);<br><span class="hljs-keyword">if</span> (success == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">string</span> infoLog = GL.GetShaderInfoLog(VertexShader);<br>    Console.WriteLine(infoLog);<br>&#125;<br><br>GL.CompileShader(FragmentShader);<br><br>GL.GetShader(FragmentShader, ShaderParameter.CompileStatus, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> success);<br><span class="hljs-keyword">if</span> (success == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">string</span> infoLog = GL.GetShaderInfoLog(FragmentShader);<br>    Console.WriteLine(infoLog);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果在编译过程中出现任何错误，您可以使用函数GL.GetShaderInfoLog获取调试字符串。假设没有问题，我们可以继续链接。</p>
<p>我们的各个着色器已经编译完成，但要实际使用它们，我们必须将它们链接到一个可以在GPU上运行的程序中。这就是我们从现在开始谈论“着色器”时所指的内容。我们可以这样做：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#">Handle = GL.CreateProgram();<br><br>GL.AttachShader(Handle, VertexShader);<br>GL.AttachShader(Handle, FragmentShader);<br><br>GL.LinkProgram(Handle);<br><br>GL.GetProgram(Handle, GetProgramParameterName.LinkStatus, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> success);<br><span class="hljs-keyword">if</span> (success == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">string</span> infoLog = GL.GetProgramInfoLog(Handle);<br>    Console.WriteLine(infoLog);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这就是全部了！现在，handle是一个可用的着色器程序。</p>
<p>在离开构造函数之前，我们应该进行一些清理工作。现在，各个顶点和片段着色器已经被链接后就变得无用了；当你链接时，编译的数据被复制到着色器程序中。你也不需要将这些单独的着色器附加到程序中；让我们将它们分离然后删除它们。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.DetachShader(Handle, VertexShader);<br>GL.DetachShader(Handle, FragmentShader);<br>GL.DeleteShader(FragmentShader);<br>GL.DeleteShader(VertexShader);<br></code></pre></td></tr></table></figure>

<p>现在我们有一个有效的着色器，所以让我们添加一种使用它的方法。将以下函数添加到Shader类中：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span><br>&#123;<br>    GL.UseProgram(Handle);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后，我们需要在这个类被销毁后清理handle。我们不能在终结器中这样做，因为面向对象语言的问题。相反，我们必须从IDisposable派生，并记得手动调用Dispose来释放我们的着色器。在你的其余代码下面，添加以下内容：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> disposedValue = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> disposing</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!disposedValue)<br>    &#123;<br>        GL.DeleteProgram(Handle);<br><br>        disposedValue = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br>~Shader()<br>&#123;<br>    <span class="hljs-keyword">if</span> (disposedValue == <span class="hljs-literal">false</span>)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;GPU Resource leak! Did you forget to call Dispose()?&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>&#123;<br>    Dispose(<span class="hljs-literal">true</span>);<br>    GC.SuppressFinalize(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>恭喜！我们现在有了一个功能完备的着色器类。</p>
<p>在你的窗口类中，添加一个新的属性，Shader shader;。然后，在glControl1_Load中，添加一行shader &#x3D; new Shader(“shader.vert”, “shader.frag”);。<code>接着，转到OnUnload，并添加一行shader.Dispose();。？？</code></p>
<p>尝试运行；如果控制台没有输出任何内容，那么你的着色器已经成功编译了！</p>
<h3 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h3><p>顶点着色器允许我们以顶点属性的形式指定任何输入。虽然这提供了很大的灵活性，但这意味着我们必须手动指定输入数据的哪一部分传递给顶点着色器中的哪个顶点属性。这意味着我们必须在渲染之前指定OpenGL应该如何解释顶点数据。</p>
<p>这种格式信息存储在所谓的顶点数组对象（VAO）中。VAO包含有关顶点格式以及要从哪些缓冲区读取的信息。我们稍后将更详细地讨论这一点，但首先我们创建一个VAO并绑定它，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> VertexArrayObject = GL.GenVertexArray();<br>GL.BindVertexArray(VertexArrayObject);<br></code></pre></td></tr></table></figure>

<p>我们创建并绑定了VAO后，可以开始指定顶点格式和数据缓冲区。为此，首先需要查看我们顶点缓冲区的格式。</p>
<p>我们的顶点缓冲区数据格式如下：</p>
<p><img src="/2-vertex_attribute_pointer.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>位置数据存储为32位（4字节）浮点值。</li>
<li>每个位置由其中的3个值组成。 </li>
<li>每组3个值之间没有空格（或其他值）。这些值在数组中紧密地排列。 </li>
<li>数据中的第一个值位于缓冲区的开头。</li>
</ul>
<p>有了这些知识，我们可以告诉OpenGL如何解释顶点数据（每个顶点属性），使用GL.VertexAttribPointer：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>GL.VertexAttribPointer函数具有许多参数，让我们仔细地逐个讨论它们：</p>
<ul>
<li>第一个参数指定了我们要配置的顶点属性。记住，我们在顶点着色器中使用了layout(location &#x3D; 0)来指定位置顶点属性的位置。这将位置顶点属性的位置设置为0，因此我们传入0。</li>
<li>接下来的参数指定了顶点属性的大小。位置顶点属性是一个vec3，因此由3个值组成。</li>
<li>第三个参数指定了数据的类型，这里是浮点数（在GLSL中，vec*由浮点值组成）。</li>
<li>接下来的参数指定了是否希望数据被标准化。如果我们输入整数数据类型（int、byte），并将其设置为true，那么整数数据在转换为浮点数时会被标准化为0（或对于有符号数据为-1）和1。对我们来说，这并不相关，所以我们将其保持为false。</li>
<li>第五个参数被称为步长（stride），告诉我们相邻顶点属性之间的间隔空间。由于下一组位置数据恰好位于比一个浮点数大3倍的位置，我们将该值指定为步长。请注意，由于我们知道数组是紧密打包的（下一个顶点属性值之间没有空间），我们也可以将步长指定为0，让OpenGL确定步长（这仅在值紧密打包时有效）。每当我们有更多的顶点属性时，我们都必须仔细定义每个顶点属性之间的间隔，但我们稍后会看到更多的例子。</li>
<li>最后一个参数是位置数据在缓冲区中开始的偏移量。由于位置数据位于数据数组的开头，这个值就是0。我们将在后面更详细地探讨这个参数。</li>
</ul>
<p>每个顶点属性从由VBO管理的内存中获取其数据，它从哪个VBO获取数据（您可以有多个VBO）是由在调用GL.VertexAttribPointer时绑定到ArrayBuffer的VBO决定的。由于在调用glVertexAttribPointer之前，先前定义的VBO仍然绑定，因此顶点属性0现在与其顶点数据关联起来了。</p>
<p>现在我们已经指定了OpenGL应该如何解释顶点数据，我们还应该使用GL.EnableVertexAttribArray启用顶点属性，将顶点属性的位置作为其参数；顶点属性默认是禁用的。</p>
<p>从那时起，我们已经准备就绪：我们使用顶点缓冲对象初始化了缓冲区中的顶点数据，设置了顶点和片段着色器，并告诉OpenGL如何将顶点数据链接到顶点着色器的顶点属性。在OpenGL中绘制对象现在看起来会像这样：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><br>GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>shader.Use()<br><span class="hljs-comment">// 3. now draw the object</span><br>someOpenGLFunctionThatDrawsOurTriangle();<br></code></pre></td></tr></table></figure>

<p>每次我们想要绘制一个对象时，我们都必须重复这个过程。这可能看起来不是很多，但想象一下，如果我们有五个或更多的顶点属性，以及可能有数百个不同的对象（这并不罕见）。为每个对象绑定适当的缓冲对象并配置所有顶点属性很快就会变得繁琐起来。如果有一种方法可以将所有这些状态配置存储到一个对象中，并简单地绑定该对象来恢复其状态呢？</p>
<h3 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h3><p>顶点数组对象（Vertex Array Object，也称为VAO）可以像顶点缓冲对象一样绑定，从那时起，任何后续的顶点属性调用都将存储在VAO中。这样做的好处是，当配置顶点属性指针时，您只需要进行一次调用，每当我们想要绘制对象时，我们只需绑定相应的VAO。这使得在不同的顶点数据和属性配置之间切换就像绑定不同的VAO一样简单。我们刚刚设置的所有状态都存储在VAO中。</p>
<p>核心OpenGL要求我们使用VAO，这样它才知道如何处理我们的顶点输入。如果我们没有绑定VAO，OpenGL很可能会拒绝绘制任何东西。</p>
<p>顶点数组对象存储以下内容：</p>
<ul>
<li>GL.EnableVertexAttribArray或GL.DisableVertexAttribArray的调用。</li>
<li>通过GL.VertexAttribPointer进行的顶点属性配置。</li>
<li>通过GL.VertexAttribPointer调用与顶点属性相关联的顶点缓冲对象。</li>
</ul>
<p><img src="/2-vertex_array_objects.png" srcset="/img/loading.gif" lazyload></p>
<p>要生成一个VAO的过程与生成VBO的过程相似。作为一个属性，添加</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> VertexArrayObject;<br></code></pre></td></tr></table></figure>

<p>然后，在OnLoad中，在调用GL.BindVertexArray之前，添加：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">VertexArrayObject = GL.GenVertexArray();<br></code></pre></td></tr></table></figure>

<p>要使用VAO，你只需要绑定VAO使用GL.BindVertexArray。从那时起，我们应该绑定&#x2F;配置相应的VBO(s)和属性指针，并且然后解绑VAO以便以后使用。只要我们想要绘制一个对象，我们只需在绘制对象之前简单地绑定带有所需设置的VAO，然后绘制对象，就这样。在代码中，这看起来会像这样：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// ..:: 初始化代码（只需一次（除非你的对象经常变化））:: ..</span><br><span class="hljs-comment">// 1. 绑定顶点数组对象</span><br>GL.BindVertexArray(VertexArrayObject);<br><span class="hljs-comment">// 2. 将我们的顶点数组复制到OpenGL要使用的缓冲区中</span><br>GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><span class="hljs-comment">// 3. 然后设置我们的顶点属性指针</span><br>GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>然后，要实际绘制对象，你可以在渲染循环中放置以下代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.UseProgram();<br>GL.BindVertexArray(VertexArrayObject);<br>someOpenGLFunctionThatDrawsOurTriangle();<br></code></pre></td></tr></table></figure>

<p>这就是全部！我们在过去几百万页中所做的一切都导致了这一刻，一个存储了我们的顶点属性配置和使用哪个VBO的VAO。通常，当你有多个对象要绘制时，你首先生成&#x2F;配置所有的VAO（因此也生成&#x2F;配置了所需的VBO和属性指针），然后存储它们以供以后使用。当我们想要绘制我们的对象之一时，我们取相应的VAO，绑定它，然后绘制对象，再次解绑VAO。</p>
<p>为了绘制我们选择的对象，OpenGL为我们提供了GL.DrawArrays函数，它使用当前激活的着色器、先前定义的顶点属性配置以及VBO的顶点数据（通过VAO间接绑定）来绘制图元。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">shader.Use();<br>GL.BindVertexArray(VertexArrayObject);<br>GL.DrawArrays(PrimitiveType.Triangles, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>

<p>GL.DrawArrays函数的第一个参数是我们想要绘制的OpenGL图元类型。由于我在开头说过我们想要绘制一个三角形，而我不喜欢欺骗你，我们传入PrimitiveType.Triangles。第二个参数指定了我们想要绘制的顶点数组的起始索引；因为我们想要绘制所有的顶点，所以我们将其留在0。最后一个参数指定了我们想要绘制的顶点数量，这是3（我们只从我们的数据中渲染一个三角形，它恰好是3个顶点长）。</p>
<p>现在尝试编译代码，如果出现任何错误，请从错误开始逆向操作。当你的应用程序编译成功后，你应该会看到以下结果。</p>
<p><img src="/hellotriangle.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="补充说明：动态检索着色器布局"><a href="#补充说明：动态检索着色器布局" class="headerlink" title="补充说明：动态检索着色器布局"></a>补充说明：动态检索着色器布局</h3><p>在这个例子中，当我们调用GL.VertexAttribPointer时，我们为变量的位置使用了硬编码的布局0。这仅适用于我们在shader.vert中显式将布局设置为0的情况。但是，如果你不想这样做呢？如果你愿意，你可以在运行时检索位置。</p>
<p>如果你想这样做，可以在你的Shader类中添加以下函数。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">csharpCopy codepublic <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetAttribLocation</span><span class="hljs-params">(string attribName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> GL.<span class="hljs-title">GetAttribLocation</span><span class="hljs-params">(Handle, attribName)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，在设置VAO时，你可以使用shader.GetAttribLocation(“aPosition”)代替0。如果你这样做，你就不必再在着色器中包含layout(location&#x3D;0)这一行了。</p>
<p>本教程将坚持使用硬编码的值，但重要的是要知道两种方法都可以实现。</p>
<hr>
<p>以上就是OpenTK的绘制三角形的简单的入门使用</p>
<h1 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h1><h2 id="元素缓冲区对象"><a href="#元素缓冲区对象" class="headerlink" title="元素缓冲区对象"></a>元素缓冲区对象</h2><p>我们已经渲染了我们的第一个三角形，但是如果我们想做一些更复杂的事情呢？比如说，一个矩形？</p>
<p>OpenGL专门使用三角形进行渲染。它对正方形和其他形状有部分支持，但是这些功能已经被废弃很长时间了，不应该使用。你可以通过定义六个顶点来制作两个看起来像一个形状的三角形，但是这样做会浪费，因为一个矩形只需要四个顶点。虽然这可能看起来不是很糟糕，但是考虑一个立方体：如果没有浪费，只需要八个顶点，但是如果你使用每个面由两个三角形组成的方法，那么单个立方体就需要36个顶点！随着模型变得更复杂，数字只会变得更糟；显然，需要一种更好的方法。</p>
<p>有很多不同的方法可以做到这一点（比如三角带），但是在本教程中，我们将使用称为元素缓冲对象的东西，它是一种允许我们重复使用顶点来创建多个图元的缓冲区类型。使用EBO，我们将能够仅使用四个顶点创建一个矩形。</p>
<p>用以下内容替换你的顶点数组：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">float</span>[] vertices = &#123;<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右上角</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 左下角</span><br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">// 左上角</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>然后，在下面，添加以下数组：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">uint</span>[] indices = &#123;  <span class="hljs-comment">// 注意我们从0开始！</span><br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,   <span class="hljs-comment">// 第一个三角形</span><br>    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    <span class="hljs-comment">// 第二个三角形</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>索引数组将被提供给我们的EBO，以指定哪些顶点将用于创建三角形。这个数组将使用顶点0、1和3创建一个三角形，使用顶点1、2和3创建第二个三角形。</p>
<p>接下来，在属性下面，添加以下行：int ElementBufferObject。</p>
<p>现在，在OnLoad中，在初始化VertexBufferObject的地方下面，我们以类似的方式初始化ElementBufferObject：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">ElementBufferObject = GL.GenBuffer();<br>GL.BindBuffer(BufferTarget.ElementArrayBuffer, ElementBufferObject);<br>GL.BufferData(BufferTarget.ElementArrayBuffer, indices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">uint</span>), indices, BufferUsageHint.StaticDraw);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>警告：绑定元素数组缓冲区是特殊的，只有在当前绑定了VAO时才能绑定。从概念上讲，它可以被认为是VAO拥有绑定槽。如果解绑VAO，则元素数组缓冲区仍然绑定到VAO！</p>
</blockquote>
<p>这几乎和使用VBO的方式完全一样！大多数OpenGL的缓冲区类型都会遵循这种模式：使用GL.GenBuffer()创建，使用GL.BindBuffer进行绑定，然后使用GL.BufferData添加数据。</p>
<p>现在，EBO已经准备好了。在OnRenderFrame中，用以下内容替换DrawArrays的调用：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>这些参数依次是：</p>
<p>图元类型。和上次一样，我们想要使用原始的三角形。 要绘制的顶点数。我们使用索引的长度来绘制所有内容。 EBO元素的类型。无符号整型。 我们要绘制的偏移量。因为我们想要绘制所有内容，所以我们只使用0。</p>
<p>就是这样！现在如果运行你的程序，你应该能够看到你有一个矩形，而不是一个三角形。</p>
<h2 id="着色器-1"><a href="#着色器-1" class="headerlink" title="着色器"></a>着色器</h2><p>如在入门使用章节中所述，着色器是在GPU上运行的小程序。这些程序针对图形管线的每个特定部分运行。从基本意义上讲，着色器不过是将输入转换为输出的程序。着色器也是非常隔离的程序，它们不允许彼此通信；它们之间唯一的通信方式是通过它们的输入和输出。</p>
<p>在前一章中，我们简要介绍了着色器及其如何正确使用。现在我们将以更一般的方式解释着色器，特别是OpenGL着色语言。</p>
<h3 id="GLSL（OpenGL着色语言）"><a href="#GLSL（OpenGL着色语言）" class="headerlink" title="GLSL（OpenGL着色语言）"></a>GLSL（OpenGL着色语言）</h3><p>着色器是用类似C的语言GLSL编写的。GLSL专门用于图形处理，并包含针对向量和矩阵操作的有用特性。</p>
<p>着色器总是以版本声明开头，然后是一系列的输入和输出变量、uniform变量以及它的主函数。每个着色器的入口点都在它的主函数中，在那里我们处理任何输入变量并将结果输出到它的输出变量中。如果你不知道uniform是什么，不用担心，我们马上就会讲到。</p>
<p>一个着色器通常具有以下结构：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version version_number</span><br><span class="hljs-keyword">in</span> type in_variable_name;<br><span class="hljs-keyword">in</span> type in_variable_name;<br><br><span class="hljs-keyword">out</span> type out_variable_name;<br><br><span class="hljs-keyword">uniform</span> type uniform_name;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>  <span class="hljs-comment">// 处理输入并进行一些奇怪的图形处理</span><br>  ...<br>  <span class="hljs-comment">// 将处理后的内容输出到输出变量</span><br>  out_variable_name = weird_stuff_we_processed;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们特别谈论顶点着色器时，每个输入变量也被称为顶点属性。我们可以声明的顶点属性数量受到硬件限制。OpenGL保证至少有16个4分量的顶点属性可用，但一些硬件可能允许更多，您可以通过查询GL_MAX_VERTEX_ATTRIBS来获取：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> nrAttributes = <span class="hljs-number">0</span>;<br>GL.GetInteger(GetPName.MaxVertexAttribs, <span class="hljs-keyword">out</span> nrAttributes);<br>Console.WriteLine(<span class="hljs-string">&quot;支持的最大顶点属性数量：&quot;</span> + nrAttributes);<br></code></pre></td></tr></table></figure>

<p>这通常返回至少16的最小值，对于大多数情况来说应该足够了。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>与任何其他编程语言一样，GLSL具有用于指定我们想要使用的变量类型的数据类型。GLSL具有大多数我们从C语言等语言中了解的默认基本类型：int、float、double、uint和bool。GLSL还具有两种容器类型，我们将经常使用它们，即向量和矩阵。我们将在以后的章节中讨论矩阵。</p>
<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>在GLSL中，向量是一个包含任何基本类型中提到的1、2、3或4个组件的容器。它们可以采用以下形式（n代表组件的数量）：</p>
<ul>
<li>vecn：n个浮点数的默认向量。</li>
<li>bvecn：n个布尔值的向量。</li>
<li>ivecn：n个整数的向量。</li>
<li>uvecn：n个无符号整数的向量。</li>
<li>dvecn：n个双精度组件的向量。</li>
</ul>
<p>大多数时候，我们将使用基本的vecn，因为对于大多数情况来说，float类型已经足够了。</p>
<p>可以通过vec.x来访问向量的组件，其中x是向量的第一个组件。您可以使用.x、.y、.z和.w来分别访问它们的第一个、第二、第三和第四个组件。GLSL还允许您使用rgba表示颜色或使用stpq表示纹理坐标，以访问相同的组件。</p>
<p>向量数据类型允许进行一些有趣且灵活的组件选择，称为 swizzling。Swizzling允许我们使用以下语法：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> someVec;<br><span class="hljs-type">vec4</span> differentVec = someVec.xyxx;<br><span class="hljs-type">vec3</span> anotherVec = differentVec.zyw;<br><span class="hljs-type">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;<br></code></pre></td></tr></table></figure>

<p>您可以使用最多4个字母的任意组合来创建一个新的向量（相同类型的）只要原始向量具有这些组件；例如，不允许访问vec2的.z组件。我们还可以将向量作为参数传递给不同的向量构造函数调用，从而减少所需的参数数量：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> vect = <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span>);<br><span class="hljs-type">vec4</span> result = <span class="hljs-type">vec4</span>(vect, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><span class="hljs-type">vec4</span> otherResult = <span class="hljs-type">vec4</span>(result.xyz, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure>

<p>因此，向量是一种灵活的数据类型，我们可以用它来处理各种输入和输出。在本书中，您将看到许多关于如何创造性地管理向量的示例。</p>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>着色器本身是很好的小程序，但它们是整体的一部分，因此我们希望在各个着色器上有输入和输出，以便我们可以移动数据。GLSL专门为此目的定义了in和out关键字。每个着色器都可以使用这些关键字指定输入和输出，其中输出变量与下一个着色器阶段的输入变量匹配时，它们将被传递。然而，顶点着色器和片段着色器有所不同。</p>
<p>顶点着色器应该接收某种形式的输入，否则它将是相当无效的。顶点着色器的输入与众不同，它直接从顶点数据中接收输入。为了定义顶点数据的组织方式，我们使用位置元数据来指定输入变量，以便我们可以在CPU上配置顶点属性。我们在前一章中已经看到了这一点，即layout（location &#x3D; 0）。因此，顶点着色器需要额外的布局规范来指定其输入，以便我们可以将其与顶点数据链接起来。</p>
<p>也可以省略layout（location &#x3D; 0）规范，并在OpenGL代码中通过glGetAttribLocation查询属性位置，但我更喜欢在顶点着色器中设置它们。这样更容易理解，也节省了您（和OpenGL）一些工作。</p>
<p>另一个例外是，片段着色器需要一个vec4颜色输出变量，因为片段着色器需要生成最终的输出颜色。如果您未在片段着色器中指定输出颜色，则这些片段的颜色缓冲输出将未定义（通常意味着OpenGL将它们渲染为黑色或白色）。</p>
<p>因此，如果我们想要从一个着色器发送数据到另一个着色器，我们必须在发送着色器中声明一个输出，在接收着色器中声明一个类似的输入。当两侧的类型和名称相等时，OpenGL将这些变量链接在一起，然后可以在着色器之间发送数据（这是在链接程序对象时完成的）。为了向您展示这在实践中是如何工作的，我们将修改上一章中的着色器，让顶点着色器决定片段着色器的颜色。</p>
<h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos; <span class="hljs-comment">// 位置变量在位置0处</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> vertexColor; <span class="hljs-comment">// 向片段着色器指定一个颜色输出</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// 将vec3直接传递给vec4的构造函数</span><br>    vertexColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// 将输出变量设置为深红色</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> vertexColor; <span class="hljs-comment">// 来自顶点着色器的输入变量（名称和类型相同）</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = vertexColor;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>您可以看到，我们声明了一个vertexColor变量作为vec4输出，在顶点着色器中设置了它，并在片段着色器中声明了一个类似的vertexColor输入。由于它们都具有相同的类型和名称，片段着色器中的vertexColor与顶点着色器中的vertexColor链接在一起。由于我们在顶点着色器中将颜色设置为深红色，因此结果片段应该也是深红色。</p>
<h3 id="Uniforms"><a href="#Uniforms" class="headerlink" title="Uniforms"></a>Uniforms</h3><p>统一变量是另一种将数据从CPU上的应用程序传递到GPU上的着色器的方式。然而，与顶点属性相比，统一变量稍有不同。首先，统一变量是全局的。全局意味着每个着色器程序对象中的统一变量都是唯一的，并且可以在着色器程序的任何阶段的任何着色器中访问。其次，无论您将统一变量的值设置为什么，统一变量都会保持其值，直到被重新设置或更新为止。</p>
<p>要在GLSL中声明一个统一变量，我们只需在着色器中添加uniform关键字，然后加上一个类型和一个名称。从那时起，我们就可以在着色器中使用新声明的统一变量。让我们看看这次我们能否通过一个统一变量来设置三角形的颜色：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br>  <br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec4</span> ourColor; <span class="hljs-comment">// 我们将在OpenGL代码中设置这个变量。</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = ourColor;<br>&#125;   <br></code></pre></td></tr></table></figure>

<p>我们在片段着色器中声明了一个uniform vec4 ourColor，并将片段的输出颜色设置为该统一变量的内容。由于统一变量是全局变量，我们可以在任何我们想要的着色器阶段定义它们，所以不需要再通过顶点着色器来将数据传递到片段着色器。我们在顶点着色器中没有使用这个统一变量，因此也不需要在那里定义它。</p>
<p>如果您声明了一个在GLSL代码中未被使用的统一变量，编译器将在编译后的版本中静默删除该变量，这是导致一些令人沮丧的错误的原因；请牢记这一点！</p>
<p>目前这个统一变量是空的；我们还没有向统一变量中添加任何数据，所以让我们尝试一下。我们首先需要找到着色器中统一变量属性的索引&#x2F;位置。一旦我们有了统一变量的索引&#x2F;位置，我们就可以更新它的值。我们不再将单一颜色传递到片段着色器中，让我们通过随时间逐渐改变颜色来增添一些色彩：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">double</span> timeValue = _timer.Elapsed.TotalSeconds;<br><span class="hljs-built_in">float</span> greenValue = (<span class="hljs-built_in">float</span>)Math.Sin(timeValue) / <span class="hljs-number">2.0f</span> + <span class="hljs-number">0.5f</span>;<br><span class="hljs-built_in">int</span> vertexColorLocation = GL.GetUniformLocation(_shader.Handle, <span class="hljs-string">&quot;ourColor&quot;</span>);<br>GL.Uniform4(vertexColorLocation, <span class="hljs-number">0.0f</span>, greenValue, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br></code></pre></td></tr></table></figure>

<p>首先，我们通过StopWatch对象_calld_timer获取了运行时间（以秒为单位）。然后，我们使用sin函数将颜色在0.0 - 1.0范围内变化，并将结果存储在greenValue中。</p>
<p>然后，我们使用glGetUniformLocation查询ourColor统一变量的位置。我们向查询函数提供了着色器程序和统一变量的名称（我们要从中检索位置的名称）。如果glGetUniformLocation返回-1，则表示找不到位置。最后，我们可以使用glUniform4f函数设置统一变量的值。请注意，查找统一变量的位置不需要您首先使用着色器程序，但是更新统一变量需要您首先使用程序（通过调用glUseProgram），因为它会将统一变量设置为当前活动的着色器程序。</p>
<p>由于OpenGL本质上是一个C库，它不支持函数重载，因此无论函数是否可以使用不同类型进行调用，OpenGL都为每种所需类型定义了新的函数；glUniform就是一个很好的例子。该函数需要用于要设置的统一变量类型的特定后缀。一些可能的后缀包括：</p>
<ul>
<li><p>f：该函数希望值为float。</p>
</li>
<li><p>i：该函数希望值为int。</p>
</li>
<li><p>ui：该函数希望值为unsigned int。</p>
</li>
<li><p>3f：该函数希望值为3个float。</p>
</li>
<li><p>fv：该函数希望值为float向量&#x2F;数组。</p>
</li>
</ul>
<p>每当您想要配置OpenGL选项时，只需选择与您的类型对应的重载函数。在我们的情况下，我们想要单独设置统一变量的4个浮点数，因此我们通过glUniform4f传递我们的数据（请注意，我们也可以使用fv版本）。</p>
<p>现在我们知道如何设置统一变量的值了，我们可以将它们用于渲染。如果我们希望颜色逐渐改变，我们希望在每一帧更新这个统一变量，否则三角形将保持单一的固定颜色，如果我们只设置一次。因此，我们计算greenValue，并在每次渲染迭代之前更新统一变量：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderFrame</span>(<span class="hljs-params">FrameEventArgs e</span>)</span><br>&#123;<br>    <span class="hljs-keyword">base</span>.OnRenderFrame(e);<br><br>    <span class="hljs-comment">// 渲染</span><br>    <span class="hljs-comment">// 清除颜色缓冲区</span><br>    GL.Clear(ClearBufferMask.ColorBufferBit);<br><br>    <span class="hljs-comment">// 确保激活着色器</span><br>    _shader.Use();<br><br>    <span class="hljs-comment">// 更新统一变量颜色</span><br>    <span class="hljs-built_in">double</span> timeValue = _timer.Elapsed.TotalSeconds;<br>    <span class="hljs-built_in">float</span> greenValue = (<span class="hljs-built_in">float</span>)Math.Sin(timeValue) / <span class="hljs-number">2.0f</span> + <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-built_in">int</span> vertexColorLocation = GL.GetUniformLocation(_shader.Handle, <span class="hljs-string">&quot;ourColor&quot;</span>);<br>    GL.Uniform4(vertexColorLocation, <span class="hljs-number">0.0f</span>, greenValue, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br><br><br>    <span class="hljs-comment">// 现在渲染三角形</span><br>    GL.BindVertexArray(_vertexArrayObject);<br>    GL.DrawArrays(PrimitiveType.Triangles, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 交换缓冲区</span><br>    SwapBuffers();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码是前一段代码的一个相对简单的改编。这一次，在绘制三角形之前，我们每帧更新一次统一变量的值。如果您正确更新了统一变量，您应该可以看到三角形的颜色从绿色逐渐变为黑色，然后再变回绿色。</p>
<p>正如您所看到的，统一变量是一个有用的工具，用于设置每一帧可能会变化的属性，或者用于在应用程序和着色器之间交换数据，但是如果我们想为每个顶点设置一个颜色怎么办？在这种情况下，我们必须为每个顶点声明许多统一变量。更好的解决方案是在顶点属性中包含更多的数据，这就是我们接下来要做的事情。</p>
<h3 id="更多属性"><a href="#更多属性" class="headerlink" title="更多属性"></a>更多属性</h3><p>在上一章中，我们学习了如何填充 VBO、配置顶点属性指针并将所有数据存储在 VAO 中。这一次，我们还想要向顶点数据中添加颜色数据。我们将颜色数据作为 3 个浮点数添加到顶点数组中。我们分别为三角形的每个角分配了红色、绿色和蓝色：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">float</span>[] _vertices =<br>&#123;<br>    <span class="hljs-comment">// positions        // colors</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// bottom right</span><br>   <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// bottom left</span><br>    <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>    <span class="hljs-comment">// top </span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>由于我们现在要发送更多数据到顶点着色器，因此需要调整顶点着色器以接收颜色值作为顶点属性输入。请注意，我们使用布局说明符将 aColor 属性的位置设置为 1：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;   <span class="hljs-comment">// the position variable has attribute position 0</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aColor; <span class="hljs-comment">// the color variable has attribute position 1</span><br>  <br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> ourColor; <span class="hljs-comment">// output a color to the fragment shader</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    ourColor = aColor; <span class="hljs-comment">// set ourColor to the input color we got from the vertex data</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于我们不再使用 uniform 来设置片段的颜色，而是使用了 ourColor 输出变量，因此还需要更改片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;  <br><span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> ourColor;<br>  <br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = <span class="hljs-type">vec4</span>(ourColor, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于我们添加了另一个顶点属性并更新了 VBO 的内存，因此必须重新配置顶点属性指针。VBO 内存中的更新数据现在如下所示：</p>
<p><img src="/4-vertex_attribute_pointer_interleaved.png" srcset="/img/loading.gif" lazyload></p>
<p>了解了当前的布局，我们可以使用 glVertexAttribPointer 更新顶点格式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>GL.VertexAttribPointer(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br>GL.EnableVertexAttribArray(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>glVertexAttribPointer 的前几个参数相对简单。这次我们在属性位置 1 上配置了顶点属性。颜色值有 3 个浮点数大小，并且我们不对值进行归一化处理。</p>
<p>由于我们现在有两个顶点属性，因此必须重新计算步幅值。为了获取数据数组中的下一个属性值（例如位置向量的下一个 x 分量），我们必须向右移动 6 个浮点数，其中三个用于位置值，三个用于颜色值。这给了我们步幅值为 6 乘以浮点数的大小（&#x3D; 24 字节）。此外，这次我们必须指定偏移量。对于每个顶点，位置顶点属性首先出现，因此偏移量为 0。颜色属性在位置数据之后开始，因此偏移量为 3 * sizeof(float) 字节（&#x3D; 12 字节）。</p>
<p>运行应用程序应该会产生以下图像：</p>
<p><img src="/%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7.png" srcset="/img/loading.gif" lazyload></p>
<p>图像可能不是您预期的，因为我们只提供了 3 种颜色，而不是我们现在看到的庞大颜色调色板。这一切都是片段着色器中称为片段插值的结果。当渲染三角形时，光栅化阶段通常会产生比最初指定的顶点更多的片段。然后，光栅化器根据它们在三角形形状上的位置确定每个片段的位置。基于这些位置，它会对所有片段着色器的输入变量进行插值。举个例子，假设我们有一条线，上点是绿色，下点是蓝色。如果片段着色器在线的 70% 位置处运行，那么其结果的颜色输入属性将是绿色和蓝色的线性组合；更准确地说是：30% 的蓝色和 70% 的绿色。</p>
<p>这正是在三角形中发生的情况。我们有 3 个顶点，因此有 3 种颜色，从三角形的像素来看，它可能包含大约 50000 个片段，片段着色器在这些像素之间进行颜色插值。如果您仔细观察颜色，您会发现这一切都是有道理的：从红色到蓝色首先变成紫色，然后变成蓝色。片段插值应用于所有片段着色器的输入属性。</p>
<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>我们学到了通过为每个顶点指定颜色来为对象添加更多细节，从而创建一些有趣的图像。然而，为了获得相当程度的逼真感，我们必须拥有许多顶点，以便我们可以指定许多颜色。这会增加相当多的额外开销，因为每个模型都需要更多的顶点，而且每个顶点都需要一个颜色属性。</p>
<p>艺术家和程序员通常更喜欢使用纹理。纹理是一个2D图像（虽然存在1D和3D纹理，但它们并不常见），用于为对象添加细节；可以将纹理想象成一个带有漂亮砖块图像（例如）的纸张，整齐地折叠在你的3D房屋上，使得你的房子看起来像是外部有石头覆盖。由于我们可以在单个图像中插入许多细节，因此我们可以产生这样的幻觉，即对象非常详细，而无需指定额外的顶点。</p>
<p>除了图像之外，纹理还可以用于存储大量数据以发送到着色器，但我们将把这留到另一个话题。</p>
<p>下面你将看到一个砖墙的纹理图像被映射到前面教程中的三角形上。</p>
<p><img src="/wall.jpg" srcset="/img/loading.gif" lazyload></p>
<p>为了将纹理映射到三角形上，我们需要告诉三角形的每个顶点它对应纹理的哪一部分。因此，每个顶点都应该有一个与之关联的纹理坐标，指定从纹理图像中采样的部分。然后，片段插值会为其他片段完成剩余工作。</p>
<p>纹理坐标在x和y轴上的范围是从0到1（记住我们使用的是2D纹理图像）。使用纹理坐标检索纹理颜色称为采样。纹理坐标从纹理图像的左下角（0,0）开始，到右上角（1,1）结束。下面的图像展示了我们如何将纹理坐标映射到三角形上：</p>
<p><img src="/5-tex_coords.png" srcset="/img/loading.gif" lazyload></p>
<p>我们为三角形指定了3个纹理坐标点。我们希望三角形的左下边对应纹理的左下边，因此我们对三角形的左下顶点使用了纹理坐标(0,0)。对于右下边，我们使用了(1,0)作为纹理坐标。三角形的顶部应该对应纹理图像的顶部中心，因此我们将(0.5,1.0)作为其纹理坐标。我们只需将3个纹理坐标传递给顶点着色器，然后顶点着色器将这些坐标传递给片段着色器，后者将为每个片段精确插值所有纹理坐标。</p>
<p>结果的纹理坐标如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">float</span>[] texCoords = &#123;<br>    <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// lower-left corner  </span><br>    <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// lower-right corner</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">1.0f</span>   <span class="hljs-comment">// top-center corner</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>纹理采样具有宽泛的解释，并且可以通过许多不同的方式进行。因此，我们的任务是告诉OpenGL应该如何对其纹理进行采样。</p>
<h3 id="纹理包裹"><a href="#纹理包裹" class="headerlink" title="纹理包裹"></a>纹理包裹</h3><p>纹理坐标通常范围在 (0,0) 到 (1,1) 之间，但如果我们指定超出此范围的坐标会发生什么？OpenGL 的默认行为是重复纹理图像（基本上忽略浮点纹理坐标的整数部分），但OpenGL 提供了更多选项：</p>
<ul>
<li>Repeat（重复）：纹理的默认行为。重复纹理图像。</li>
<li>MirroredRepeat（镜像重复）：与 GL_REPEAT 相同，但在每次重复时镜像图像。</li>
<li>ClampToEdge（夹取到边缘）：将坐标夹取在 0 和 1 之间。结果是，较高的坐标将夹取到边缘，导致边缘拉伸的图案。</li>
<li>ClampToBorder（夹取到边界）：超出范围的坐标现在被赋予用户指定的边界颜色。</li>
</ul>
<p>每个选项在使用纹理坐标超出默认范围时都会产生不同的视觉效果。让我们看看这些选项在示例纹理图像上的效果：</p>
<p><img src="/5-texture_wrapping.png" srcset="/img/loading.gif" lazyload></p>
<p>上述提到的每个选项都可以通过 GL.TexParameter 函数针对每个坐标轴（s、t（如果您使用 3D 纹理，则为 p，相当于 x、y、z））进行设置：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：您必须将枚举强制转换为 int 才能使 GL.TexParameter 接受它。</p>
</blockquote>
<p>第一个参数指定纹理目标；我们使用 2D 纹理，因此纹理目标是 TextureTarget.Texture2D。</p>
<p>第二个参数要求我们告诉它我们想设置哪个选项以及对应的纹理轴。我们想配置 WRAP 选项，并为 S 和 T 轴指定它。</p>
<p>最后一个参数要求我们传入我们想要的纹理包裹模式，在这种情况下，OpenGL 将使用 TextureWrapMode.Repeat 设置当前活动纹理的纹理包裹选项。</p>
<p>如果我们选择 TextureWrapMode.ClampToBorder 选项，我们还应该指定边界颜色。这可以使用 fv 版本的 glTexParameter 函数来完成，其中选项为 TextureParameterName.TextureBorderColor，我们传入一个边界颜色值的浮点数组：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">float</span>[] borderColor = &#123; <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureBorderColor, borderColor);<br></code></pre></td></tr></table></figure>

<h3 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h3><p>纹理坐标不依赖于分辨率，而可以是任何浮点值，因此OpenGL必须确定要将纹理坐标映射到哪个纹理像素（也称为纹素）。如果您有一个非常大的对象和一个低分辨率的纹理，这变得尤为重要。您现在可能已经猜到，OpenGL也有针对这种纹理过滤的选项。有几个选项可用，但现在我们将讨论最重要的选项：最近和线性。</p>
<p>最近（也称为最近邻过滤）是OpenGL的默认纹理过滤方法。当设置为最近时，OpenGL选择最靠近纹理坐标的像素中心。下面您可以看到4个像素，十字表示确切的纹理坐标。左上角的纹素其中心最靠近纹理坐标，因此被选为采样颜色：</p>
<p><img src="/5-texture_filter_nearest.png" srcset="/img/loading.gif" lazyload></p>
<p>线性（也称为（双）线性过滤）从纹理坐标的相邻纹素中取得一个插值的值，从而近似计算出纹素之间的颜色。纹理坐标到纹素中心的距离越小，该纹素的颜色就对采样颜色贡献越大。下面我们可以看到返回的相邻像素的混合颜色：</p>
<p><img src="/5-texture_filter_linear.png" srcset="/img/loading.gif" lazyload></p>
<p>但是，这种纹理过滤方法的视觉效果是什么呢？让我们看看在大对象上使用低分辨率纹理时这些方法的工作方式（因此纹理被放大，单个纹素是可见的）：</p>
<p><img src="/5-texture_filtering.png" srcset="/img/loading.gif" lazyload></p>
<p>最近邻过滤产生了明显的像素块模式，我们可以清楚地看到形成纹理的像素，而线性过滤产生了更平滑的模式，单个像素不太明显。线性过滤产生了更真实的输出，但有些开发人员更喜欢复古、像素化的外观，因此选择了最近邻选项。</p>
<p>纹理过滤可以针对放大和缩小操作（放大或缩小时）进行设置，因此您可以在纹理被缩小时使用最近邻过滤，而在纹理被放大时使用线性过滤。因此，我们必须通过GL.TexParameter为两种选项指定过滤方法。代码应该类似于设置包装方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.Nearest);<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br></code></pre></td></tr></table></figure>

<h3 id="Mipmaps"><a href="#Mipmaps" class="headerlink" title="Mipmaps"></a>Mipmaps</h3><p>想象一下，我们有一个庞大的房间，里面摆放着成千上万个物体，每个物体都附有一个贴图。远处的物体和近处的物体都使用同样的高分辨率贴图。由于远处的物体只产生少量片段，OpenGL 在从高分辨率贴图中为片段选择正确的颜色值时会遇到困难，因为它必须为跨越贴图大部分区域的片段选择一个贴图颜色。这将在小物体上产生可见的伪影，而且在小物体上使用高分辨率贴图也浪费了内存和计算资源。</p>
<p>为了解决这个问题，OpenGL 引入了一种叫做 Mipmaps 的概念，它基本上是一组贴图图像，其中每个后续的贴图都是前一个贴图的一半大小。Mipmaps 背后的思想应该很容易理解：在距离观察者一定距离后，OpenGL 将使用最适合对象距离的不同 Mipmap 贴图。因为对象远处，较小的分辨率对用户来说不会明显。此外，Mipmaps 还有一个额外的好处，就是它们对性能也有好处。让我们更仔细地看看 Mipmapped 贴图是什么样子：</p>
<p><img src="/5-mipmaps.png" srcset="/img/loading.gif" lazyload></p>
<p>手动创建每个贴图图像的 Mipmapped 贴图集合很麻烦，但幸运的是，OpenGL 可以在我们创建贴图后通过一次调用 GL.GenerateMipmap(GenerateMipmapTarget.Texture2D) 来为我们完成所有工作。稍后在贴图教程中，您将看到如何使用此函数。</p>
<p>在渲染过程中切换 Mipmap 级别时，OpenGL 可能会显示一些伪影，例如两个 Mipmap 层之间可见的锐利边缘。就像普通的贴图过滤一样，我们也可以使用 Nearest 和 Linear 过滤来在 Mipmap 级别之间进行切换。我们可以用以下四个选项之一来指定 Mipmap 级别之间的过滤方法：</p>
<ul>
<li>NearestMipmapNearest：选择最接近的 Mipmap 来匹配像素大小，并使用最近邻插值进行贴图采样。</li>
<li>LinearMipmapNearest：选择最接近的 Mipmap 级别，并使用线性插值进行采样。</li>
<li>NearestMipmapLinear：在最接近像素大小的两个 Mipmap 之间进行线性插值，并通过最近邻插值采样贴图。</li>
<li>LinearMipmapLinear：在最接近的两个 Mipmap 之间进行线性插值，并通过线性插值采样贴图。</li>
</ul>
<p>与贴图过滤一样，我们可以使用 GL.TexParameter 将过滤方法设置为上述四种方法之一：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.LinearMipmapLinear);<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br></code></pre></td></tr></table></figure>

<p>一个常见的错误是将其中一种 Mipmap 过滤选项设置为放大过滤器。这没有任何效果，因为 Mipmaps 主要用于当贴图缩小时：贴图放大不使用 Mipmaps，给它一个 Mipmap 过滤选项将生成一个 OpenGL GL_INVALID_ENUM 错误代码。</p>
<h3 id="加载和创建纹理"><a href="#加载和创建纹理" class="headerlink" title="加载和创建纹理"></a>加载和创建纹理</h3><p>现在我们已经创建了纹理，我们需要修改我们的着色器和顶点来使用纹理。</p>
<p>首先，用以下顶点数组替换：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">float</span>[] vertices =<br>&#123;<br>    <span class="hljs-comment">//Position          Texture coordinates</span><br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-comment">// 右上</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 右下</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下</span><br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>  <span class="hljs-comment">// 左上</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>回想一下我们之前讨论的纹理坐标以及它们的工作原理。我们将它们添加到每个顶点中。</p>
<p>接下来，我们将修改顶点属性位置以将纹理坐标发送到着色器。</p>
<p>用以下调用替换您对VertexAttribPointer的调用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.VertexAttribPointer(vertexLocation, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>几乎完全相同，只是将步长从3 * sizeof(float)更改为5 * sizeof(float)以适应新的纹理坐标。</p>
<p>在其下面，添加以下行：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> texCoordLocation = shader.GetAttribLocation(<span class="hljs-string">&quot;aTexCoord&quot;</span>);<br>GL.EnableVertexAttribArray(texCoordLocation);<br>GL.VertexAttribPointer(texCoordLocation, <span class="hljs-number">2</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br></code></pre></td></tr></table></figure>

<p>再次几乎完全与上次调用相同，只是数据包数从3变为2，并且初始偏移量为3 * sizeof(float)。</p>
<p>现在，我们需要修改我们的着色器。首先是顶点着色器。新代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoord;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>    texCoord = aTexCoord;<br><br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们添加了另一个输入变量aTexCoord，它将是纹理坐标。我们将其原样转发到输出变量texCoord，以便片段着色器可以使用它。说到片段着色器，接下来是它：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outputColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture0;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    outputColor = <span class="hljs-built_in">texture</span>(texture0, texCoord);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们看到一个全新的变量类型sampler2D。简单来说，那是着色器中纹理的表示。</p>
<p>最多可以一次绑定16个不同的纹理（取决于您的硬件，可能更多，但OpenGL要求至少16个）。在下一个例子中，我将向您展示如何同时使用多个纹理。但是，现在我们不需要做其他任何事情。</p>
<p>如果您一切都做对了，当您运行代码时，您应该看到以下内容：</p>
<p><img src="/texture_result.png" srcset="/img/loading.gif" lazyload></p>
<p>祝贺您绘制了您的第一个纹理！下次，我将演示如何同时绘制多个纹理。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><h4 id="Form1-cs"><a href="#Form1-cs" class="headerlink" title="Form1.cs"></a>Form1.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Diagnostics;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> OpenTK.WinForms;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Windows.Forms.VisualStyles.VisualStyleElement;<br><span class="hljs-keyword">using</span> OpenTK.Mathematics;<br><span class="hljs-keyword">using</span> OpenTK.Windowing.GraphicsLibraryFramework;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br><br>        <span class="hljs-built_in">float</span>[] vertices =<br>        &#123;<br>            <span class="hljs-comment">//Position          Texture coordinates</span><br>             <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-comment">// 右上</span><br>             <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 右下</span><br>            <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下</span><br>            <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>  <span class="hljs-comment">// 左上</span><br>        &#125;;<br>        <span class="hljs-built_in">uint</span>[] indices = &#123;  <span class="hljs-comment">// note that we start from 0!</span><br>            <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,   <span class="hljs-comment">// first triangle</span><br>            <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    <span class="hljs-comment">// second triangle</span><br>        &#125;;<br>        <span class="hljs-built_in">int</span> VertexBufferObject;<br>        <span class="hljs-built_in">int</span> vertexArrayObject;<br>        <span class="hljs-built_in">int</span> ElementBufferObject;<br>        <span class="hljs-keyword">private</span> Texture _texture;<br>        Shader shader;<br>        Stopwatch timer;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Form1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.ClearColor(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>            <br><br>            <span class="hljs-comment">// Create and bind VAO</span><br>            vertexArrayObject = GL.GenVertexArray();<br>            GL.BindVertexArray(vertexArrayObject);<br><br>            <span class="hljs-comment">// Create and bind VBO</span><br>            VertexBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>            <span class="hljs-comment">// Provide vertex data to the VBO</span><br>            GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><br>            ElementBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ElementArrayBuffer, ElementBufferObject);<br>            GL.BufferData(BufferTarget.ElementArrayBuffer, indices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">uint</span>), indices, BufferUsageHint.StaticDraw);<br><br>            shader = <span class="hljs-keyword">new</span> Shader(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.vert&quot;</span>, <span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.frag&quot;</span>);<br>            timer = <span class="hljs-keyword">new</span> Stopwatch();<br>            shader.Use();<br><br>            <span class="hljs-comment">// Specify the vertex attribute pointers</span><br>            GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>            GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-built_in">int</span> texCoordLocation = GL.GetAttribLocation(shader.Handle, <span class="hljs-string">&quot;aTexCoord&quot;</span>);<br>            GL.EnableVertexAttribArray(texCoordLocation);<br>            GL.VertexAttribPointer(texCoordLocation, <span class="hljs-number">2</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br><br>            _texture = Texture.LoadFromFile(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/Resources/container.png&quot;</span>);<br>            _texture.Use(TextureUnit.Texture0);<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Paint</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, PaintEventArgs e</span>)</span><br>        &#123;<br>            GL.Clear(ClearBufferMask.ColorBufferBit);<br><br>            GL.BindVertexArray(vertexArrayObject);<br><br>            _texture.Use(TextureUnit.Texture0);<br>            shader.Use();<br><br>            GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br><br>            glControl1.SwapBuffers();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_SizeChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> deltaTime</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//var input = KeyboardState;</span><br><br>            <span class="hljs-comment">//if (input.IsKeyDown(Keys.Escape))</span><br>            <span class="hljs-comment">//&#123;</span><br>            <span class="hljs-comment">//    Close();</span><br>            <span class="hljs-comment">//&#125;</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">timer1_Tick</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">float</span> deltaTime = (<span class="hljs-built_in">float</span>)timer.Elapsed.TotalSeconds;<br>            timer.Restart();<br><br>            OnUpdate(deltaTime);<br>            <br>            glControl1.Invalidate();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Texture-cs"><a href="#Texture-cs" class="headerlink" title="Texture.cs"></a>Texture.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> System.Drawing;<br><span class="hljs-keyword">using</span> System.Drawing.Imaging;<br><span class="hljs-keyword">using</span> PixelFormat = OpenTK.Graphics.OpenGL.PixelFormat;<br><span class="hljs-keyword">using</span> StbImageSharp;<br><span class="hljs-keyword">using</span> System.IO;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Texture</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Handle;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture <span class="hljs-title">LoadFromFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// Generate handle</span><br>            <span class="hljs-built_in">int</span> handle = GL.GenTexture();<br><br>            <span class="hljs-comment">// Bind the handle</span><br>            GL.ActiveTexture(TextureUnit.Texture0);<br>            GL.BindTexture(TextureTarget.Texture2D, handle);<br><br>            <span class="hljs-comment">// For this example, we&#x27;re going to use .NET&#x27;s built-in System.Drawing library to load textures.</span><br><br>            <span class="hljs-comment">// OpenGL has it&#x27;s texture origin in the lower left corner instead of the top left corner,</span><br>            <span class="hljs-comment">// so we tell StbImageSharp to flip the image when loading.</span><br>            StbImage.stbi_set_flip_vertically_on_load(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// Here we open a stream to the file and pass it to StbImageSharp to load.</span><br>            <span class="hljs-keyword">using</span> (Stream stream = File.OpenRead(path))<br>            &#123;<br>                ImageResult image = ImageResult.FromStream(stream, ColorComponents.RedGreenBlueAlpha);<br><br>                <span class="hljs-comment">// Now that our pixels are prepared, it&#x27;s time to generate a texture. We do this with GL.TexImage2D.</span><br>                <span class="hljs-comment">// Arguments:</span><br>                <span class="hljs-comment">//   The type of texture we&#x27;re generating. There are various different types of textures, but the only one we need right now is Texture2D.</span><br>                <span class="hljs-comment">//   Level of detail. We can use this to start from a smaller mipmap (if we want), but we don&#x27;t need to do that, so leave it at 0.</span><br>                <span class="hljs-comment">//   Target format of the pixels. This is the format OpenGL will store our image with.</span><br>                <span class="hljs-comment">//   Width of the image</span><br>                <span class="hljs-comment">//   Height of the image.</span><br>                <span class="hljs-comment">//   Border of the image. This must always be 0; it&#x27;s a legacy parameter that Khronos never got rid of.</span><br>                <span class="hljs-comment">//   The format of the pixels, explained above. Since we loaded the pixels as RGBA earlier, we need to use PixelFormat.Rgba.</span><br>                <span class="hljs-comment">//   Data type of the pixels.</span><br>                <span class="hljs-comment">//   And finally, the actual pixels.</span><br>                GL.TexImage2D(TextureTarget.Texture2D, <span class="hljs-number">0</span>, PixelInternalFormat.Rgba, image.Width, image.Height, <span class="hljs-number">0</span>, PixelFormat.Rgba, PixelType.UnsignedByte, image.Data);<br>            &#125;<br><br>            <span class="hljs-comment">// Now that our texture is loaded, we can set a few settings to affect how the image appears on rendering.</span><br><br>            <span class="hljs-comment">// First, we set the min and mag filter. These are used for when the texture is scaled down and up, respectively.</span><br>            <span class="hljs-comment">// Here, we use Linear for both. This means that OpenGL will try to blend pixels, meaning that textures scaled too far will look blurred.</span><br>            <span class="hljs-comment">// You could also use (amongst other options) Nearest, which just grabs the nearest pixel, which makes the texture look pixelated if scaled too far.</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The default settings for both of these are LinearMipmap. If you leave these as default but don&#x27;t generate mipmaps,</span><br>            <span class="hljs-comment">// your image will fail to render at all (usually resulting in pure black instead).</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.Linear);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br><br>            <span class="hljs-comment">// Now, set the wrapping mode. S is for the X axis, and T is for the Y axis.</span><br>            <span class="hljs-comment">// We set this to Repeat so that textures will repeat when wrapped. Not demonstrated here since the texture coordinates exactly match</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br><br>            <span class="hljs-comment">// Next, generate mipmaps.</span><br>            <span class="hljs-comment">// Mipmaps are smaller copies of the texture, scaled down. Each mipmap level is half the size of the previous one</span><br>            <span class="hljs-comment">// Generated mipmaps go all the way down to just one pixel.</span><br>            <span class="hljs-comment">// OpenGL will automatically switch between mipmaps when an object gets sufficiently far away.</span><br>            <span class="hljs-comment">// This prevents moiré effects, as well as saving on texture bandwidth.</span><br>            <span class="hljs-comment">// Here you can see and read about the morié effect https://en.wikipedia.org/wiki/Moir%C3%A9_pattern</span><br>            <span class="hljs-comment">// Here is an example of mips in action https://en.wikipedia.org/wiki/File:Mipmap_Aliasing_Comparison.png</span><br>            GL.GenerateMipmap(GenerateMipmapTarget.Texture2D);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Texture(handle);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Texture</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> glHandle</span>)</span><br>        &#123;<br>            Handle = glHandle;<br>        &#125;<br><br>        <span class="hljs-comment">// Activate texture</span><br>        <span class="hljs-comment">// Multiple textures can be bound, if your shader needs more than just one.</span><br>        <span class="hljs-comment">// If you want to do that, use GL.ActiveTexture to set which slot GL.BindTexture binds to.</span><br>        <span class="hljs-comment">// The OpenGL standard requires that there be at least 16, but there can be more depending on your graphics card.</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>(<span class="hljs-params">TextureUnit unit</span>)</span><br>        &#123;<br>            GL.ActiveTexture(unit);<br>            GL.BindTexture(TextureTarget.Texture2D, Handle);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Shader-cs"><a href="#Shader-cs" class="headerlink" title="Shader.cs"></a>Shader.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shader</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Handle &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shader</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> vertexPath, <span class="hljs-built_in">string</span> fragmentPath</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">string</span> VertexShaderSource = File.ReadAllText(vertexPath);<br>            <span class="hljs-built_in">int</span> vertexShader = GL.CreateShader(ShaderType.VertexShader);<br>            GL.ShaderSource(vertexShader, VertexShaderSource);<br>            GL.CompileShader(vertexShader);<br><br><br>            <span class="hljs-built_in">string</span> FragmentShaderSource = File.ReadAllText(fragmentPath);<br>            <span class="hljs-built_in">int</span> fragmentShader = GL.CreateShader(ShaderType.FragmentShader);<br>            GL.ShaderSource(fragmentShader, FragmentShaderSource);<br>            GL.CompileShader(fragmentShader);<br><br>            <span class="hljs-comment">// Create shader program and link shaders</span><br>            Handle = GL.CreateProgram();<br>            GL.AttachShader(Handle, vertexShader);<br>            GL.AttachShader(Handle, fragmentShader);<br>            GL.LinkProgram(Handle);<br><br>            <span class="hljs-comment">// Clean up individual shaders</span><br>            GL.DetachShader(Handle, vertexShader);<br>            GL.DetachShader(Handle, fragmentShader);<br>            GL.DeleteShader(fragmentShader);<br>            GL.DeleteShader(vertexShader);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span><br>        &#123;<br>            GL.UseProgram(Handle);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="shader-vert"><a href="#shader-vert" class="headerlink" title="shader.vert"></a>shader.vert</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoord;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>    texCoord = aTexCoord;<br><br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="shader-frag"><a href="#shader-frag" class="headerlink" title="shader.frag"></a>shader.frag</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outputColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture0;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    outputColor = <span class="hljs-built_in">texture</span>(texture0, texCoord);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="多纹理和纹理单元"><a href="#多纹理和纹理单元" class="headerlink" title="多纹理和纹理单元"></a>多纹理和纹理单元</h2><p>你可能想知道为什么<code>sampler2D</code>变量是一个<code>uniform</code>，如果我们甚至没有使用<code>GL.Uniform*</code>为它分配一些值。使用<code>GL.Uniform1</code>，我们实际上可以为纹理采样器分配一个位置值，这样我们就可以在片段着色器中一次设置多个纹理。纹理的位置更常见地称为纹理单元。纹理的默认单元是0，这是默认的活动纹理单元，因此我们在上一节中没有分配位置；请注意，并非所有的图形驱动程序都会分配默认的纹理单元，因此上一节可能对您没有渲染。</p>
<p>纹理单元的主要目的是允许我们在着色器中使用多于一个纹理。通过为采样器分配纹理单元，我们可以一次绑定多个纹理，只要我们先激活相应的纹理单元。就像GL.BindTexture一样，我们可以使用GL.ActiveTexture激活纹理单元，传入我们想要使用的纹理单元：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.ActiveTexture(TextureUnit.Texture0); <span class="hljs-comment">// 绑定纹理之前先激活纹理单元</span><br>GL.BindTexture(TextureTarget.Texture2D, texture);<br></code></pre></td></tr></table></figure>

<p>激活了一个纹理单元之后，后续的GL.BindTexture调用将把纹理绑定到当前活动的纹理单元。纹理单元Texture0总是默认激活的，所以当使用GL.BindTexture时，我们不需要激活任何纹理单元。</p>
<p>OpenGL应该至少有16个纹理单元供您使用，您可以使用Texture0到Texture15来激活它们。</p>
<p>然而，我们仍然需要编辑片段着色器以接受另一个采样器。现在应该相对简单：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-comment">/* ... */</span><br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture1;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture2;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = <span class="hljs-built_in">mix</span>(<span class="hljs-built_in">texture</span>(texture1, TexCoord), <span class="hljs-built_in">texture</span>(texture2, TexCoord), <span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终的输出颜色现在是两个纹理查找的组合。GLSL的内置mix函数接受两个值作为输入，并根据其第三个参数进行线性插值。如果第三个值是0.0，它将返回第一个输入；如果是1.0，它将返回第二个输入值。值为0.2将返回第一个输入颜色的80%和第二个输入颜色的20%，从而得到两个纹理的混合色。</p>
<p>现在我们想要加载和创建另一个纹理；您现在应该熟悉了这些步骤。确保创建另一个纹理对象，加载图像并使用GL.TexImage2D生成最终的纹理。对于第二个纹理，我们将使用一个学习OpenGL时你的面部表情的图像：</p>
<p>要使用第二个纹理（和第一个纹理），我们需要稍微更改渲染过程，将两个纹理绑定到相应的纹理单元。首先，转到Texture.cs，并像这样修改Use函数：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>(<span class="hljs-params">TextureUnit unit = TextureUnit.Texture0</span>)</span><br>&#123;<br>    GL.ActiveTexture(unit);<br>    GL.BindTexture(TextureTarget.Texture2D, Handle);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后，在OnLoad中添加一个新属性来保存新纹理，并加载它。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Texture texture2;<br><br>...<br><br>texture2 = <span class="hljs-keyword">new</span> Texture(<span class="hljs-string">&quot;awesomeface.png&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>新纹理已经准备好了，现在我们必须设置着色器uniform变量。在Shader.cs中添加以下函数：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetInt</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> location = GL.GetUniformLocation(Handle, name);<br><br>    GL.Uniform1(location, <span class="hljs-keyword">value</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数简化了设置着色器uniform变量的过程。采样器在CPU中表示为整数；将uniform设置为整数，它将检查纹理单元。</p>
<p>在OnLoad中创建纹理后，立即添加以下行：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">shader.SetInt(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">0</span>);<br>shader.SetInt(<span class="hljs-string">&quot;texture2&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>这将uniform纹理1设置为使用纹理单元0中的内容，并将纹理2设置为使用纹理单元1中的内容。</p>
<p>最后，在OnRenderFrame中进行如下修改：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.Clear(ClearBufferMask.ColorBufferBit);<br>GL.BindVertexArray(VertexArrayObject);<br><br>texture.Use(TextureUnit.Texture0);<br>texture2.Use(TextureUnit.Texture1);<br>shader.Use();<br><br>GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br><br>Context.SwapBuffers();<br><br><span class="hljs-keyword">base</span>.OnRenderFrame(e);<br></code></pre></td></tr></table></figure>

<p>绑定了两个纹理并且着色器正确设置后，您现在应该看到以下结果：</p>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><h4 id="Form1-cs-1"><a href="#Form1-cs-1" class="headerlink" title="Form1.cs"></a>Form1.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Diagnostics;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> OpenTK.WinForms;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Windows.Forms.VisualStyles.VisualStyleElement;<br><span class="hljs-keyword">using</span> OpenTK.Mathematics;<br><span class="hljs-keyword">using</span> OpenTK.Windowing.GraphicsLibraryFramework;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br><br>        <span class="hljs-built_in">float</span>[] vertices =<br>        &#123;<br>            <span class="hljs-comment">//Position          Texture coordinates</span><br>             <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-comment">// 右上</span><br>             <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 右下</span><br>            <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下</span><br>            <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>  <span class="hljs-comment">// 左上</span><br>        &#125;;<br>        <span class="hljs-built_in">uint</span>[] indices = &#123;  <span class="hljs-comment">// note that we start from 0!</span><br>            <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,   <span class="hljs-comment">// first triangle</span><br>            <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    <span class="hljs-comment">// second triangle</span><br>        &#125;;<br>        <span class="hljs-built_in">int</span> VertexBufferObject;<br>        <span class="hljs-built_in">int</span> vertexArrayObject;<br>        <span class="hljs-built_in">int</span> ElementBufferObject;<br>        <span class="hljs-keyword">private</span> Texture _texture;<br>        <span class="hljs-keyword">private</span> Texture _texture2;<br>        Shader shader;<br>        Stopwatch timer;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Form1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.ClearColor(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>            <br><br>            <span class="hljs-comment">// Create and bind VAO</span><br>            vertexArrayObject = GL.GenVertexArray();<br>            GL.BindVertexArray(vertexArrayObject);<br><br>            <span class="hljs-comment">// Create and bind VBO</span><br>            VertexBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>            <span class="hljs-comment">// Provide vertex data to the VBO</span><br>            GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><br>            ElementBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ElementArrayBuffer, ElementBufferObject);<br>            GL.BufferData(BufferTarget.ElementArrayBuffer, indices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">uint</span>), indices, BufferUsageHint.StaticDraw);<br><br>            shader = <span class="hljs-keyword">new</span> Shader(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.vert&quot;</span>, <span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.frag&quot;</span>);<br>            timer = <span class="hljs-keyword">new</span> Stopwatch();<br>            shader.Use();<br><br>            <span class="hljs-comment">// Specify the vertex attribute pointers</span><br>            GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>            GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-built_in">int</span> texCoordLocation = GL.GetAttribLocation(shader.Handle, <span class="hljs-string">&quot;aTexCoord&quot;</span>);<br>            GL.EnableVertexAttribArray(texCoordLocation);<br>            GL.VertexAttribPointer(texCoordLocation, <span class="hljs-number">2</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br><br>            _texture = Texture.LoadFromFile(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/Resources/container.png&quot;</span>);<br>            _texture.Use(TextureUnit.Texture0);<br><br>            _texture2 = Texture.LoadFromFile(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/Resources/awesomeface.png&quot;</span>);<br>            _texture2.Use(TextureUnit.Texture1);<br><br>            shader.SetInt(<span class="hljs-string">&quot;texture0&quot;</span>, <span class="hljs-number">0</span>);<br>            shader.SetInt(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Paint</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, PaintEventArgs e</span>)</span><br>        &#123;<br>            GL.Clear(ClearBufferMask.ColorBufferBit);<br><br>            GL.BindVertexArray(vertexArrayObject);<br><br>            _texture.Use(TextureUnit.Texture0);<br>            _texture2.Use(TextureUnit.Texture1);<br>            shader.Use();<br><br>            GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br><br>            glControl1.SwapBuffers();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_SizeChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> deltaTime</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//var input = KeyboardState;</span><br><br>            <span class="hljs-comment">//if (input.IsKeyDown(Keys.Escape))</span><br>            <span class="hljs-comment">//&#123;</span><br>            <span class="hljs-comment">//    Close();</span><br>            <span class="hljs-comment">//&#125;</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">timer1_Tick</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">float</span> deltaTime = (<span class="hljs-built_in">float</span>)timer.Elapsed.TotalSeconds;<br>            timer.Restart();<br><br>            OnUpdate(deltaTime);<br>            <br>            glControl1.Invalidate();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Texture-cs-1"><a href="#Texture-cs-1" class="headerlink" title="Texture.cs"></a>Texture.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> System.Drawing;<br><span class="hljs-keyword">using</span> System.Drawing.Imaging;<br><span class="hljs-keyword">using</span> PixelFormat = OpenTK.Graphics.OpenGL.PixelFormat;<br><span class="hljs-keyword">using</span> StbImageSharp;<br><span class="hljs-keyword">using</span> System.IO;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Texture</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Handle;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture <span class="hljs-title">LoadFromFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// Generate handle</span><br>            <span class="hljs-built_in">int</span> handle = GL.GenTexture();<br><br>            <span class="hljs-comment">// Bind the handle</span><br>            GL.ActiveTexture(TextureUnit.Texture0);<br>            GL.BindTexture(TextureTarget.Texture2D, handle);<br><br>            <span class="hljs-comment">// For this example, we&#x27;re going to use .NET&#x27;s built-in System.Drawing library to load textures.</span><br><br>            <span class="hljs-comment">// OpenGL has it&#x27;s texture origin in the lower left corner instead of the top left corner,</span><br>            <span class="hljs-comment">// so we tell StbImageSharp to flip the image when loading.</span><br>            StbImage.stbi_set_flip_vertically_on_load(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// Here we open a stream to the file and pass it to StbImageSharp to load.</span><br>            <span class="hljs-keyword">using</span> (Stream stream = File.OpenRead(path))<br>            &#123;<br>                ImageResult image = ImageResult.FromStream(stream, ColorComponents.RedGreenBlueAlpha);<br><br>                <span class="hljs-comment">// Now that our pixels are prepared, it&#x27;s time to generate a texture. We do this with GL.TexImage2D.</span><br>                <span class="hljs-comment">// Arguments:</span><br>                <span class="hljs-comment">//   The type of texture we&#x27;re generating. There are various different types of textures, but the only one we need right now is Texture2D.</span><br>                <span class="hljs-comment">//   Level of detail. We can use this to start from a smaller mipmap (if we want), but we don&#x27;t need to do that, so leave it at 0.</span><br>                <span class="hljs-comment">//   Target format of the pixels. This is the format OpenGL will store our image with.</span><br>                <span class="hljs-comment">//   Width of the image</span><br>                <span class="hljs-comment">//   Height of the image.</span><br>                <span class="hljs-comment">//   Border of the image. This must always be 0; it&#x27;s a legacy parameter that Khronos never got rid of.</span><br>                <span class="hljs-comment">//   The format of the pixels, explained above. Since we loaded the pixels as RGBA earlier, we need to use PixelFormat.Rgba.</span><br>                <span class="hljs-comment">//   Data type of the pixels.</span><br>                <span class="hljs-comment">//   And finally, the actual pixels.</span><br>                GL.TexImage2D(TextureTarget.Texture2D, <span class="hljs-number">0</span>, PixelInternalFormat.Rgba, image.Width, image.Height, <span class="hljs-number">0</span>, PixelFormat.Rgba, PixelType.UnsignedByte, image.Data);<br>            &#125;<br><br>            <span class="hljs-comment">// Now that our texture is loaded, we can set a few settings to affect how the image appears on rendering.</span><br><br>            <span class="hljs-comment">// First, we set the min and mag filter. These are used for when the texture is scaled down and up, respectively.</span><br>            <span class="hljs-comment">// Here, we use Linear for both. This means that OpenGL will try to blend pixels, meaning that textures scaled too far will look blurred.</span><br>            <span class="hljs-comment">// You could also use (amongst other options) Nearest, which just grabs the nearest pixel, which makes the texture look pixelated if scaled too far.</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The default settings for both of these are LinearMipmap. If you leave these as default but don&#x27;t generate mipmaps,</span><br>            <span class="hljs-comment">// your image will fail to render at all (usually resulting in pure black instead).</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.Linear);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br><br>            <span class="hljs-comment">// Now, set the wrapping mode. S is for the X axis, and T is for the Y axis.</span><br>            <span class="hljs-comment">// We set this to Repeat so that textures will repeat when wrapped. Not demonstrated here since the texture coordinates exactly match</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br><br>            <span class="hljs-comment">// Next, generate mipmaps.</span><br>            <span class="hljs-comment">// Mipmaps are smaller copies of the texture, scaled down. Each mipmap level is half the size of the previous one</span><br>            <span class="hljs-comment">// Generated mipmaps go all the way down to just one pixel.</span><br>            <span class="hljs-comment">// OpenGL will automatically switch between mipmaps when an object gets sufficiently far away.</span><br>            <span class="hljs-comment">// This prevents moiré effects, as well as saving on texture bandwidth.</span><br>            <span class="hljs-comment">// Here you can see and read about the morié effect https://en.wikipedia.org/wiki/Moir%C3%A9_pattern</span><br>            <span class="hljs-comment">// Here is an example of mips in action https://en.wikipedia.org/wiki/File:Mipmap_Aliasing_Comparison.png</span><br>            GL.GenerateMipmap(GenerateMipmapTarget.Texture2D);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Texture(handle);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Texture</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> glHandle</span>)</span><br>        &#123;<br>            Handle = glHandle;<br>        &#125;<br><br>        <span class="hljs-comment">// Activate texture</span><br>        <span class="hljs-comment">// Multiple textures can be bound, if your shader needs more than just one.</span><br>        <span class="hljs-comment">// If you want to do that, use GL.ActiveTexture to set which slot GL.BindTexture binds to.</span><br>        <span class="hljs-comment">// The OpenGL standard requires that there be at least 16, but there can be more depending on your graphics card.</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>(<span class="hljs-params">TextureUnit unit</span>)</span><br>        &#123;<br>            GL.ActiveTexture(unit);<br>            GL.BindTexture(TextureTarget.Texture2D, Handle);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Shader-cs-1"><a href="#Shader-cs-1" class="headerlink" title="Shader.cs"></a>Shader.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shader</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Handle &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; _uniformLocations;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shader</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> vertexPath, <span class="hljs-built_in">string</span> fragmentPath</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">string</span> VertexShaderSource = File.ReadAllText(vertexPath);<br>            <span class="hljs-built_in">int</span> vertexShader = GL.CreateShader(ShaderType.VertexShader);<br>            GL.ShaderSource(vertexShader, VertexShaderSource);<br>            GL.CompileShader(vertexShader);<br><br><br>            <span class="hljs-built_in">string</span> FragmentShaderSource = File.ReadAllText(fragmentPath);<br>            <span class="hljs-built_in">int</span> fragmentShader = GL.CreateShader(ShaderType.FragmentShader);<br>            GL.ShaderSource(fragmentShader, FragmentShaderSource);<br>            GL.CompileShader(fragmentShader);<br><br>            <span class="hljs-comment">// Create shader program and link shaders</span><br>            Handle = GL.CreateProgram();<br>            GL.AttachShader(Handle, vertexShader);<br>            GL.AttachShader(Handle, fragmentShader);<br>            GL.LinkProgram(Handle);<br><br>            <span class="hljs-comment">// Clean up individual shaders</span><br>            GL.DetachShader(Handle, vertexShader);<br>            GL.DetachShader(Handle, fragmentShader);<br>            GL.DeleteShader(fragmentShader);<br>            GL.DeleteShader(vertexShader);<br><br>            GL.GetProgram(Handle, GetProgramParameterName.ActiveUniforms, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> numberOfUniforms);<br>            _uniformLocations = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;();<br><br>            <span class="hljs-comment">// Loop over all the uniforms,</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; numberOfUniforms; i++)<br>            &#123;<br>                <span class="hljs-comment">// get the name of this uniform,</span><br>                <span class="hljs-keyword">var</span> key = GL.GetActiveUniform(Handle, i, <span class="hljs-keyword">out</span> _, <span class="hljs-keyword">out</span> _);<br><br>                <span class="hljs-comment">// get the location,</span><br>                <span class="hljs-keyword">var</span> location = GL.GetUniformLocation(Handle, key);<br><br>                <span class="hljs-comment">// and then add it to the dictionary.</span><br>                _uniformLocations.Add(key, location);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span><br>        &#123;<br>            GL.UseProgram(Handle);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetInt</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> data</span>)</span><br>        &#123;<br>            GL.UseProgram(Handle);<br>            GL.Uniform1(_uniformLocations[name], data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="shader-vert-1"><a href="#shader-vert-1" class="headerlink" title="shader.vert"></a>shader.vert</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoord;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>    texCoord = aTexCoord;<br><br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="shader-frag-1"><a href="#shader-frag-1" class="headerlink" title="shader.frag"></a>shader.frag</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outputColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture0;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture1;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    outputColor = <span class="hljs-built_in">mix</span>(<span class="hljs-built_in">texture</span>(texture0, texCoord), <span class="hljs-built_in">texture</span>(texture1, texCoord), <span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>我们已经知道如何创建对象，给它们上色和&#x2F;或使用纹理给它们赋予详细的外观，但它们仍然不那么有趣，因为它们都是静态对象。我们可以尝试通过改变它们的顶点并重新配置它们的缓冲区来使它们移动，但这很麻烦，而且会消耗大量的处理能力。有更好的方法来转换对象，那就是使用（多个）矩阵对象。</p>
<p>矩阵是非常强大的数学构造，起初似乎令人望而生畏，但一旦你逐渐习惯了它们，它们将证明极其有用。当讨论矩阵时，我们将不得不对一些数学进行简要的探讨，对于更倾向于数学的读者，我将提供进一步阅读的额外资源。</p>
<p>然而，要完全理解变换，我们首先必须在讨论矩阵之前深入了解一些向量。本章的重点是为您提供我们以后需要的基本数学背景。如果这些主题很难，尽量理解它们，以后需要时随时回到本页面复习概念。</p>
<p>对上一节的图片进行旋转和缩放</p>
<p>首先引入<code>using OpenTK.Mathematics;</code></p>
<p>glControl1_Paint:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> transform = Matrix4.Identity;<br>transform = transform * Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(<span class="hljs-number">90.0f</span>));<br>transform = transform * Matrix4.CreateScale(<span class="hljs-number">1.1f</span>);<br>transform = transform * Matrix4.CreateTranslation(<span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>);<br></code></pre></td></tr></table></figure>

<p>这段代码是使用OpenGL数学库进行矩阵变换的示例。让我解释一下每一步的含义：</p>
<ol>
<li><p><code>Matrix4.Identity</code>: 这是一个单位矩阵，表示没有任何变换。它是一个4x4的矩阵，对角线上的元素为1，其余为0。</p>
</li>
<li><p><code>Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(90.0f))</code>: 这一行代码创建了一个绕着Z轴旋转90度的旋转矩阵。<code>MathHelper.DegreesToRadians()</code>是一个函数，用于将角度转换为弧度，因为大多数数学库使用弧度来表示角度。</p>
</li>
<li><p><code>Matrix4.CreateScale(1.1f)</code>: 这一行代码创建了一个缩放矩阵，将对象沿着X、Y和Z方向各放大1.1倍。这意味着对象在每个方向上都会增加10%的大小。</p>
</li>
<li><p><code>Matrix4.CreateTranslation(0.1f, 0.1f, 0.1f)</code>: 最后一行代码创建了一个平移矩阵，将对象沿着X、Y和Z方向各移动0.1个单位。</p>
</li>
</ol>
<p>在这些操作之后，<code>transform</code>矩阵将包含所有这些变换的组合。如果将这个矩阵应用到对象的顶点上，对象就会按照这些变换进行旋转、缩放和平移。</p>
<p>剩下看官方代码</p>
<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>在上节中，我们学习了如何利用矩阵通过转换矩阵来转换所有顶点。OpenGL希望在每次顶点着色器运行后，我们希望变得可见的所有顶点都位于归一化设备坐标中。也就是说，每个顶点的x、y和z坐标应该在-1.0和1.0之间；超出此范围的坐标将不可见。我们通常做的是在一个我们自己配置的范围内指定坐标，并在顶点着色器中将这些坐标转换为NDC。然后将这些NDC坐标传递给光栅化器，以将它们转换为屏幕上的2D坐标&#x2F;像素。</p>
<p>将坐标转换为NDC，然后转换为屏幕坐标通常是逐步完成的，我们将一个对象的顶点转换为几个坐标系统，最后将它们转换为屏幕坐标。将它们转换为几个中间坐标系统的优点是，某些操作&#x2F;计算在特定坐标系统中更容易，这很快就会变得明显。对我们来说，共有5种不同的重要坐标系统：</p>
<ol>
<li>局部空间（或对象空间）</li>
<li>世界空间</li>
<li>观察空间（或眼睛空间）</li>
<li>裁剪空间</li>
<li>屏幕空间</li>
</ol>
<p>在最终成为片段之前，这些坐标系统中的每一个都是顶点将被转换为的不同状态。</p>
<p>您现在可能对空间或坐标系统到底是什么感到困惑，所以我们将以更易于理解的方式解释它们，通过展示整体图像和每个特定空间实际执行的操作。</p>
<h3 id="全局视角"><a href="#全局视角" class="headerlink" title="全局视角"></a>全局视角</h3><p>为了将一个坐标空间中的坐标转换到下一个坐标空间中，我们将使用几个变换矩阵，其中最重要的是模型（Model）、视图（View）和投影（Projection）矩阵。我们的顶点坐标首先从局部空间开始作为局部坐标，然后进一步转换为世界坐标、观察坐标、裁剪坐标，最终以屏幕坐标结束。下图展示了这个过程，并显示了每个转换的作用：</p>
<p><img src="/8-coordinate_systems.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li><p>局部坐标是相对于对象的局部原点的坐标；它们是对象起始的坐标。</p>
</li>
<li><p>接下来的步骤是将局部坐标转换为世界空间坐标，这些坐标是相对于更大的世界的坐标。这些坐标是相对于世界的全局原点的，与许多其他对象一起放置在相对于世界原点的位置。</p>
</li>
<li><p>接下来，我们将世界坐标转换为视图空间坐标，以使每个坐标都是从摄像机或观察者的视角看到的。</p>
</li>
<li><p>当坐标处于视图空间时，我们希望将它们投影到裁剪坐标中。裁剪坐标被处理为-1.0和1.0的范围，并确定哪些顶点将出现在屏幕上。</p>
</li>
<li><p>最后，我们将裁剪坐标转换为屏幕坐标，这个过程称为视口变换，它将坐标从-1.0和1.0转换为由GL.Viewport定义的坐标范围。然后，得到的坐标被发送到光栅化器，将它们转换为片段。</p>
</li>
</ol>
<p>你可能已经对每个单独的空间有了一些了解。我们将顶点转换为所有这些不同的空间的原因是，某些操作在特定坐标系统中更有意义或更容易使用。例如，当修改对象时，在局部空间中进行修改是最合理的，而在世界坐标系中计算与其他对象位置相关的某些操作是最合理的，依此类推。如果我们愿意，我们可以定义一个从局部空间到裁剪空间的转换矩阵，但这样会给我们留下更少的灵活性。</p>
<p>我们将在下面更详细地讨论每个坐标系。</p>
<h4 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h4><p>局部空间是与你的对象相关的坐标空间，即你的对象起始的地方。想象一下，你在建模软件（如Blender）中创建了一个立方体。你的立方体的原点可能在（0,0,0），即使你的立方体最终可能在你的最终应用程序中位于不同的位置。你创建的所有模型的初始位置可能都是（0,0,0）。因此，你模型的所有顶点都在局部空间中：它们都是相对于你的对象的局部坐标。</p>
<p>我们使用的容器的顶点被指定为介于-0.5和0.5之间的坐标，以0.0作为原点。这些是局部坐标。</p>
<h4 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h4><p>如果我们直接将所有的对象导入应用程序中，它们可能都堆叠在世界原点（0,0,0）附近，这不是我们想要的。我们希望为每个对象定义一个位置，将它们放置在一个更大的世界中。世界空间中的坐标正是它们听起来的样子：所有顶点相对于（游戏）世界的坐标。这是一个坐标空间，你希望将你的对象转换到这个空间中，以使它们分散在各个地方（最好以一种真实的方式）。你的对象的坐标是从局部空间转换到世界空间的；这是通过模型矩阵完成的。</p>
<p>模型矩阵是一个转换矩阵，可以平移、缩放和&#x2F;或旋转你的对象，将其放置在世界中的一个位置&#x2F;方向上。可以将其想象为通过缩小房屋（在局部空间中有点太大了）、将其平移到郊区城镇并在y轴上稍微向左旋转一点，以便它与邻近的房屋整齐地配合。你也可以将前面教程中的矩阵想象成一种模型矩阵，用于将容器的局部坐标转换到场景&#x2F;世界中的某个不同位置。</p>
<h4 id="视图空间"><a href="#视图空间" class="headerlink" title="视图空间"></a>视图空间</h4><p>视图空间通常被称为OpenGL的摄像机（有时也称为相机空间或眼睛空间）。视图空间是将世界空间坐标转换为位于用户视图前方的坐标的结果。因此，视图空间就是从摄像机视角看到的空间。通常通过一系列平移和旋转来实现视图空间的转换，以便将某些物体转换到摄像机前面。这些组合的变换通常存储在一个视图矩阵中，该矩阵将世界坐标转换为视图空间。在下一个教程中，我们将详细讨论如何创建这样一个视图矩阵来模拟一个摄像机。</p>
<h4 id="剪裁空间"><a href="#剪裁空间" class="headerlink" title="剪裁空间"></a>剪裁空间</h4><p>在每次顶点着色器运行结束时，OpenGL期望坐标位于特定范围内，任何超出此范围的坐标都将被裁剪。被裁剪的坐标将被丢弃，因此剩下的坐标将成为在屏幕上可见的片段。这也是裁剪空间得名的原因。</p>
<p>由于将所有可见坐标指定为范围-1.0和1.0并不直观，我们会指定我们自己的坐标集并将其转换回NDC，因为OpenGL期望它们是NDC。</p>
<p>为了将顶点坐标从视图空间转换为裁剪空间，我们定义了一个称为投影矩阵的矩阵，该矩阵指定了每个维度中的坐标范围，例如-1000和1000。然后，投影矩阵将在指定范围内的坐标转换为规范化设备坐标（-1.0，1.0）。所有超出此范围的坐标将不会映射到-1.0和1.0之间，因此将被裁剪。对于我们在投影矩阵中指定的范围，例如坐标（1250，500，750）将不可见，因为x坐标超出了范围，因此会转换为NDC中大于1.0的坐标，因此被裁剪。</p>
<blockquote>
<p>请注意，如果一个图元的一部分（例如一个三角形）超出了裁剪体积，OpenGL将重构该三角形为一个或多个三角形，以适应裁剪范围内。</p>
</blockquote>
<p>投影矩阵创建的视图框称为视锥体，位于该视锥体内的每个坐标将出现在用户的屏幕上。将坐标从指定范围转换为NDC并映射到2D视图空间坐标的整个过程称为投影，因为投影矩阵将3D坐标投影到易于映射到2D规范化设备坐标的坐标。</p>
<p>一旦所有顶点转换为裁剪空间，将执行最终操作，称为透视除法，其中我们将位置向量的x、y和z分量除以向量的齐次w分量；透视除法是将4D裁剪空间坐标转换为3D规范化设备坐标。这一步在每次顶点着色器运行结束时自动执行。</p>
<p>在这个阶段之后，将结果坐标映射到屏幕坐标（使用glViewport的设置），并转换为片段。</p>
<p>将视图坐标转换为裁剪坐标的投影矩阵可以采用两种不同形式，每种形式定义了自己独特的视锥体。我们可以创建正交投影矩阵或透视投影矩阵。</p>
<h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p>正交投影矩阵定义了一个立方体般的视锥体，它定义了剪裁空间，其中每个顶点在此盒子外部都会被裁剪。创建正交投影矩阵时，我们指定可见视锥体的宽度、高度和长度。在使用正交投影矩阵将坐标转换为裁剪空间后，所有落入此视锥体内部的坐标都不会被裁剪。视锥体看起来有点像一个容器：</p>
<p><img src="/8-orthographic_frustum.png" srcset="/img/loading.gif" lazyload></p>
<p>视锥体定义了可见坐标，并由宽度、高度和近平面和远平面来指定。任何位于近平面前面的坐标都会被裁剪，对于位于远平面后面的坐标也是一样。正交投影视锥体直接将视锥体内的所有坐标映射到规范化设备坐标，因为每个向量的w分量保持不变；如果w分量等于1.0，则透视除法不会改变坐标。</p>
<p>要创建一个正交投影矩阵，我们使用<code>OpenTK</code>的<code>CreateOrthographicOffCenter</code>方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4.CreateOrthographicOffCenter(<span class="hljs-number">0.0f</span>, <span class="hljs-number">800.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">600.0f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure>

<p>前两个参数指定了视锥体的左边界和右边界，第三和第四个参数指定了视锥体的底部和顶部。通过这4个点，我们定义了近平面和远平面的大小，然后第5和第6个参数定义了近平面和远平面之间的距离。这个特定的投影矩阵将所有在这些x、y和z范围值之间的坐标转换为规范化设备坐标。</p>
<p>正交投影矩阵直接将坐标映射到您屏幕的2D平面，但实际上，直接投影会产生不真实的结果，因为投影不考虑透视。这就是透视投影矩阵为我们修正的内容。</p>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>如果你曾经欣赏过现实生活中的图形，你会注意到远处的物体看起来要小得多。这种奇怪的效果是我们所谓的透视。透视在望着无限公路或铁路的尽头时尤为明显，就像下面的图片所示：</p>
<p><img src="/8-perspective.png" srcset="/img/loading.gif" lazyload></p>
<p>正如你所看到的，由于透视，线条在远处似乎重合。透视投影正是试图模仿这种效果，它使用透视投影矩阵来实现。投影矩阵将给定的视锥体范围映射到裁剪空间，但也以一种方式操纵每个顶点坐标的w值，使得离观察者越远的顶点坐标，其w分量越高。一旦坐标被转换到裁剪空间，它们就位于-w到w的范围内（范围之外的任何坐标都会被裁剪）。OpenGL要求可见坐标必须落在-1.0到1.0的范围内，作为最终顶点着色器的输出，因此一旦坐标位于裁剪空间中，透视除法就会应用到裁剪空间坐标上：<br>$$<br>out&#x3D;<br>\begin{pmatrix}<br>x&#x2F;w\<br>y&#x2F;w\<br>z&#x2F;w<br>\end{pmatrix}<br>$$<br>每个顶点坐标的每个分量都被它的w分量除以，使得顶点距离观察者越远，顶点坐标就越小。这也是为什么w分量很重要的另一个原因，因为它帮助我们进行透视投影。得到的坐标随后处于规范化设备空间中。如果你有兴趣弄清楚正交投影和透视投影矩阵是如何实际计算的（并且不怕数学），我可以推荐这篇由Songho撰写的优秀文章。</p>
<p>在OpenTK中可以使用以下方式创建透视投影矩阵：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(<span class="hljs-number">45.0f</span>), (<span class="hljs-built_in">float</span>)width / (<span class="hljs-built_in">float</span>)height, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure>

<p>这段代码创建了一个透视投影矩阵。它通过参数指定了一个大的视锥体，定义了可见空间，视锥体之外的任何东西都不会出现在裁剪空间中，因此会被裁剪掉。透视视锥体可以想象成一个非均匀形状的盒子，其中每个在这个盒子内部的坐标都会映射到裁剪空间中的一个点。下面是一个透视视锥体的图像：<code>Matrix4.CreatePerspectiveFieldOfView</code></p>
<p><img src="/8-perspective_frustum.png" srcset="/img/loading.gif" lazyload></p>
<p>第一个参数定义了fovy值，代表视场角（y代表垂直轴，因此是垂直视场角），并设置了视景体的大小。为了获得逼真的视图，通常将其设置为45度，但如果想要更像《毁灭战士》（Doom）风格的结果，可以将其设置为更高的值。第二个参数设置了纵横比，通过将视口的宽度除以其高度来计算。第三个和第四个参数设置了视锥体的近平面和远平面。通常将近距离设置为0.1f，远距离设置为100.0f。在视锥体的近平面和远平面之间以及内部的所有顶点都将被渲染。</p>
<blockquote>
<p>当透视矩阵的近平面值设置得稍微过高（例如10.0f）时，OpenGL会裁剪所有靠近相机的坐标（在0.0f和10.0f之间），这在视频游戏中会产生一个熟悉的视觉效果，即如果你靠近某些物体，你可以看穿它们。</p>
</blockquote>
<p>在使用正交投影时，每个顶点坐标都直接映射到裁剪空间，没有任何复杂的透视除法（实际上仍然进行了透视除法，但w分量不受影响（保持为1），因此没有效果）。由于正交投影不使用透视投影，因此远处的物体看起来不会变小，这会产生一种奇怪的视觉效果。因此，正交投影主要用于2D渲染以及一些建筑或工程应用中，在这些应用中我们不希望顶点受到透视的扭曲。用于3D建模的应用程序（如Blender）有时会使用正交投影进行建模，因为它更准确地描绘了每个对象的尺寸。下面你会看到Blender中两种投影方法的比较：</p>
<p><img src="/8-perspective_orthographic.png" srcset="/img/loading.gif" lazyload></p>
<p>你可以看到，使用透视投影时，远处的顶点看起来要小得多，而在正交投影中，每个顶点与用户的距离相同。</p>
<h3 id="结合起来"><a href="#结合起来" class="headerlink" title="结合起来"></a>结合起来</h3><p>我们为前面提到的每个步骤创建一个变换矩阵：模型、视图和投影矩阵。然后，顶点坐标被转换为裁剪坐标，如下所示：<br>$$<br>V_{clip}&#x3D;M_{projection}\cdot M_{view}\cdot M_{model}\cdot V_{local}<br>$$<br>请注意，矩阵乘法的顺序是相反的（记住我们需要从右向左阅读矩阵乘法）。然后，将得到的顶点分配给顶点着色器中的gl_Position，然后OpenGL将自动执行透视除法和裁剪。</p>
<blockquote>
<p>然后呢？顶点着色器的输出要求坐标在裁剪空间中，这就是我们刚刚通过变换矩阵完成的。OpenGL然后对裁剪空间坐标执行透视除法，将它们转换为标准化设备坐标。然后，OpenGL使用GL.Viewport的参数将标准化设备坐标映射到屏幕坐标，在这里，每个坐标对应屏幕上的一个点（在我们的情况下是800x600屏幕）。这个过程被称为视口变换。</p>
</blockquote>
<p>这是一个难以理解的话题，所以如果你对每个空间的具体用途仍然不太清楚，也不必担心。在接下来的教程中，我们将看到如何实际运用这些坐标空间，并且会有足够的示例跟随在这些教程中。</p>
<h3 id="前往3D"><a href="#前往3D" class="headerlink" title="前往3D"></a>前往3D</h3><p>现在我们知道如何将 3D 坐标转换为 2D 坐标，我们可以开始展示我们的对象作为真正的 3D 对象，而不是到目前为止我们一直展示的平淡的 2D 平面。</p>
<p>为了开始绘制 3D 图形，我们首先创建一个模型矩阵。模型矩阵包括我们想要应用的平移、缩放和&#x2F;或旋转，以将所有对象的顶点转换为全局世界空间。让我们通过绕 x 轴旋转一下我们的平面，使其看起来好像躺在地板上。模型矩阵如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4 model = Matrix4.CreateRotationX(MathHelper.DegreesToRadians(<span class="hljs-number">-55.0f</span>));<br></code></pre></td></tr></table></figure>

<p>通过将顶点坐标与这个模型矩阵相乘，我们将顶点坐标转换为世界坐标。我们的平面略微位于地板上，因此代表了全局世界中的平面。</p>
<p>接下来，我们需要创建一个视图矩阵。我们想向后稍微移动场景，这样对象就变得可见（当在世界空间时，我们位于原点（0,0,0））。要在场景中移动，可以考虑以下内容：</p>
<ul>
<li>将相机向后移动，相当于将整个场景向前移动。</li>
</ul>
<p>这正是视图矩阵所做的，我们将整个场景向相机所在位置的反方向移动。因为我们想向后移动，而且由于 OpenGL 是一个右手坐标系统，所以我们必须沿着正的 z 轴移动。我们通过沿着负 z 轴平移场景来实现这一点。这会给人一种我们正在向后移动的印象。</p>
<blockquote>
<p>按照惯例，OpenGL 是一个右手坐标系统。这基本上意味着正 x 轴在你的右边，正 y 轴向上，正 z 轴向后。想象一下，你的屏幕是 3 个轴的中心，正 z 轴穿过屏幕朝向你。轴的方向如下所示：右手坐标系</p>
<p>要理解为什么它被称为右手坐标系，请按照以下步骤操作：</p>
<ol>
<li>将你的右手沿着正 y 轴伸展，手向上。</li>
<li>让你的大拇指指向右边。</li>
<li>让你的食指指向上方。</li>
<li>然后将你的中指向下弯曲 90 度。</li>
</ol>
<p>如果你做得对，你的大拇指应该指向正 x 轴，食指指向正 y 轴，中指指向正 z 轴。如果你用左手这样做，你会发现 z 轴是相反的。这被称为左手坐标系，DirectX 通常使用它。请注意，在标准化设备坐标中，OpenGL 实际上使用左手坐标系（投影矩阵会切换坐标系的左右性）。</p>
</blockquote>
<p>我们将在下一篇教程中更详细地讨论如何在场景中移动。目前，视图矩阵如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 注意我们将场景向我们想要移动的反方向进行平移。</span><br>Matrix4 view = Matrix4.CreateTranslation(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-3.0f</span>);<br></code></pre></td></tr></table></figure>

<p>我们需要定义的最后一件事是投影矩阵。我们想要在场景中使用透视投影，因此我们将声明投影矩阵如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(<span class="hljs-number">45.0f</span>), Width / Height, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure>

<p>现在我们已经创建了变换矩阵，我们应该将它们传递给我们的着色器。首先让我们在顶点着色器中将变换矩阵声明为uniform，并将它们与顶点坐标相乘：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br>...<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// 注意我们从右到左读取乘法</span><br>    <span class="hljs-built_in">gl_Position</span> =  <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>) * model * view * projection;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们还应该将矩阵发送到着色器中（通常在每次渲染迭代中执行，因为变换矩阵往往会经常变化）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">shader.SetMatrix4(<span class="hljs-string">&quot;model&quot;</span>, model);<br>shader.SetMatrix4(<span class="hljs-string">&quot;view&quot;</span>, view);<br>shader.SetMatrix4(<span class="hljs-string">&quot;projection&quot;</span>, projection);<br></code></pre></td></tr></table></figure>

<p>现在，我们的顶点坐标经过了模型、视图和投影矩阵的变换，最终对象应该是：</p>
<p>向后倾斜，靠在地板上。<br>离我们有一点远。<br>以透视方式显示（随着顶点越来越远，它应该变小）。<br>让我们检查一下结果是否确实满足了这些要求：</p>
<h2 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h2><p>在之前的教程中，我们讨论了视图矩阵以及如何使用视图矩阵在场景中移动（我们稍微向后移动了一点）。OpenGL本身并不熟悉摄像机的概念，但我们可以尝试通过将场景中的所有物体向相反方向移动来模拟摄像机，从而产生我们在移动的错觉。</p>
<p>在本教程中，我们将讨论如何在OpenGL中设置摄像机。我们将讨论一种FPS风格的摄像机，它允许您在3D场景中自由移动。在本教程中，我们还将讨论键盘和鼠标输入，并以一个自定义摄像机类结束。</p>
<h3 id="相机-视图空间"><a href="#相机-视图空间" class="headerlink" title="相机&#x2F;视图空间"></a>相机&#x2F;视图空间</h3><p>当我们谈论相机&#x2F;视图空间时，我们指的是从相机的角度来看所有顶点坐标，相机被视为场景的原点：视图矩阵将所有世界坐标转换为相对于相机位置和方向的视图坐标。要定义一个相机，我们需要它在世界空间中的位置、它所看的方向，以及从相机指向右侧和向上的向量。一个细心的读者可能会注意到，实际上我们要创建一个由相机位置作为原点的具有三个垂直单位轴的坐标系。</p>
<p><img src="/9-camera_axes.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>获取相机位置很容易。相机位置基本上是世界空间中指向相机位置的向量。我们将相机设置在上一个教程中设置的相同位置：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 Position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">3.0f</span>);<br></code></pre></td></tr></table></figure>

<p>不要忘记，正z轴穿过屏幕指向您，因此如果我们希望相机向后移动，我们沿着正z轴移动。</p>
<h4 id="相机方向"><a href="#相机方向" class="headerlink" title="相机方向"></a>相机方向</h4><p>下一个所需的向量是相机的方向，即它指向的方向。目前，我们让相机指向我们场景的原点：(0,0,0)。记住，如果我们从彼此中减去两个向量，我们得到的是这两个向量的差向量？因此，从场景原点向量中减去相机位置向量得到方向向量。由于我们知道相机指向负z方向，我们希望方向向量指向相机的正z轴。如果我们交换减法顺序，我们现在得到一个指向相机正z轴的向量：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 cameraTarget = Vector3.Zero;<br>Vector3 cameraDirection = Vector3.Normalize(cameraPos - cameraTarget);<br></code></pre></td></tr></table></figure>

<p>“方向向量”这个名称并不是最合适的选择，因为实际上它指向的是与其目标相反的方向。</p>
<h4 id="右轴"><a href="#右轴" class="headerlink" title="右轴"></a>右轴</h4><p>我们需要的下一个向量是一个右向量，表示相机空间的正x轴。为了获得右向量，我们使用一个小技巧，首先指定一个指向上方的上向量（在世界空间中）。然后，我们对上向量和第2步中的方向向量进行叉乘。由于叉乘的结果是两个向量的垂直向量，我们将得到一个指向正x轴方向的向量（如果我们交换向量，我们将得到一个指向负x轴的向量）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 up = Vector3.UnitY;<br>Vector3 cameraRight = Vector3.Normalize(Vector3.Cross(up, cameraDirection));<br></code></pre></td></tr></table></figure>

<h4 id="上轴"><a href="#上轴" class="headerlink" title="上轴"></a>上轴</h4><p>现在我们有了x轴向量和z轴向量，获取指向相机正y轴的向量相对较容易：我们对右向量和方向向量进行叉乘：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 cameraUp = Vector3.Cross(cameraDirection, cameraRight);<br></code></pre></td></tr></table></figure>

<p>通过使用叉乘和一些技巧，我们能够创建形成视图&#x2F;相机空间的所有向量。对于数学倾向的读者来说，这个过程在线性代数中被称为Gram-Schmidt过程。使用这些相机向量，我们现在可以创建一个非常有用的LookAt矩阵来创建相机。</p>
<h3 id="LookAt"><a href="#LookAt" class="headerlink" title="LookAt"></a>LookAt</h3><p>矩阵的一个伟大之处在于，如果你使用3个垂直（或非线性）的轴定义了一个坐标空间，你可以创建一个包含这3个轴加上一个平移向量的矩阵，通过与该矩阵相乘，你可以将任何向量转换到该坐标空间。这正是LookAt矩阵的作用，现在我们有了3个垂直的轴和一个位置向量来定义相机空间，我们可以创建自己的LookAt矩阵：<br>$$<br>LookAt&#x3D;<br>\begin{bmatrix}<br>R_x&amp;R_y&amp;R_z&amp;0\<br>U_x&amp;U_y&amp;U_z&amp;0\<br>D_x&amp;D_y&amp;D_z&amp;0\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}*<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;-P_x\<br>0&amp;1&amp;0&amp;-P_y\<br>0&amp;0&amp;1&amp;-P_z\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}<br>$$<br>其中，R是右向量，U是上向量，D是方向向量，P是相机的位置向量。请注意，位置向量是反转的，因为我们最终希望将世界向相反方向移动。使用这个LookAt矩阵作为我们的视图矩阵有效地将所有世界坐标转换为我们刚刚定义的视图空间。LookAt矩阵的作用正是它的名字所描述的：它创建一个指向给定目标的视图矩阵。</p>
<p>幸运的是，OpenTK已经为我们完成了所有这些工作。我们只需要指定相机位置、目标位置和一个在世界空间中表示上向量的向量（我们用于计算右向量的上向量）。OpenTK然后创建我们可以用作视图矩阵的LookAt矩阵：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4 view = Matrix4.LookAt(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">3.0f</span>), <br>  		   					  <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>  		                      <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>));<br></code></pre></td></tr></table></figure>

<p><code>Matrix4.LookAt</code>函数分别需要位置、目标和上向量。这将创建一个与上一教程中使用的视图矩阵相同的视图矩阵。</p>
<h3 id="走动"><a href="#走动" class="headerlink" title="走动"></a>走动</h3><p>现在是时候实际处理一些玩家输入并使我们的窗口响应了！首先，我们需要设置一个摄像机系统，因此在程序的顶部定义一些摄像机变量会很有用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">float</span> speed = <span class="hljs-number">1.5f</span>;<br><br>Vector3 position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">3.0f</span>);<br>Vector3 front = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-1.0f</span>);<br>Vector3 up = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,  <span class="hljs-number">0.0f</span>);<br></code></pre></td></tr></table></figure>

<p>在这里，我们引入了一个新的变量，以及用于LookAt函数的变量。speed变量将帮助我们定义相机移动时的速度。现在，LookAt函数变为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">view = Matrix4.LookAt(position, position + front, up);<br></code></pre></td></tr></table></figure>

<p>首先，我们将相机位置设置为之前定义的Position。方向是当前位置加上我们刚刚定义的方向向量。这确保了无论我们如何移动，相机都会保持朝向目标方向。让我们通过在按下某些键时更新Position向量来稍微调整这些变量。</p>
<p>我们已经看过如何在OnUpdateFrame函数中获取用户输入，现在我们可以扩展此功能以移动相机。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdateFrame</span>(<span class="hljs-params">FrameEventArgs e</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!IsFocused) <span class="hljs-comment">// check to see if the window is focused</span><br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    KeyboardState input = KeyboardState;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.W))<br>    &#123;<br>        position += front * speed; <span class="hljs-comment">//Forward </span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.S))<br>    &#123;<br>        position -= front * speed; <span class="hljs-comment">//Backwards</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.A))<br>    &#123;<br>        position -= Vector3.Normalize(Vector3.Cross(front, up)) * speed; <span class="hljs-comment">//Left</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.D))<br>    &#123;<br>        position += Vector3.Normalize(Vector3.Cross(front, up)) * speed; <span class="hljs-comment">//Right</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.Space))<br>    &#123;<br>        position += up * speed; <span class="hljs-comment">//Up </span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.LeftShift))<br>    &#123;<br>        position -= up * speed; <span class="hljs-comment">//Down</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>请注意，在顶部我们还检查窗口是否获得焦点，如果没有，就返回，这样可以避免窗口不在焦点时出现问题。</p>
</blockquote>
<p>每当我们按下WASD键中的一个时，相机的位置会相应地更新。如果我们想向前或向后移动，就会从位置向量中加或减去前向量。如果我们想侧向移动，我们会进行叉乘以创建一个右向量，并相应地沿着右向量移动。这样就产生了使用相机时熟悉的横向移动效果。此外，我们还添加了上升（空格键）或下降（LShift键）的功能，这与上升和下降相同，只是作用于上向量而不是前向量。</p>
<p>请注意，我们对结果右向量进行了归一化处理。如果我们不对该向量进行归一化处理，叉乘的结果可能会基于前变量而返回不同大小的向量。如果我们不对该向量进行归一化处理，我们移动的速度将取决于相机的方向，而不是保持一致的移动速度。</p>
<p>到目前为止，您应该已经能够以一种在不同系统中速度可能略有不同但您可能需要调整的速度移动相机了。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="category-chain-item">计算机图形学</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/OpenTK/" class="print-no-link">#OpenTK</a>
      
        <a href="/tags/OpenGL/" class="print-no-link">#OpenGL</a>
      
        <a href="/tags/%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/" class="print-no-link">#图像渲染</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>OpenTK入门</div>
      <div>https://strive-c.github.io/2024/01/31/OpenTK入门/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>bjx</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月31日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/02/17/%E9%93%BE%E6%8E%A5%E5%BA%93%E6%8C%87%E5%8C%97/" title="链接库指北">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">链接库指北</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/23/git/" title="git">
                        <span class="hidden-mobile">git</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'https://strive-c.github.io/2024/01/31/OpenTK%E5%85%A5%E9%97%A8/';
          this.page.identifier = '/2024/01/31/OpenTK%E5%85%A5%E9%97%A8/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
