<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面向对象编程OOP解析</title>
    <link href="/2024/03/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8BOOP%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/03/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8BOOP%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程-oop">面向对象编程 OOP</h1><h2 id="封装">封装</h2><h2 id="继承">继承</h2><h2 id="多态">多态</h2><ul><li>多态：父类指针/引用指向子类对象，从而在调用方法的时候，通过指向的子类对象的不同而调用不同的子类方法。</li><li>C++中的多态是通过继承和虚函数来实现的</li><li>Java中的多态是通过接口来实现的</li></ul><h2 id="c">C++</h2><ol type="1"><li><p>继承就是允许派生类拥有调用基类中属性和方法的权利</p></li><li><p>成员函数可以分为三种：普通成员函数、虚函数、纯虚函数</p></li><li><p>虚函数表示希望子类重新实现，且父类中有对应的实现方式</p></li><li><p>纯虚函数表示要求子类一定要实现，且父类中没有对应的实现方式</p></li><li><p>为什么要把某些函数设成虚函数?：父类在定义函数时决定暂缓具体实现步骤,因为子类在设计时有更具体的,精细的想法,我作为父类的设计者允许子类去override, 通过把自己的函数设置成虚函数,子类才有机会(权限)去重新定义。</p></li><li><p>含义一个纯虚函数的类称为纯虚类，纯虚类不允许声明对象 ##Java</p></li><li><p>Java中的接口是一个类，可以简单的等效于C++的纯虚类</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>链接库指北</title>
    <link href="/2024/02/17/%E9%93%BE%E6%8E%A5%E5%BA%93%E6%8C%87%E5%8C%97/"/>
    <url>/2024/02/17/%E9%93%BE%E6%8E%A5%E5%BA%93%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识">基础知识</h1><p>为了实现代码的复用我们使用链接库的形式对代码进行封装，链接库是写好的现有的，成熟的，可以复用的代码。本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存中执行。</p><p>链接库有两种：静态库（.a、.lib）和动态库（.so、.dll）</p><p>在Linux中静态库文件后缀是.a，动态库文件后缀是.so</p><p>在Windows中静态库文件后缀是.lib，动态库文件后缀是.dll</p><p>编写的代码有以下三种分发方式：</p><ol type="1"><li>源码：头文件 + 源文件</li><li>动态库：头文件 + LIB文件 + DLL文件<ul><li>其中头文件和LIB文件是可选的</li></ul></li><li>静态库：头文件 + LIB文件</li></ol><h1 id="静态库">静态库</h1><p>之所以称为静态库，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</p><p>静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是<strong>一组目标文件（.o/.obj文件）的集合</strong>，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：</p><ul><li>静态库对函数库的链接是放在编译时期完成的。</li><li>程序在运行时与函数库再无瓜葛，移植方便。</li><li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li></ul><p>函数和数据被编译进一个二进制文件（通常扩展名为.LIB）。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其他模块组合起来创建最终的可执行文件（.EXE文件）。当发布产品时，只需要发布这个可执行文件，并不需要发布被使用的静态库。</p><h2 id="静态库的配置">静态库的配置</h2><p>静态库由头文件、LIB文件组成</p><p>使用方式有两种</p><p>第一种是最简单、比较偷懒、适合自己做练习的时候使用：</p><ol type="1"><li>直接include头文件的绝对地址</li><li>直接使用命令引用LIB文件，代码如下</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;LIB文件的绝对地址&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>第二种是使用Visual Studio进行配置：</p><ol type="1"><li><p>打开项目的属性页，配置属性 -&gt; C/C++ -&gt;附加包含目录，点击添加头文件所在的父路径，即配置好头文件的路径。</p></li><li><p>配置属性 -&gt; 链接器 -&gt; 常规 -&gt;附加库目录，点击添加LIB所在的父路径</p></li><li><p>配置属性 -&gt; 链接器 -&gt; 输入 -&gt;附加依赖项，添加LIB文件的全名，包含后缀</p></li></ol><p>注意配置的平台和版本要与程序中对应</p><p>然后在程序中包含该头文件即可使用该静态库中的导出项</p><h1 id="动态库">动态库</h1><p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，这样可以节省内存空间，在程序修改方面也更加方便，只需更新.dll文件即可。</p><p>以下以Windows系统中的DLL为例</p><h2 id="动态库的配置">动态库的配置</h2><p>动态库由头文件（可选）、LIB文件（可选）、DLL文件组成</p><p>具体配置过程为：</p><ul><li><p>头文件的配置</p><ul><li>属性页：配置属性 -&gt; C/C++ -&gt;附加包含目录，点击添加头文件所在的父路径</li></ul></li><li><p>LIB文件的配置</p><ul><li><p>属性页：配置属性-&gt;链接器-&gt;常规-&gt;附加库目录，点击添加LIB所在的父路径</p></li><li><p>属性页：配置属性-&gt;链接器-&gt;输入-&gt;附加依赖项，添加LIB文件的全名，包含后缀</p></li></ul></li><li><p>DLL文件的配置</p><ul><li>将生成的DLL文件复制到exe程序的当前目录中即可，也不一定放在一起，Windows有DLL的搜索路径，在那些路径下都是可以的</li></ul></li></ul><p>第三方动态库目录解析：</p><ul><li><p>build目录放着编译源码的相关文件</p></li><li><p>include目录放着头文件，后期写代码的时候要包含这个文件</p></li><li><p>lib目录放着生成的文件，编译后生成的LIB文件和DLL文件都会在这个目录中</p></li></ul><p>补充函数结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> 调用约定 Add(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br>    <span class="hljs-comment">//........</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用约定，顾名思义就是对函数调用的一个约束和规定(规范)，描述了函数参数是怎么传递和由谁清除堆栈的。它决定以下内容：</p><ol type="1"><li>函数参数的压栈顺序</li><li>由调用者还是被调用者把参数弹出栈</li><li>以及产生函数修饰名的方法</li></ol><p>常见的调用约定有：__stdcall, __cdecl, __fastcall,__thiscall，__thiscall一般是类的成员函数会用，在使用时我们不会声明成这样，所以一般用前三种。</p><p>在编写动态库时，就是在对函数、变量、类进行导出。</p><p>其中函数的导出方式有两种：</p><ol type="1"><li><p>def文件</p><ul><li><p>优点：通用性很好</p></li><li><p>缺点：导出比较麻烦</p></li></ul></li><li><p>__declspec(dllexport)</p><ul><li><p>优点：导出方式简单</p></li><li><p>缺点：通用性较差</p></li></ul></li></ol><p>如果打算给其他语言调用，导出函数的参数，返回值类型必须使用基本类型</p><ul><li><p>基本类型：int, char, double, char*, …</p></li><li><p>非基本类型：std::string, std::vector, …</p></li></ul><h2 id="动态库创建">动态库创建</h2><p>在VS中创建<code>具有导出项的DLL动态链接库</code>，创建完成后打开的是dllmain.cpp文件，这个是dll的主函数，暂时不用管，目前主要讲导出的方式</p><h3 id="declspecdllexport">__declspec(dllexport)</h3><p>在头文件中有一个与项目名称相同的.h头文件，将其打开，其中的代码是编辑器为我们生成的一个示例代码，其中包括类的导出，变量的导出，函数的导出。</p><p>将其中的类导出和变量导出删掉，写一个导出的加法函数进行练习，注意cpp文件中的也要删除</p><p>仿照函数的导出方式，写一个Add函数，输入两个int变量，返回两个数的和</p><p>生成该项目，成功后即完成了两个函数的导出，一个是Add函数，一个是自带的函数</p><p>此时将dll文件和生成的exe文件一起打包即可运行，运行程序代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../ExportDLL/ExportDLL.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;D:\\Desktop\\bilibiliDLLTest\\ExportDLL\\x64\\Debug\\ExportDLL.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-built_in">Add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;Pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="def文件">def文件</h3><p>首先将上一步中函数前面添加的宏去掉，恢复成最普通的代码格式</p><p>然后在DLL项目中右键 -&gt; 添加新建项 -&gt; Visual C++ -&gt; 代码-&gt; 模块定义文件</p><p>在创建的文件的LIBRARY关键字后面写上库的名字，文件内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LIBRARY ExportDLL<br>EXPORTS<br>Add<br></code></pre></td></tr></table></figure><p>正常使用即可</p><p>但是推荐使用__declspec(dllexport)进行导出，方便简洁</p><h3 id="c语言调用">C语言调用</h3><p>如果把调用的文件由cpp变成c时，是无法调用的，需要在编写dll时对宏进行处理一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>以上代码的含义是，将Add以C语言的方式来解析函数</p><p>此时重新生成调用也可成功，将后缀由c变成cpp也是成功的</p><h3 id="其他语言调用">其他语言调用</h3><p>若是要将dll生成给C或CPP调用时，使用__declspec(dllexport)方式比较方便</p><p>如果要把代码给Java、JavaScript、C#等语言调用时，__declspec(dllexport)方法就不会那么方便，下面我们将以C#进行说明</p><p>先将def文件的依赖去掉，将ExportDLL属性页 -&gt; 配置属性 -&gt; 链接器-&gt; 所有选项 -&gt;模块定义文件中的Source.def删除，然后添加__declspec(dllexport)</p><h3 id="c调用">C#调用</h3><p>我们在创建dll工程的时候，编写的函数都没有显示指出调用约定，在属性页中进行设置，C/C++-&gt;所有选项-&gt;调用约定，VS中默认的是__cdecl(/Gd)，</p><p>创建一个控制台应用(.NET Framework)，名称为UseDLL_CSharp</p><p>将属性 -&gt; 生成 -&gt; 生成路径修改为 -&gt; ..\Debug\</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Runtime.InteropServices;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">UseDLL_CSharp</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;ExportDLL.dll&quot;</span>, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> a = Add(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>);<br>            Console.WriteLine(a);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果将DLL工程中调用约定写成__stdcall，就会出现找不到入口点的问题，原因在于dllexport虽然可以很方便的对函数进行导出，但是导出是由当前版本的编译器决定的，会对函数进行一系列的修饰，无法管理该修饰，如果使用def的方式就会好很多</p><p>所以如果希望对除C和C++以外的语言调用时，最好使用def的格式导出</p><h1 id="疑难杂症">疑难杂症</h1><h2 id="c向dll传递数据">C#向DLL传递数据</h2><h3 id="字符串类型的数据传输">字符串类型的数据传输</h3><p>C#：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 声明</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span>[] path</span>)</span>;<br><span class="hljs-comment">// 调用</span><br>livoxLidarInit(Encoding.Default.GetBytes(path));<br></code></pre></td></tr></table></figure><p>DLL：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span>;<br></code></pre></td></tr></table></figure><h2 id="dll向c传递数据">DLL向C#传递数据</h2><p>在开发过程中，除了C#主动调用DLL中的函数外，还有种情况是DLL向C#传递数据，此时需要使用函数指针，委托等工具进行设置。</p><p>基本逻辑为，将C#中编写的函数指针传递给DLL中，在DLL中调用函数指针就是在调用C#中的函数，从而完成DLL向C#的数据传递。</p><h3 id="c端">C#端</h3><ol type="1"><li>首先声明回调函数代理</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallbackDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span>;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>从DLL中引入设置回调函数的函数</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;LivoxLidar.dll&quot;</span>, CallingConvention = CallingConvention.StdCall)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetCallback</span>(<span class="hljs-params">CallbackDelegate callback</span>)</span>;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>编写回调函数</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyCallback</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span><br>&#123;<br>Console.WriteLine(a);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>设置回调函数</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">SetCallback(MyCallback);<br></code></pre></td></tr></table></figure><h3 id="c-dll端">C++ DLL端：</h3><ol type="1"><li>声明函数指针类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*CallbackFunc)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>设置函数指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> CallbackFunc g_callback = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>编写设置回调函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetCallback</span><span class="hljs-params">(CallbackFunc callback)</span> </span>&#123;<br>g_callback = callback;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>记得将设置回调函数向外导出</p></blockquote><ol start="4" type="1"><li>在合适位置调用该函数指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (g_callback != <span class="hljs-literal">nullptr</span>) &#123;<br><span class="hljs-built_in">g_callback</span>(<span class="hljs-number">123</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/CPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>CPP</tag>
      
      <tag>链接库</tag>
      
      <tag>动态链接库</tag>
      
      <tag>静态链接库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenTK入门</title>
    <link href="/2024/01/31/OpenTK%E5%85%A5%E9%97%A8/"/>
    <url>/2024/01/31/OpenTK%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍">介绍</h1><ul><li>官网：<a href="https://opentk.net/">OpenTK - OpenTK</a></li><li>官方文档：<a href="https://opentk.net/learn/index.html">LearnOpenTK- OpenTK</a></li><li>以下内容，采用版本为<strong>OpenTK 4.x</strong></li><li>出于在C#中使用OpenGL的需求，发现一个封装库OpenTK，以下为该封装库在Winform开发中的使用过程</li></ul><h1 id="下载">下载</h1><ul><li>在NuGet包管理器中下载<code>OpenTK</code>和<code>OpenTK.WinForms</code></li></ul><h1 id="入门使用">入门使用</h1><ul><li><p>在工具箱中将<code>GLControl</code>控件拖入窗口，即可在窗口中添加渲染组件。</p></li><li><p>在程序上方引入包：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br></code></pre></td></tr></table></figure></li></ul><h2 id="渲染管线">渲染管线</h2><figure><img src="pipeline.png" alt="Pipeline graph" /><figcaption aria-hidden="true">Pipeline graph</figcaption></figure><ul><li>VERTEX DATA[]：顶点数据</li><li>VERTEXSHADER：将顶点移动到其位置。这是应用模型位置等操作的阶段。</li><li>SHAPEASSEMBLY：OpenGL通过将顶点组合成三角形来工作；这个阶段就是实现这个过程的阶段。</li><li>GEOMETRYSHADER：一个可选的阶段。允许你对形状组装的结果进行微调。</li><li>RASTERIZATION：将三角形转换为片段的过程。</li><li>FRAGMENTSHADER：修改片段以包括颜色数据等内容。这是应用纹理和光照等操作的阶段。</li><li>TESTS ANDBLENDING：片段着色器的结果与场景的其他部分集成的阶段。</li></ul><p>蓝色背景的部分是可编程的，灰色背景的部分是可以使用功能进行轻微自定义</p><h2 id="流程">流程</h2><h3 id="函数介绍">函数介绍</h3><p>在<code>glControl1_Load</code>函数中添加如下代码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GL</span>.ClearColor(<span class="hljs-number">0</span>.<span class="hljs-number">2</span>f, <span class="hljs-number">0</span>.<span class="hljs-number">3</span>f, <span class="hljs-number">0</span>.<span class="hljs-number">3</span>f, <span class="hljs-number">1</span>.<span class="hljs-number">0</span>f);<br></code></pre></td></tr></table></figure><p>该函数是控件第一次加载的函数，任何与初始化有关的函数都应该放在<code>glControl1_Load</code>中间。</p><p><code>GL.ClearColor</code>接收四个0~1的浮点数，用于决定窗口在帧之间清除后的颜色。</p><hr /><p>在<code>glControl1_Paint</code>函数中添加如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.Clear(ClearBufferMask.ColorBufferBit);<br><span class="hljs-comment">//Code goes here.</span><br>glControl1.SwapBuffers();<br></code></pre></td></tr></table></figure><p>该函数是控件的绘制代码</p><p>GL.Clear清除了屏幕，并且使用GL.ClearColor设置的对应颜色刷新屏幕</p><p>Code goes here.为渲染代码</p><p>几乎任何现代 OpenGL都是所谓的“双缓冲”，先绘制绘制完成后再交换缓冲区</p><hr /><p>在<code>glControl1_SizeChanged</code>函数中添加如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br></code></pre></td></tr></table></figure><p>该函数是用于尺寸变更时重新设置视角</p><h3 id="顶点输入">顶点输入</h3><p>OpenGL是一个3D图形库，因此我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z坐标）。并且OpenGL仅在（x、y和z）处于-1.0到1.0之间的特定范围内时才处理3D 坐标</p><p>以下是一个简单的顶点坐标示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">float</span>[] vertices = &#123;<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">//Bottom-left vertex</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">//Bottom-right vertex</span><br>     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>  <span class="hljs-comment">//Top vertex</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="归一化设备坐标">归一化设备坐标</h3><ul><li>Normalized Device Coordinates (NDC)</li><li>在顶点着色器中处理顶点坐标后，它们应位于归一化设备坐标中，这是一个小空间，其中x、y 和 z 值从 -1.0 到 1.0不等。任何超出此范围的坐标都将被丢弃/裁剪，并且在屏幕上不可见。</li><li>与普通的屏幕坐标系不同，坐标系如下图所示</li></ul><p><img src="2-ndc.png" /></p><h3 id="缓冲区">缓冲区</h3><p>在上面定义完顶点数据后，我们需要进行渲染管线的第一步，顶点着色器。我们需要完成以下任务：在GPU上创建内存；配置OpenGL如何解释内存；指定如何将数据发送到GPU。完成以上设置后，顶点着色器会处理我们提供给它的任意数量的顶点</p><p>我们通过顶点缓冲区对象（VBO）来管理这些内存，该对象可以在 GPU的内存中存储大量顶点。使用这些缓冲区对象的优点是，我们可以一次将大批量数据发送到显卡，而不必一次发送一个顶点的数据。从CPU向显卡发送数据相对较慢，因此只要有可能，我们都会尝试一次发送尽可能多的数据。一旦数据进入显卡的内存中，顶点着色器几乎可以立即访问顶点，使其速度非常快。</p><p>顶点缓冲区对象有一个与该缓冲区对应的唯一ID，因此我们可以使用<code>GL.GenBuffers</code>生成一个缓冲器并返回该缓冲区的ID。</p><p>在<code>glControl1_Load</code>函数中添加如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> VertexBufferObject;<br>VertexBufferObject = GL.GenBuffer();<br></code></pre></td></tr></table></figure><p>OpenGL有多种类型的缓冲区对象，顶点缓冲区对象的缓冲区类型为<code>BufferTarget.ArrayBuffer</code>，balabalabala</p><p>我们可以使用<code>GL.BindBuffer</code>函数将新创建的缓冲区绑定到<code>BufferTarget.ArrayBuffer</code>类型上，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br></code></pre></td></tr></table></figure><p>绑定完成后，我们可以通过<code>GL.BufferData</code>函数向缓冲区中放入之前定义的顶点数据：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br></code></pre></td></tr></table></figure><ul><li><p>该函数用于将顶点数据放入缓冲区</p></li><li><p>第一个参数为要赋值到缓冲区的类型</p></li><li><p>第二个参数是传递给缓冲区的对象大小，以字节为单位</p></li><li><p>第三个参数是发送的实际数据</p></li><li><p>第四个参数是<code>BufferUsageHint</code>，用于指示显卡如何管理给定数据</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">StaticDraw：数据很可能根本不会改变或很少改变。<br>DynamicDraw：数据可能会发生很大变化。<br>StreamDraw：每次绘制数据时都会发生变化。<br></code></pre></td></tr></table></figure></li></ul><p>程序结束时会释放所有资源，但是如何出于某种原因需要手动释放缓冲区，可以调用如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.BindBuffer(BufferTarget.ArrayBuffer, <span class="hljs-number">0</span>);<br>GL.DeleteBuffer(VertexBufferObject);<br></code></pre></td></tr></table></figure><p>以上，我们完成了将顶点数据存储在显卡的内存中，由名为VBO的顶点缓冲区对象管理。接下来，我们要创建一个顶点和片段着色器来实际处理这些数据。</p><h3 id="着色器">着色器</h3><p>如果我们想做一些渲染，OpenGL要求我们至少设置一个顶点和片段着色器。</p><p>我们需要做的第一件事是用着色器语言GLSL（OpenGL着色语言）编写顶点着色器，然后编译这个着色器，以便我们可以在我们的应用程序中使用它。下面是GLSL 中一个非常基本的顶点着色器的源代码：</p><p>顶点着色器代码：shader.vert</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>GLSL看起来类似于C。每个着色器都以声明其版本开头。从OpenGL3.3及更高版本开始，GLSL的版本号与OpenGL的版本匹配（例如，GLSL版本420对应于OpenGL版本4.2）。</p><p>接下来，在顶点着色器中用关键字<code>in</code>声明所有输入顶点属性。目前我们只关心位置数据，因此我们只需要一个顶点属性。GLSL具有矢量数据类型，根据其后缀数字包含1到4个浮点数。由于每个顶点都有一个3D坐标，我们使用名称<code>aPosition</code>创建一个<code>vec3</code>输入变量。我们还通过<code>layout(location = 0)</code>明确设置了输入变量的位置，稍后你会看到我们为什么需要这个位置。</p><p>每个着色器的入口点是<code>void main()</code>函数。这是你可以进行任何处理的地方。然而，在这里，我们只是将输入数据分配给了<code>gl_Position</code>，这是顶点着色器的内置变量，表示该顶点的最终位置。然而，<code>gl_Position</code>是一个<code>vec4</code>，但我们的输入顶点是<code>vec3</code>。为此，我们使用<code>vec4</code>函数使向量变得足够长。</p><p>当前的顶点着色器可能是我们能想象的最简单的顶点着色器，因为我们对输入数据没有进行任何处理，只是将其转发到着色器的输出。在实际应用中，输入数据通常不是已经在标准化设备坐标中，因此我们首先必须将输入数据转换为在OpenGL可见区域内的坐标。</p></blockquote><p>片段着色器代码：shader.frag</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> vec4 FragColor;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    FragColor = vec4(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.2f</span>, <span class="hljs-number">1.0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>片段着色器是我们将为渲染三角形创建的第二个也是最后一个着色器。片段着色器主要是关于计算像素的颜色输出。为了保持简单，片段着色器将始终输出一种橙色。</p><p>在计算机图形中，颜色表示为一个包含4个值的向量：红色、绿色、蓝色和alpha（不透明度）分量，通常缩写为RGBA。在OpenGL或GLSL中定义颜色时，我们将每个分量的强度设置为介于0.0和1.0之间的值。例如，如果我们将红色设置为1.0f并将绿色设置为1.0f，我们将获得混合了两种颜色并得到黄色的颜色。给定这三个颜色分量，我们可以生成超过1600万种不同的颜色！</p><p>片段着色器只需要一个输出变量，那就是一个大小为4的向量，定义了我们自己要计算的最终颜色输出。我们可以使用关键字<code>out</code>声明输出值，这里我们迅速命名为<code>FragColor</code>。接下来，我们只需将一个<code>vec4</code>分配给颜色输出，作为橙色，并且alpha值为1.0（1.0表示完全不透明）。</p></blockquote><h3 id="编译着色器">编译着色器</h3><p>有了着色器源代码，现在需要编译着色器。这是在运行时完成的；预先编译着色器并将其与程序打包在一起是不可能的，因为编译后的着色器取决于许多因素，比如显卡型号、制造商和驱动程序。相反，我们在程序开始时包含着色器源代码并对其进行编译。</p><p>我们将通过创建一个Shader类来实现这一点，该类编译着色器并封装了我们稍后将看到的几个函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shader</span><br>&#123;<br>    <span class="hljs-built_in">int</span> Handle;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shader</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> vertexPath, <span class="hljs-built_in">string</span> fragmentPath</span>)</span><br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在构造函数中，handle将代表着我们最终着色器程序编译完成后的位置。我们将在构造函数中进行所有初始化工作。</p><p>首先，在构造函数中定义两个整数：VertexShader和FragmentShader。这些是各个着色器的句柄。它们在构造函数中定义，因为在完整的着色器程序完成后，我们不再需要各个着色器。</p><p>接下来，我们需要从各个着色器文件中加载源代码。我们可以这样做：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> VertexShaderSource = File.ReadAllText(vertexPath);<br><span class="hljs-built_in">string</span> FragmentShaderSource = File.ReadAllText(fragmentPath);<br></code></pre></td></tr></table></figure><p>然后，我们生成我们的着色器，并将源代码绑定到着色器上。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">VertexShader = GL.CreateShader(ShaderType.VertexShader);<br>GL.ShaderSource(VertexShader, VertexShaderSource);<br><br>FragmentShader = GL.CreateShader(ShaderType.FragmentShader);<br>GL.ShaderSource(FragmentShader, FragmentShaderSource);<br></code></pre></td></tr></table></figure><p>接下来，我们编译着色器并检查是否有错误。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.CompileShader(VertexShader);<br><br>GL.GetShader(VertexShader, ShaderParameter.CompileStatus, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> success);<br><span class="hljs-keyword">if</span> (success == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">string</span> infoLog = GL.GetShaderInfoLog(VertexShader);<br>    Console.WriteLine(infoLog);<br>&#125;<br><br>GL.CompileShader(FragmentShader);<br><br>GL.GetShader(FragmentShader, ShaderParameter.CompileStatus, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> success);<br><span class="hljs-keyword">if</span> (success == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">string</span> infoLog = GL.GetShaderInfoLog(FragmentShader);<br>    Console.WriteLine(infoLog);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在编译过程中出现任何错误，您可以使用函数GL.GetShaderInfoLog获取调试字符串。假设没有问题，我们可以继续链接。</p><p>我们的各个着色器已经编译完成，但要实际使用它们，我们必须将它们链接到一个可以在GPU上运行的程序中。这就是我们从现在开始谈论“着色器”时所指的内容。我们可以这样做：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#">Handle = GL.CreateProgram();<br><br>GL.AttachShader(Handle, VertexShader);<br>GL.AttachShader(Handle, FragmentShader);<br><br>GL.LinkProgram(Handle);<br><br>GL.GetProgram(Handle, GetProgramParameterName.LinkStatus, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> success);<br><span class="hljs-keyword">if</span> (success == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">string</span> infoLog = GL.GetProgramInfoLog(Handle);<br>    Console.WriteLine(infoLog);<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是全部了！现在，handle是一个可用的着色器程序。</p><p>在离开构造函数之前，我们应该进行一些清理工作。现在，各个顶点和片段着色器已经被链接后就变得无用了；当你链接时，编译的数据被复制到着色器程序中。你也不需要将这些单独的着色器附加到程序中；让我们将它们分离然后删除它们。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.DetachShader(Handle, VertexShader);<br>GL.DetachShader(Handle, FragmentShader);<br>GL.DeleteShader(FragmentShader);<br>GL.DeleteShader(VertexShader);<br></code></pre></td></tr></table></figure><p>现在我们有一个有效的着色器，所以让我们添加一种使用它的方法。将以下函数添加到Shader类中：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span><br>&#123;<br>    GL.UseProgram(Handle);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们需要在这个类被销毁后清理handle。我们不能在终结器中这样做，因为面向对象语言的问题。相反，我们必须从IDisposable派生，并记得手动调用Dispose来释放我们的着色器。在你的其余代码下面，添加以下内容：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> disposedValue = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> disposing</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!disposedValue)<br>    &#123;<br>        GL.DeleteProgram(Handle);<br><br>        disposedValue = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br>~Shader()<br>&#123;<br>    <span class="hljs-keyword">if</span> (disposedValue == <span class="hljs-literal">false</span>)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;GPU Resource leak! Did you forget to call Dispose()?&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>&#123;<br>    Dispose(<span class="hljs-literal">true</span>);<br>    GC.SuppressFinalize(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>恭喜！我们现在有了一个功能完备的着色器类。</p><p>在你的窗口类中，添加一个新的属性，Shadershader;。然后，在glControl1_Load中，添加一行shader = newShader("shader.vert","shader.frag");。<code>接着，转到OnUnload，并添加一行shader.Dispose();。？？</code></p><p>尝试运行；如果控制台没有输出任何内容，那么你的着色器已经成功编译了！</p><h3 id="链接顶点属性">链接顶点属性</h3><p>顶点着色器允许我们以顶点属性的形式指定任何输入。虽然这提供了很大的灵活性，但这意味着我们必须手动指定输入数据的哪一部分传递给顶点着色器中的哪个顶点属性。这意味着我们必须在渲染之前指定OpenGL应该如何解释顶点数据。</p><p>这种格式信息存储在所谓的顶点数组对象（VAO）中。VAO包含有关顶点格式以及要从哪些缓冲区读取的信息。我们稍后将更详细地讨论这一点，但首先我们创建一个VAO并绑定它，如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> VertexArrayObject = GL.GenVertexArray();<br>GL.BindVertexArray(VertexArrayObject);<br></code></pre></td></tr></table></figure><p>我们创建并绑定了VAO后，可以开始指定顶点格式和数据缓冲区。为此，首先需要查看我们顶点缓冲区的格式。</p><p>我们的顶点缓冲区数据格式如下：</p><p><img src="2-vertex_attribute_pointer.png" /></p><ul><li>位置数据存储为32位（4字节）浮点值。</li><li>每个位置由其中的3个值组成。</li><li>每组3个值之间没有空格（或其他值）。这些值在数组中紧密地排列。</li><li>数据中的第一个值位于缓冲区的开头。</li></ul><p>有了这些知识，我们可以告诉OpenGL如何解释顶点数据（每个顶点属性），使用GL.VertexAttribPointer：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>GL.VertexAttribPointer函数具有许多参数，让我们仔细地逐个讨论它们：</p><ul><li>第一个参数指定了我们要配置的顶点属性。记住，我们在顶点着色器中使用了layout(location=0)来指定位置顶点属性的位置。这将位置顶点属性的位置设置为0，因此我们传入0。</li><li>接下来的参数指定了顶点属性的大小。位置顶点属性是一个vec3，因此由3个值组成。</li><li>第三个参数指定了数据的类型，这里是浮点数（在GLSL中，vec*由浮点值组成）。</li><li>接下来的参数指定了是否希望数据被标准化。如果我们输入整数数据类型（int、byte），并将其设置为true，那么整数数据在转换为浮点数时会被标准化为0（或对于有符号数据为-1）和1。对我们来说，这并不相关，所以我们将其保持为false。</li><li>第五个参数被称为步长（stride），告诉我们相邻顶点属性之间的间隔空间。由于下一组位置数据恰好位于比一个浮点数大3倍的位置，我们将该值指定为步长。请注意，由于我们知道数组是紧密打包的（下一个顶点属性值之间没有空间），我们也可以将步长指定为0，让OpenGL确定步长（这仅在值紧密打包时有效）。每当我们有更多的顶点属性时，我们都必须仔细定义每个顶点属性之间的间隔，但我们稍后会看到更多的例子。</li><li>最后一个参数是位置数据在缓冲区中开始的偏移量。由于位置数据位于数据数组的开头，这个值就是0。我们将在后面更详细地探讨这个参数。</li></ul><p>每个顶点属性从由VBO管理的内存中获取其数据，它从哪个VBO获取数据（您可以有多个VBO）是由在调用GL.VertexAttribPointer时绑定到ArrayBuffer的VBO决定的。由于在调用glVertexAttribPointer之前，先前定义的VBO仍然绑定，因此顶点属性0现在与其顶点数据关联起来了。</p><p>现在我们已经指定了OpenGL应该如何解释顶点数据，我们还应该使用GL.EnableVertexAttribArray启用顶点属性，将顶点属性的位置作为其参数；顶点属性默认是禁用的。</p><p>从那时起，我们已经准备就绪：我们使用顶点缓冲对象初始化了缓冲区中的顶点数据，设置了顶点和片段着色器，并告诉OpenGL如何将顶点数据链接到顶点着色器的顶点属性。在OpenGL中绘制对象现在看起来会像这样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><br>GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>shader.Use()<br><span class="hljs-comment">// 3. now draw the object</span><br>someOpenGLFunctionThatDrawsOurTriangle();<br></code></pre></td></tr></table></figure><p>每次我们想要绘制一个对象时，我们都必须重复这个过程。这可能看起来不是很多，但想象一下，如果我们有五个或更多的顶点属性，以及可能有数百个不同的对象（这并不罕见）。为每个对象绑定适当的缓冲对象并配置所有顶点属性很快就会变得繁琐起来。如果有一种方法可以将所有这些状态配置存储到一个对象中，并简单地绑定该对象来恢复其状态呢？</p><h3 id="顶点数组对象">顶点数组对象</h3><p>顶点数组对象（Vertex ArrayObject，也称为VAO）可以像顶点缓冲对象一样绑定，从那时起，任何后续的顶点属性调用都将存储在VAO中。这样做的好处是，当配置顶点属性指针时，您只需要进行一次调用，每当我们想要绘制对象时，我们只需绑定相应的VAO。这使得在不同的顶点数据和属性配置之间切换就像绑定不同的VAO一样简单。我们刚刚设置的所有状态都存储在VAO中。</p><p>核心OpenGL要求我们使用VAO，这样它才知道如何处理我们的顶点输入。如果我们没有绑定VAO，OpenGL很可能会拒绝绘制任何东西。</p><p>顶点数组对象存储以下内容：</p><ul><li>GL.EnableVertexAttribArray或GL.DisableVertexAttribArray的调用。</li><li>通过GL.VertexAttribPointer进行的顶点属性配置。</li><li>通过GL.VertexAttribPointer调用与顶点属性相关联的顶点缓冲对象。</li></ul><p><img src="2-vertex_array_objects.png" /></p><p>要生成一个VAO的过程与生成VBO的过程相似。作为一个属性，添加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> VertexArrayObject;<br></code></pre></td></tr></table></figure><p>然后，在OnLoad中，在调用GL.BindVertexArray之前，添加：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">VertexArrayObject = GL.GenVertexArray();<br></code></pre></td></tr></table></figure><p>要使用VAO，你只需要绑定VAO使用GL.BindVertexArray。从那时起，我们应该绑定/配置相应的VBO(s)和属性指针，并且然后解绑VAO以便以后使用。只要我们想要绘制一个对象，我们只需在绘制对象之前简单地绑定带有所需设置的VAO，然后绘制对象，就这样。在代码中，这看起来会像这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// ..:: 初始化代码（只需一次（除非你的对象经常变化））:: ..</span><br><span class="hljs-comment">// 1. 绑定顶点数组对象</span><br>GL.BindVertexArray(VertexArrayObject);<br><span class="hljs-comment">// 2. 将我们的顶点数组复制到OpenGL要使用的缓冲区中</span><br>GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><span class="hljs-comment">// 3. 然后设置我们的顶点属性指针</span><br>GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>然后，要实际绘制对象，你可以在渲染循环中放置以下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.UseProgram();<br>GL.BindVertexArray(VertexArrayObject);<br>someOpenGLFunctionThatDrawsOurTriangle();<br></code></pre></td></tr></table></figure><p>这就是全部！我们在过去几百万页中所做的一切都导致了这一刻，一个存储了我们的顶点属性配置和使用哪个VBO的VAO。通常，当你有多个对象要绘制时，你首先生成/配置所有的VAO（因此也生成/配置了所需的VBO和属性指针），然后存储它们以供以后使用。当我们想要绘制我们的对象之一时，我们取相应的VAO，绑定它，然后绘制对象，再次解绑VAO。</p><p>为了绘制我们选择的对象，OpenGL为我们提供了GL.DrawArrays函数，它使用当前激活的着色器、先前定义的顶点属性配置以及VBO的顶点数据（通过VAO间接绑定）来绘制图元。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">shader.Use();<br>GL.BindVertexArray(VertexArrayObject);<br>GL.DrawArrays(PrimitiveType.Triangles, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>GL.DrawArrays函数的第一个参数是我们想要绘制的OpenGL图元类型。由于我在开头说过我们想要绘制一个三角形，而我不喜欢欺骗你，我们传入PrimitiveType.Triangles。第二个参数指定了我们想要绘制的顶点数组的起始索引；因为我们想要绘制所有的顶点，所以我们将其留在0。最后一个参数指定了我们想要绘制的顶点数量，这是3（我们只从我们的数据中渲染一个三角形，它恰好是3个顶点长）。</p><p>现在尝试编译代码，如果出现任何错误，请从错误开始逆向操作。当你的应用程序编译成功后，你应该会看到以下结果。</p><p><img src="hellotriangle.png" /></p><h3 id="补充说明动态检索着色器布局">补充说明：动态检索着色器布局</h3><p>在这个例子中，当我们调用GL.VertexAttribPointer时，我们为变量的位置使用了硬编码的布局0。这仅适用于我们在shader.vert中显式将布局设置为0的情况。但是，如果你不想这样做呢？如果你愿意，你可以在运行时检索位置。</p><p>如果你想这样做，可以在你的Shader类中添加以下函数。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">csharpCopy codepublic <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetAttribLocation</span><span class="hljs-params">(string attribName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> GL.<span class="hljs-title">GetAttribLocation</span><span class="hljs-params">(Handle, attribName)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在设置VAO时，你可以使用shader.GetAttribLocation("aPosition")代替0。如果你这样做，你就不必再在着色器中包含layout(location=0)这一行了。</p><p>本教程将坚持使用硬编码的值，但重要的是要知道两种方法都可以实现。</p><hr /><p>以上就是OpenTK的绘制三角形的简单的入门使用</p><h1 id="进阶使用">进阶使用</h1><h2 id="元素缓冲区对象">元素缓冲区对象</h2><p>我们已经渲染了我们的第一个三角形，但是如果我们想做一些更复杂的事情呢？比如说，一个矩形？</p><p>OpenGL专门使用三角形进行渲染。它对正方形和其他形状有部分支持，但是这些功能已经被废弃很长时间了，不应该使用。你可以通过定义六个顶点来制作两个看起来像一个形状的三角形，但是这样做会浪费，因为一个矩形只需要四个顶点。虽然这可能看起来不是很糟糕，但是考虑一个立方体：如果没有浪费，只需要八个顶点，但是如果你使用每个面由两个三角形组成的方法，那么单个立方体就需要36个顶点！随着模型变得更复杂，数字只会变得更糟；显然，需要一种更好的方法。</p><p>有很多不同的方法可以做到这一点（比如三角带），但是在本教程中，我们将使用称为元素缓冲对象的东西，它是一种允许我们重复使用顶点来创建多个图元的缓冲区类型。使用EBO，我们将能够仅使用四个顶点创建一个矩形。</p><p>用以下内容替换你的顶点数组：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">float</span>[] vertices = &#123;<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右上角</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 左下角</span><br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">// 左上角</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>然后，在下面，添加以下数组：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">uint</span>[] indices = &#123;  <span class="hljs-comment">// 注意我们从0开始！</span><br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,   <span class="hljs-comment">// 第一个三角形</span><br>    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    <span class="hljs-comment">// 第二个三角形</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>索引数组将被提供给我们的EBO，以指定哪些顶点将用于创建三角形。这个数组将使用顶点0、1和3创建一个三角形，使用顶点1、2和3创建第二个三角形。</p><p>接下来，在属性下面，添加以下行：int ElementBufferObject。</p><p>现在，在OnLoad中，在初始化VertexBufferObject的地方下面，我们以类似的方式初始化ElementBufferObject：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">ElementBufferObject = GL.GenBuffer();<br>GL.BindBuffer(BufferTarget.ElementArrayBuffer, ElementBufferObject);<br>GL.BufferData(BufferTarget.ElementArrayBuffer, indices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">uint</span>), indices, BufferUsageHint.StaticDraw);<br></code></pre></td></tr></table></figure><blockquote><p>警告：绑定元素数组缓冲区是特殊的，只有在当前绑定了VAO时才能绑定。从概念上讲，它可以被认为是VAO拥有绑定槽。如果解绑VAO，则元素数组缓冲区仍然绑定到VAO！</p></blockquote><p>这几乎和使用VBO的方式完全一样！大多数OpenGL的缓冲区类型都会遵循这种模式：使用GL.GenBuffer()创建，使用GL.BindBuffer进行绑定，然后使用GL.BufferData添加数据。</p><p>现在，EBO已经准备好了。在OnRenderFrame中，用以下内容替换DrawArrays的调用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>这些参数依次是：</p><p>图元类型。和上次一样，我们想要使用原始的三角形。要绘制的顶点数。我们使用索引的长度来绘制所有内容。EBO元素的类型。无符号整型。我们要绘制的偏移量。因为我们想要绘制所有内容，所以我们只使用0。</p><p>就是这样！现在如果运行你的程序，你应该能够看到你有一个矩形，而不是一个三角形。</p><h2 id="着色器-1">着色器</h2><p>如在入门使用章节中所述，着色器是在GPU上运行的小程序。这些程序针对图形管线的每个特定部分运行。从基本意义上讲，着色器不过是将输入转换为输出的程序。着色器也是非常隔离的程序，它们不允许彼此通信；它们之间唯一的通信方式是通过它们的输入和输出。</p><p>在前一章中，我们简要介绍了着色器及其如何正确使用。现在我们将以更一般的方式解释着色器，特别是OpenGL着色语言。</p><h3 id="glslopengl着色语言">GLSL（OpenGL着色语言）</h3><p>着色器是用类似C的语言GLSL编写的。GLSL专门用于图形处理，并包含针对向量和矩阵操作的有用特性。</p><p>着色器总是以版本声明开头，然后是一系列的输入和输出变量、uniform变量以及它的主函数。每个着色器的入口点都在它的主函数中，在那里我们处理任何输入变量并将结果输出到它的输出变量中。如果你不知道uniform是什么，不用担心，我们马上就会讲到。</p><p>一个着色器通常具有以下结构：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version version_number</span><br><span class="hljs-keyword">in</span> type in_variable_name;<br><span class="hljs-keyword">in</span> type in_variable_name;<br><br><span class="hljs-keyword">out</span> type out_variable_name;<br><br><span class="hljs-keyword">uniform</span> type uniform_name;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>  <span class="hljs-comment">// 处理输入并进行一些奇怪的图形处理</span><br>  ...<br>  <span class="hljs-comment">// 将处理后的内容输出到输出变量</span><br>  out_variable_name = weird_stuff_we_processed;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们特别谈论顶点着色器时，每个输入变量也被称为顶点属性。我们可以声明的顶点属性数量受到硬件限制。OpenGL保证至少有16个4分量的顶点属性可用，但一些硬件可能允许更多，您可以通过查询GL_MAX_VERTEX_ATTRIBS来获取：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> nrAttributes = <span class="hljs-number">0</span>;<br>GL.GetInteger(GetPName.MaxVertexAttribs, <span class="hljs-keyword">out</span> nrAttributes);<br>Console.WriteLine(<span class="hljs-string">&quot;支持的最大顶点属性数量：&quot;</span> + nrAttributes);<br></code></pre></td></tr></table></figure><p>这通常返回至少16的最小值，对于大多数情况来说应该足够了。</p><h3 id="类型">类型</h3><p>与任何其他编程语言一样，GLSL具有用于指定我们想要使用的变量类型的数据类型。GLSL具有大多数我们从C语言等语言中了解的默认基本类型：int、float、double、uint和bool。GLSL还具有两种容器类型，我们将经常使用它们，即向量和矩阵。我们将在以后的章节中讨论矩阵。</p><h3 id="向量">向量</h3><p>在GLSL中，向量是一个包含任何基本类型中提到的1、2、3或4个组件的容器。它们可以采用以下形式（n代表组件的数量）：</p><ul><li>vecn：n个浮点数的默认向量。</li><li>bvecn：n个布尔值的向量。</li><li>ivecn：n个整数的向量。</li><li>uvecn：n个无符号整数的向量。</li><li>dvecn：n个双精度组件的向量。</li></ul><p>大多数时候，我们将使用基本的vecn，因为对于大多数情况来说，float类型已经足够了。</p><p>可以通过vec.x来访问向量的组件，其中x是向量的第一个组件。您可以使用.x、.y、.z和.w来分别访问它们的第一个、第二、第三和第四个组件。GLSL还允许您使用rgba表示颜色或使用stpq表示纹理坐标，以访问相同的组件。</p><p>向量数据类型允许进行一些有趣且灵活的组件选择，称为swizzling。Swizzling允许我们使用以下语法：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> someVec;<br><span class="hljs-type">vec4</span> differentVec = someVec.xyxx;<br><span class="hljs-type">vec3</span> anotherVec = differentVec.zyw;<br><span class="hljs-type">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;<br></code></pre></td></tr></table></figure><p>您可以使用最多4个字母的任意组合来创建一个新的向量（相同类型的）只要原始向量具有这些组件；例如，不允许访问vec2的.z组件。我们还可以将向量作为参数传递给不同的向量构造函数调用，从而减少所需的参数数量：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> vect = <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span>);<br><span class="hljs-type">vec4</span> result = <span class="hljs-type">vec4</span>(vect, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><span class="hljs-type">vec4</span> otherResult = <span class="hljs-type">vec4</span>(result.xyz, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><p>因此，向量是一种灵活的数据类型，我们可以用它来处理各种输入和输出。在本书中，您将看到许多关于如何创造性地管理向量的示例。</p><h3 id="输入和输出">输入和输出</h3><p>着色器本身是很好的小程序，但它们是整体的一部分，因此我们希望在各个着色器上有输入和输出，以便我们可以移动数据。GLSL专门为此目的定义了in和out关键字。每个着色器都可以使用这些关键字指定输入和输出，其中输出变量与下一个着色器阶段的输入变量匹配时，它们将被传递。然而，顶点着色器和片段着色器有所不同。</p><p>顶点着色器应该接收某种形式的输入，否则它将是相当无效的。顶点着色器的输入与众不同，它直接从顶点数据中接收输入。为了定义顶点数据的组织方式，我们使用位置元数据来指定输入变量，以便我们可以在CPU上配置顶点属性。我们在前一章中已经看到了这一点，即layout（location=0）。因此，顶点着色器需要额外的布局规范来指定其输入，以便我们可以将其与顶点数据链接起来。</p><p>也可以省略layout（location =0）规范，并在OpenGL代码中通过glGetAttribLocation查询属性位置，但我更喜欢在顶点着色器中设置它们。这样更容易理解，也节省了您（和OpenGL）一些工作。</p><p>另一个例外是，片段着色器需要一个vec4颜色输出变量，因为片段着色器需要生成最终的输出颜色。如果您未在片段着色器中指定输出颜色，则这些片段的颜色缓冲输出将未定义（通常意味着OpenGL将它们渲染为黑色或白色）。</p><p>因此，如果我们想要从一个着色器发送数据到另一个着色器，我们必须在发送着色器中声明一个输出，在接收着色器中声明一个类似的输入。当两侧的类型和名称相等时，OpenGL将这些变量链接在一起，然后可以在着色器之间发送数据（这是在链接程序对象时完成的）。为了向您展示这在实践中是如何工作的，我们将修改上一章中的着色器，让顶点着色器决定片段着色器的颜色。</p><h3 id="顶点着色器">顶点着色器</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos; <span class="hljs-comment">// 位置变量在位置0处</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> vertexColor; <span class="hljs-comment">// 向片段着色器指定一个颜色输出</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// 将vec3直接传递给vec4的构造函数</span><br>    vertexColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// 将输出变量设置为深红色</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="片段着色器">片段着色器</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> vertexColor; <span class="hljs-comment">// 来自顶点着色器的输入变量（名称和类型相同）</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = vertexColor;<br>&#125;<br></code></pre></td></tr></table></figure><p>您可以看到，我们声明了一个vertexColor变量作为vec4输出，在顶点着色器中设置了它，并在片段着色器中声明了一个类似的vertexColor输入。由于它们都具有相同的类型和名称，片段着色器中的vertexColor与顶点着色器中的vertexColor链接在一起。由于我们在顶点着色器中将颜色设置为深红色，因此结果片段应该也是深红色。</p><h3 id="uniforms">Uniforms</h3><p>统一变量是另一种将数据从CPU上的应用程序传递到GPU上的着色器的方式。然而，与顶点属性相比，统一变量稍有不同。首先，统一变量是全局的。全局意味着每个着色器程序对象中的统一变量都是唯一的，并且可以在着色器程序的任何阶段的任何着色器中访问。其次，无论您将统一变量的值设置为什么，统一变量都会保持其值，直到被重新设置或更新为止。</p><p>要在GLSL中声明一个统一变量，我们只需在着色器中添加uniform关键字，然后加上一个类型和一个名称。从那时起，我们就可以在着色器中使用新声明的统一变量。让我们看看这次我们能否通过一个统一变量来设置三角形的颜色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br>  <br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec4</span> ourColor; <span class="hljs-comment">// 我们将在OpenGL代码中设置这个变量。</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = ourColor;<br>&#125;   <br></code></pre></td></tr></table></figure><p>我们在片段着色器中声明了一个uniform vec4ourColor，并将片段的输出颜色设置为该统一变量的内容。由于统一变量是全局变量，我们可以在任何我们想要的着色器阶段定义它们，所以不需要再通过顶点着色器来将数据传递到片段着色器。我们在顶点着色器中没有使用这个统一变量，因此也不需要在那里定义它。</p><p>如果您声明了一个在GLSL代码中未被使用的统一变量，编译器将在编译后的版本中静默删除该变量，这是导致一些令人沮丧的错误的原因；请牢记这一点！</p><p>目前这个统一变量是空的；我们还没有向统一变量中添加任何数据，所以让我们尝试一下。我们首先需要找到着色器中统一变量属性的索引/位置。一旦我们有了统一变量的索引/位置，我们就可以更新它的值。我们不再将单一颜色传递到片段着色器中，让我们通过随时间逐渐改变颜色来增添一些色彩：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">double</span> timeValue = _timer.Elapsed.TotalSeconds;<br><span class="hljs-built_in">float</span> greenValue = (<span class="hljs-built_in">float</span>)Math.Sin(timeValue) / <span class="hljs-number">2.0f</span> + <span class="hljs-number">0.5f</span>;<br><span class="hljs-built_in">int</span> vertexColorLocation = GL.GetUniformLocation(_shader.Handle, <span class="hljs-string">&quot;ourColor&quot;</span>);<br>GL.Uniform4(vertexColorLocation, <span class="hljs-number">0.0f</span>, greenValue, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br></code></pre></td></tr></table></figure><p>首先，我们通过StopWatch对象_calld_timer获取了运行时间（以秒为单位）。然后，我们使用sin函数将颜色在0.0- 1.0范围内变化，并将结果存储在greenValue中。</p><p>然后，我们使用glGetUniformLocation查询ourColor统一变量的位置。我们向查询函数提供了着色器程序和统一变量的名称（我们要从中检索位置的名称）。如果glGetUniformLocation返回-1，则表示找不到位置。最后，我们可以使用glUniform4f函数设置统一变量的值。请注意，查找统一变量的位置不需要您首先使用着色器程序，但是更新统一变量需要您首先使用程序（通过调用glUseProgram），因为它会将统一变量设置为当前活动的着色器程序。</p><p>由于OpenGL本质上是一个C库，它不支持函数重载，因此无论函数是否可以使用不同类型进行调用，OpenGL都为每种所需类型定义了新的函数；glUniform就是一个很好的例子。该函数需要用于要设置的统一变量类型的特定后缀。一些可能的后缀包括：</p><ul><li><p>f：该函数希望值为float。</p></li><li><p>i：该函数希望值为int。</p></li><li><p>ui：该函数希望值为unsigned int。</p></li><li><p>3f：该函数希望值为3个float。</p></li><li><p>fv：该函数希望值为float向量/数组。</p></li></ul><p>每当您想要配置OpenGL选项时，只需选择与您的类型对应的重载函数。在我们的情况下，我们想要单独设置统一变量的4个浮点数，因此我们通过glUniform4f传递我们的数据（请注意，我们也可以使用fv版本）。</p><p>现在我们知道如何设置统一变量的值了，我们可以将它们用于渲染。如果我们希望颜色逐渐改变，我们希望在每一帧更新这个统一变量，否则三角形将保持单一的固定颜色，如果我们只设置一次。因此，我们计算greenValue，并在每次渲染迭代之前更新统一变量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderFrame</span>(<span class="hljs-params">FrameEventArgs e</span>)</span><br>&#123;<br>    <span class="hljs-keyword">base</span>.OnRenderFrame(e);<br><br>    <span class="hljs-comment">// 渲染</span><br>    <span class="hljs-comment">// 清除颜色缓冲区</span><br>    GL.Clear(ClearBufferMask.ColorBufferBit);<br><br>    <span class="hljs-comment">// 确保激活着色器</span><br>    _shader.Use();<br><br>    <span class="hljs-comment">// 更新统一变量颜色</span><br>    <span class="hljs-built_in">double</span> timeValue = _timer.Elapsed.TotalSeconds;<br>    <span class="hljs-built_in">float</span> greenValue = (<span class="hljs-built_in">float</span>)Math.Sin(timeValue) / <span class="hljs-number">2.0f</span> + <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-built_in">int</span> vertexColorLocation = GL.GetUniformLocation(_shader.Handle, <span class="hljs-string">&quot;ourColor&quot;</span>);<br>    GL.Uniform4(vertexColorLocation, <span class="hljs-number">0.0f</span>, greenValue, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br><br><br>    <span class="hljs-comment">// 现在渲染三角形</span><br>    GL.BindVertexArray(_vertexArrayObject);<br>    GL.DrawArrays(PrimitiveType.Triangles, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 交换缓冲区</span><br>    SwapBuffers();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是前一段代码的一个相对简单的改编。这一次，在绘制三角形之前，我们每帧更新一次统一变量的值。如果您正确更新了统一变量，您应该可以看到三角形的颜色从绿色逐渐变为黑色，然后再变回绿色。</p><p>正如您所看到的，统一变量是一个有用的工具，用于设置每一帧可能会变化的属性，或者用于在应用程序和着色器之间交换数据，但是如果我们想为每个顶点设置一个颜色怎么办？在这种情况下，我们必须为每个顶点声明许多统一变量。更好的解决方案是在顶点属性中包含更多的数据，这就是我们接下来要做的事情。</p><h3 id="更多属性">更多属性</h3><p>在上一章中，我们学习了如何填充VBO、配置顶点属性指针并将所有数据存储在 VAO中。这一次，我们还想要向顶点数据中添加颜色数据。我们将颜色数据作为 3个浮点数添加到顶点数组中。我们分别为三角形的每个角分配了红色、绿色和蓝色：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">float</span>[] _vertices =<br>&#123;<br>    <span class="hljs-comment">// positions        // colors</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// bottom right</span><br>   <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// bottom left</span><br>    <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>    <span class="hljs-comment">// top </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>由于我们现在要发送更多数据到顶点着色器，因此需要调整顶点着色器以接收颜色值作为顶点属性输入。请注意，我们使用布局说明符将aColor 属性的位置设置为 1：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;   <span class="hljs-comment">// the position variable has attribute position 0</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aColor; <span class="hljs-comment">// the color variable has attribute position 1</span><br>  <br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> ourColor; <span class="hljs-comment">// output a color to the fragment shader</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    ourColor = aColor; <span class="hljs-comment">// set ourColor to the input color we got from the vertex data</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们不再使用 uniform 来设置片段的颜色，而是使用了 ourColor输出变量，因此还需要更改片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;  <br><span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> ourColor;<br>  <br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = <span class="hljs-type">vec4</span>(ourColor, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们添加了另一个顶点属性并更新了 VBO的内存，因此必须重新配置顶点属性指针。VBO内存中的更新数据现在如下所示：</p><p><img src="4-vertex_attribute_pointer_interleaved.png" /></p><p>了解了当前的布局，我们可以使用 glVertexAttribPointer更新顶点格式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>GL.VertexAttribPointer(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br>GL.EnableVertexAttribArray(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>glVertexAttribPointer 的前几个参数相对简单。这次我们在属性位置 1上配置了顶点属性。颜色值有 3个浮点数大小，并且我们不对值进行归一化处理。</p><p>由于我们现在有两个顶点属性，因此必须重新计算步幅值。为了获取数据数组中的下一个属性值（例如位置向量的下一个x 分量），我们必须向右移动 6个浮点数，其中三个用于位置值，三个用于颜色值。这给了我们步幅值为 6乘以浮点数的大小（= 24字节）。此外，这次我们必须指定偏移量。对于每个顶点，位置顶点属性首先出现，因此偏移量为0。颜色属性在位置数据之后开始，因此偏移量为 3 * sizeof(float) 字节（= 12字节）。</p><p>运行应用程序应该会产生以下图像：</p><p><img src="更多属性.png" /></p><p>图像可能不是您预期的，因为我们只提供了 3种颜色，而不是我们现在看到的庞大颜色调色板。这一切都是片段着色器中称为片段插值的结果。当渲染三角形时，光栅化阶段通常会产生比最初指定的顶点更多的片段。然后，光栅化器根据它们在三角形形状上的位置确定每个片段的位置。基于这些位置，它会对所有片段着色器的输入变量进行插值。举个例子，假设我们有一条线，上点是绿色，下点是蓝色。如果片段着色器在线的70%位置处运行，那么其结果的颜色输入属性将是绿色和蓝色的线性组合；更准确地说是：30%的蓝色和 70% 的绿色。</p><p>这正是在三角形中发生的情况。我们有 3 个顶点，因此有 3种颜色，从三角形的像素来看，它可能包含大约 50000个片段，片段着色器在这些像素之间进行颜色插值。如果您仔细观察颜色，您会发现这一切都是有道理的：从红色到蓝色首先变成紫色，然后变成蓝色。片段插值应用于所有片段着色器的输入属性。</p><h2 id="纹理">纹理</h2><p>我们学到了通过为每个顶点指定颜色来为对象添加更多细节，从而创建一些有趣的图像。然而，为了获得相当程度的逼真感，我们必须拥有许多顶点，以便我们可以指定许多颜色。这会增加相当多的额外开销，因为每个模型都需要更多的顶点，而且每个顶点都需要一个颜色属性。</p><p>艺术家和程序员通常更喜欢使用纹理。纹理是一个2D图像（虽然存在1D和3D纹理，但它们并不常见），用于为对象添加细节；可以将纹理想象成一个带有漂亮砖块图像（例如）的纸张，整齐地折叠在你的3D房屋上，使得你的房子看起来像是外部有石头覆盖。由于我们可以在单个图像中插入许多细节，因此我们可以产生这样的幻觉，即对象非常详细，而无需指定额外的顶点。</p><p>除了图像之外，纹理还可以用于存储大量数据以发送到着色器，但我们将把这留到另一个话题。</p><p>下面你将看到一个砖墙的纹理图像被映射到前面教程中的三角形上。</p><p><img src="wall.jpg" /></p><p>为了将纹理映射到三角形上，我们需要告诉三角形的每个顶点它对应纹理的哪一部分。因此，每个顶点都应该有一个与之关联的纹理坐标，指定从纹理图像中采样的部分。然后，片段插值会为其他片段完成剩余工作。</p><p>纹理坐标在x和y轴上的范围是从0到1（记住我们使用的是2D纹理图像）。使用纹理坐标检索纹理颜色称为采样。纹理坐标从纹理图像的左下角（0,0）开始，到右上角（1,1）结束。下面的图像展示了我们如何将纹理坐标映射到三角形上：</p><p><img src="5-tex_coords.png" /></p><p>我们为三角形指定了3个纹理坐标点。我们希望三角形的左下边对应纹理的左下边，因此我们对三角形的左下顶点使用了纹理坐标(0,0)。对于右下边，我们使用了(1,0)作为纹理坐标。三角形的顶部应该对应纹理图像的顶部中心，因此我们将(0.5,1.0)作为其纹理坐标。我们只需将3个纹理坐标传递给顶点着色器，然后顶点着色器将这些坐标传递给片段着色器，后者将为每个片段精确插值所有纹理坐标。</p><p>结果的纹理坐标如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">float</span>[] texCoords = &#123;<br>    <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// lower-left corner  </span><br>    <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// lower-right corner</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">1.0f</span>   <span class="hljs-comment">// top-center corner</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>纹理采样具有宽泛的解释，并且可以通过许多不同的方式进行。因此，我们的任务是告诉OpenGL应该如何对其纹理进行采样。</p><h3 id="纹理包裹">纹理包裹</h3><p>纹理坐标通常范围在 (0,0) 到 (1,1)之间，但如果我们指定超出此范围的坐标会发生什么？OpenGL的默认行为是重复纹理图像（基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多选项：</p><ul><li>Repeat（重复）：纹理的默认行为。重复纹理图像。</li><li>MirroredRepeat（镜像重复）：与 GL_REPEAT相同，但在每次重复时镜像图像。</li><li>ClampToEdge（夹取到边缘）：将坐标夹取在 0 和 1之间。结果是，较高的坐标将夹取到边缘，导致边缘拉伸的图案。</li><li>ClampToBorder（夹取到边界）：超出范围的坐标现在被赋予用户指定的边界颜色。</li></ul><p>每个选项在使用纹理坐标超出默认范围时都会产生不同的视觉效果。让我们看看这些选项在示例纹理图像上的效果：</p><p><img src="5-texture_wrapping.png" /></p><p>上述提到的每个选项都可以通过 GL.TexParameter函数针对每个坐标轴（s、t（如果您使用 3D 纹理，则为 p，相当于x、y、z））进行设置：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br></code></pre></td></tr></table></figure><blockquote><p>注意：您必须将枚举强制转换为 int 才能使 GL.TexParameter 接受它。</p></blockquote><p>第一个参数指定纹理目标；我们使用 2D 纹理，因此纹理目标是TextureTarget.Texture2D。</p><p>第二个参数要求我们告诉它我们想设置哪个选项以及对应的纹理轴。我们想配置WRAP 选项，并为 S 和 T 轴指定它。</p><p>最后一个参数要求我们传入我们想要的纹理包裹模式，在这种情况下，OpenGL将使用 TextureWrapMode.Repeat 设置当前活动纹理的纹理包裹选项。</p><p>如果我们选择 TextureWrapMode.ClampToBorder选项，我们还应该指定边界颜色。这可以使用 fv 版本的 glTexParameter函数来完成，其中选项为TextureParameterName.TextureBorderColor，我们传入一个边界颜色值的浮点数组：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">float</span>[] borderColor = &#123; <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureBorderColor, borderColor);<br></code></pre></td></tr></table></figure><h3 id="纹理过滤">纹理过滤</h3><p>纹理坐标不依赖于分辨率，而可以是任何浮点值，因此OpenGL必须确定要将纹理坐标映射到哪个纹理像素（也称为纹素）。如果您有一个非常大的对象和一个低分辨率的纹理，这变得尤为重要。您现在可能已经猜到，OpenGL也有针对这种纹理过滤的选项。有几个选项可用，但现在我们将讨论最重要的选项：最近和线性。</p><p>最近（也称为最近邻过滤）是OpenGL的默认纹理过滤方法。当设置为最近时，OpenGL选择最靠近纹理坐标的像素中心。下面您可以看到4个像素，十字表示确切的纹理坐标。左上角的纹素其中心最靠近纹理坐标，因此被选为采样颜色：</p><p><img src="5-texture_filter_nearest.png" /></p><p>线性（也称为（双）线性过滤）从纹理坐标的相邻纹素中取得一个插值的值，从而近似计算出纹素之间的颜色。纹理坐标到纹素中心的距离越小，该纹素的颜色就对采样颜色贡献越大。下面我们可以看到返回的相邻像素的混合颜色：</p><p><img src="5-texture_filter_linear.png" /></p><p>但是，这种纹理过滤方法的视觉效果是什么呢？让我们看看在大对象上使用低分辨率纹理时这些方法的工作方式（因此纹理被放大，单个纹素是可见的）：</p><p><img src="5-texture_filtering.png" /></p><p>最近邻过滤产生了明显的像素块模式，我们可以清楚地看到形成纹理的像素，而线性过滤产生了更平滑的模式，单个像素不太明显。线性过滤产生了更真实的输出，但有些开发人员更喜欢复古、像素化的外观，因此选择了最近邻选项。</p><p>纹理过滤可以针对放大和缩小操作（放大或缩小时）进行设置，因此您可以在纹理被缩小时使用最近邻过滤，而在纹理被放大时使用线性过滤。因此，我们必须通过GL.TexParameter为两种选项指定过滤方法。代码应该类似于设置包装方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.Nearest);<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br></code></pre></td></tr></table></figure><h3 id="mipmaps">Mipmaps</h3><p>想象一下，我们有一个庞大的房间，里面摆放着成千上万个物体，每个物体都附有一个贴图。远处的物体和近处的物体都使用同样的高分辨率贴图。由于远处的物体只产生少量片段，OpenGL在从高分辨率贴图中为片段选择正确的颜色值时会遇到困难，因为它必须为跨越贴图大部分区域的片段选择一个贴图颜色。这将在小物体上产生可见的伪影，而且在小物体上使用高分辨率贴图也浪费了内存和计算资源。</p><p>为了解决这个问题，OpenGL 引入了一种叫做 Mipmaps的概念，它基本上是一组贴图图像，其中每个后续的贴图都是前一个贴图的一半大小。Mipmaps背后的思想应该很容易理解：在距离观察者一定距离后，OpenGL将使用最适合对象距离的不同 Mipmap贴图。因为对象远处，较小的分辨率对用户来说不会明显。此外，Mipmaps还有一个额外的好处，就是它们对性能也有好处。让我们更仔细地看看 Mipmapped贴图是什么样子：</p><p><img src="5-mipmaps.png" /></p><p>手动创建每个贴图图像的 Mipmapped 贴图集合很麻烦，但幸运的是，OpenGL可以在我们创建贴图后通过一次调用GL.GenerateMipmap(GenerateMipmapTarget.Texture2D)来为我们完成所有工作。稍后在贴图教程中，您将看到如何使用此函数。</p><p>在渲染过程中切换 Mipmap 级别时，OpenGL 可能会显示一些伪影，例如两个Mipmap 层之间可见的锐利边缘。就像普通的贴图过滤一样，我们也可以使用Nearest 和 Linear 过滤来在 Mipmap级别之间进行切换。我们可以用以下四个选项之一来指定 Mipmap级别之间的过滤方法：</p><ul><li>NearestMipmapNearest：选择最接近的 Mipmap来匹配像素大小，并使用最近邻插值进行贴图采样。</li><li>LinearMipmapNearest：选择最接近的 Mipmap级别，并使用线性插值进行采样。</li><li>NearestMipmapLinear：在最接近像素大小的两个 Mipmap之间进行线性插值，并通过最近邻插值采样贴图。</li><li>LinearMipmapLinear：在最接近的两个 Mipmap之间进行线性插值，并通过线性插值采样贴图。</li></ul><p>与贴图过滤一样，我们可以使用 GL.TexParameter将过滤方法设置为上述四种方法之一：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.LinearMipmapLinear);<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br></code></pre></td></tr></table></figure><p>一个常见的错误是将其中一种 Mipmap过滤选项设置为放大过滤器。这没有任何效果，因为 Mipmaps主要用于当贴图缩小时：贴图放大不使用 Mipmaps，给它一个 Mipmap过滤选项将生成一个 OpenGL GL_INVALID_ENUM 错误代码。</p><h3 id="加载和创建纹理">加载和创建纹理</h3><p>现在我们已经创建了纹理，我们需要修改我们的着色器和顶点来使用纹理。</p><p>首先，用以下顶点数组替换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">float</span>[] vertices =<br>&#123;<br>    <span class="hljs-comment">//Position          Texture coordinates</span><br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-comment">// 右上</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 右下</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下</span><br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>  <span class="hljs-comment">// 左上</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>回想一下我们之前讨论的纹理坐标以及它们的工作原理。我们将它们添加到每个顶点中。</p><p>接下来，我们将修改顶点属性位置以将纹理坐标发送到着色器。</p><p>用以下调用替换您对VertexAttribPointer的调用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.VertexAttribPointer(vertexLocation, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>几乎完全相同，只是将步长从3 * sizeof(float)更改为5 *sizeof(float)以适应新的纹理坐标。</p><p>在其下面，添加以下行：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> texCoordLocation = shader.GetAttribLocation(<span class="hljs-string">&quot;aTexCoord&quot;</span>);<br>GL.EnableVertexAttribArray(texCoordLocation);<br>GL.VertexAttribPointer(texCoordLocation, <span class="hljs-number">2</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br></code></pre></td></tr></table></figure><p>再次几乎完全与上次调用相同，只是数据包数从3变为2，并且初始偏移量为3 *sizeof(float)。</p><p>现在，我们需要修改我们的着色器。首先是顶点着色器。新代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoord;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>    texCoord = aTexCoord;<br><br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们添加了另一个输入变量aTexCoord，它将是纹理坐标。我们将其原样转发到输出变量texCoord，以便片段着色器可以使用它。说到片段着色器，接下来是它：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outputColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture0;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    outputColor = <span class="hljs-built_in">texture</span>(texture0, texCoord);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到一个全新的变量类型sampler2D。简单来说，那是着色器中纹理的表示。</p><p>最多可以一次绑定16个不同的纹理（取决于您的硬件，可能更多，但OpenGL要求至少16个）。在下一个例子中，我将向您展示如何同时使用多个纹理。但是，现在我们不需要做其他任何事情。</p><p>如果您一切都做对了，当您运行代码时，您应该看到以下内容：</p><p><img src="texture_result.png" /></p><p>祝贺您绘制了您的第一个纹理！下次，我将演示如何同时绘制多个纹理。</p><h3 id="完整代码">完整代码</h3><h4 id="form1.cs">Form1.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Diagnostics;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> OpenTK.WinForms;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Windows.Forms.VisualStyles.VisualStyleElement;<br><span class="hljs-keyword">using</span> OpenTK.Mathematics;<br><span class="hljs-keyword">using</span> OpenTK.Windowing.GraphicsLibraryFramework;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br><br>        <span class="hljs-built_in">float</span>[] vertices =<br>        &#123;<br>            <span class="hljs-comment">//Position          Texture coordinates</span><br>             <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-comment">// 右上</span><br>             <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 右下</span><br>            <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下</span><br>            <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>  <span class="hljs-comment">// 左上</span><br>        &#125;;<br>        <span class="hljs-built_in">uint</span>[] indices = &#123;  <span class="hljs-comment">// note that we start from 0!</span><br>            <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,   <span class="hljs-comment">// first triangle</span><br>            <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    <span class="hljs-comment">// second triangle</span><br>        &#125;;<br>        <span class="hljs-built_in">int</span> VertexBufferObject;<br>        <span class="hljs-built_in">int</span> vertexArrayObject;<br>        <span class="hljs-built_in">int</span> ElementBufferObject;<br>        <span class="hljs-keyword">private</span> Texture _texture;<br>        Shader shader;<br>        Stopwatch timer;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Form1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.ClearColor(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>            <br><br>            <span class="hljs-comment">// Create and bind VAO</span><br>            vertexArrayObject = GL.GenVertexArray();<br>            GL.BindVertexArray(vertexArrayObject);<br><br>            <span class="hljs-comment">// Create and bind VBO</span><br>            VertexBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>            <span class="hljs-comment">// Provide vertex data to the VBO</span><br>            GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><br>            ElementBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ElementArrayBuffer, ElementBufferObject);<br>            GL.BufferData(BufferTarget.ElementArrayBuffer, indices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">uint</span>), indices, BufferUsageHint.StaticDraw);<br><br>            shader = <span class="hljs-keyword">new</span> Shader(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.vert&quot;</span>, <span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.frag&quot;</span>);<br>            timer = <span class="hljs-keyword">new</span> Stopwatch();<br>            shader.Use();<br><br>            <span class="hljs-comment">// Specify the vertex attribute pointers</span><br>            GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>            GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-built_in">int</span> texCoordLocation = GL.GetAttribLocation(shader.Handle, <span class="hljs-string">&quot;aTexCoord&quot;</span>);<br>            GL.EnableVertexAttribArray(texCoordLocation);<br>            GL.VertexAttribPointer(texCoordLocation, <span class="hljs-number">2</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br><br>            _texture = Texture.LoadFromFile(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/Resources/container.png&quot;</span>);<br>            _texture.Use(TextureUnit.Texture0);<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Paint</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, PaintEventArgs e</span>)</span><br>        &#123;<br>            GL.Clear(ClearBufferMask.ColorBufferBit);<br><br>            GL.BindVertexArray(vertexArrayObject);<br><br>            _texture.Use(TextureUnit.Texture0);<br>            shader.Use();<br><br>            GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br><br>            glControl1.SwapBuffers();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_SizeChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> deltaTime</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//var input = KeyboardState;</span><br><br>            <span class="hljs-comment">//if (input.IsKeyDown(Keys.Escape))</span><br>            <span class="hljs-comment">//&#123;</span><br>            <span class="hljs-comment">//    Close();</span><br>            <span class="hljs-comment">//&#125;</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">timer1_Tick</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">float</span> deltaTime = (<span class="hljs-built_in">float</span>)timer.Elapsed.TotalSeconds;<br>            timer.Restart();<br><br>            OnUpdate(deltaTime);<br>            <br>            glControl1.Invalidate();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="texture.cs">Texture.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> System.Drawing;<br><span class="hljs-keyword">using</span> System.Drawing.Imaging;<br><span class="hljs-keyword">using</span> PixelFormat = OpenTK.Graphics.OpenGL.PixelFormat;<br><span class="hljs-keyword">using</span> StbImageSharp;<br><span class="hljs-keyword">using</span> System.IO;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Texture</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Handle;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture <span class="hljs-title">LoadFromFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// Generate handle</span><br>            <span class="hljs-built_in">int</span> handle = GL.GenTexture();<br><br>            <span class="hljs-comment">// Bind the handle</span><br>            GL.ActiveTexture(TextureUnit.Texture0);<br>            GL.BindTexture(TextureTarget.Texture2D, handle);<br><br>            <span class="hljs-comment">// For this example, we&#x27;re going to use .NET&#x27;s built-in System.Drawing library to load textures.</span><br><br>            <span class="hljs-comment">// OpenGL has it&#x27;s texture origin in the lower left corner instead of the top left corner,</span><br>            <span class="hljs-comment">// so we tell StbImageSharp to flip the image when loading.</span><br>            StbImage.stbi_set_flip_vertically_on_load(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// Here we open a stream to the file and pass it to StbImageSharp to load.</span><br>            <span class="hljs-keyword">using</span> (Stream stream = File.OpenRead(path))<br>            &#123;<br>                ImageResult image = ImageResult.FromStream(stream, ColorComponents.RedGreenBlueAlpha);<br><br>                <span class="hljs-comment">// Now that our pixels are prepared, it&#x27;s time to generate a texture. We do this with GL.TexImage2D.</span><br>                <span class="hljs-comment">// Arguments:</span><br>                <span class="hljs-comment">//   The type of texture we&#x27;re generating. There are various different types of textures, but the only one we need right now is Texture2D.</span><br>                <span class="hljs-comment">//   Level of detail. We can use this to start from a smaller mipmap (if we want), but we don&#x27;t need to do that, so leave it at 0.</span><br>                <span class="hljs-comment">//   Target format of the pixels. This is the format OpenGL will store our image with.</span><br>                <span class="hljs-comment">//   Width of the image</span><br>                <span class="hljs-comment">//   Height of the image.</span><br>                <span class="hljs-comment">//   Border of the image. This must always be 0; it&#x27;s a legacy parameter that Khronos never got rid of.</span><br>                <span class="hljs-comment">//   The format of the pixels, explained above. Since we loaded the pixels as RGBA earlier, we need to use PixelFormat.Rgba.</span><br>                <span class="hljs-comment">//   Data type of the pixels.</span><br>                <span class="hljs-comment">//   And finally, the actual pixels.</span><br>                GL.TexImage2D(TextureTarget.Texture2D, <span class="hljs-number">0</span>, PixelInternalFormat.Rgba, image.Width, image.Height, <span class="hljs-number">0</span>, PixelFormat.Rgba, PixelType.UnsignedByte, image.Data);<br>            &#125;<br><br>            <span class="hljs-comment">// Now that our texture is loaded, we can set a few settings to affect how the image appears on rendering.</span><br><br>            <span class="hljs-comment">// First, we set the min and mag filter. These are used for when the texture is scaled down and up, respectively.</span><br>            <span class="hljs-comment">// Here, we use Linear for both. This means that OpenGL will try to blend pixels, meaning that textures scaled too far will look blurred.</span><br>            <span class="hljs-comment">// You could also use (amongst other options) Nearest, which just grabs the nearest pixel, which makes the texture look pixelated if scaled too far.</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The default settings for both of these are LinearMipmap. If you leave these as default but don&#x27;t generate mipmaps,</span><br>            <span class="hljs-comment">// your image will fail to render at all (usually resulting in pure black instead).</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.Linear);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br><br>            <span class="hljs-comment">// Now, set the wrapping mode. S is for the X axis, and T is for the Y axis.</span><br>            <span class="hljs-comment">// We set this to Repeat so that textures will repeat when wrapped. Not demonstrated here since the texture coordinates exactly match</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br><br>            <span class="hljs-comment">// Next, generate mipmaps.</span><br>            <span class="hljs-comment">// Mipmaps are smaller copies of the texture, scaled down. Each mipmap level is half the size of the previous one</span><br>            <span class="hljs-comment">// Generated mipmaps go all the way down to just one pixel.</span><br>            <span class="hljs-comment">// OpenGL will automatically switch between mipmaps when an object gets sufficiently far away.</span><br>            <span class="hljs-comment">// This prevents moiré effects, as well as saving on texture bandwidth.</span><br>            <span class="hljs-comment">// Here you can see and read about the morié effect https://en.wikipedia.org/wiki/Moir%C3%A9_pattern</span><br>            <span class="hljs-comment">// Here is an example of mips in action https://en.wikipedia.org/wiki/File:Mipmap_Aliasing_Comparison.png</span><br>            GL.GenerateMipmap(GenerateMipmapTarget.Texture2D);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Texture(handle);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Texture</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> glHandle</span>)</span><br>        &#123;<br>            Handle = glHandle;<br>        &#125;<br><br>        <span class="hljs-comment">// Activate texture</span><br>        <span class="hljs-comment">// Multiple textures can be bound, if your shader needs more than just one.</span><br>        <span class="hljs-comment">// If you want to do that, use GL.ActiveTexture to set which slot GL.BindTexture binds to.</span><br>        <span class="hljs-comment">// The OpenGL standard requires that there be at least 16, but there can be more depending on your graphics card.</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>(<span class="hljs-params">TextureUnit unit</span>)</span><br>        &#123;<br>            GL.ActiveTexture(unit);<br>            GL.BindTexture(TextureTarget.Texture2D, Handle);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.cs">Shader.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shader</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Handle &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shader</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> vertexPath, <span class="hljs-built_in">string</span> fragmentPath</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">string</span> VertexShaderSource = File.ReadAllText(vertexPath);<br>            <span class="hljs-built_in">int</span> vertexShader = GL.CreateShader(ShaderType.VertexShader);<br>            GL.ShaderSource(vertexShader, VertexShaderSource);<br>            GL.CompileShader(vertexShader);<br><br><br>            <span class="hljs-built_in">string</span> FragmentShaderSource = File.ReadAllText(fragmentPath);<br>            <span class="hljs-built_in">int</span> fragmentShader = GL.CreateShader(ShaderType.FragmentShader);<br>            GL.ShaderSource(fragmentShader, FragmentShaderSource);<br>            GL.CompileShader(fragmentShader);<br><br>            <span class="hljs-comment">// Create shader program and link shaders</span><br>            Handle = GL.CreateProgram();<br>            GL.AttachShader(Handle, vertexShader);<br>            GL.AttachShader(Handle, fragmentShader);<br>            GL.LinkProgram(Handle);<br><br>            <span class="hljs-comment">// Clean up individual shaders</span><br>            GL.DetachShader(Handle, vertexShader);<br>            GL.DetachShader(Handle, fragmentShader);<br>            GL.DeleteShader(fragmentShader);<br>            GL.DeleteShader(vertexShader);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span><br>        &#123;<br>            GL.UseProgram(Handle);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.vert">shader.vert</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoord;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>    texCoord = aTexCoord;<br><br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.frag">shader.frag</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outputColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture0;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    outputColor = <span class="hljs-built_in">texture</span>(texture0, texCoord);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多纹理和纹理单元">多纹理和纹理单元</h2><p>你可能想知道为什么<code>sampler2D</code>变量是一个<code>uniform</code>，如果我们甚至没有使用<code>GL.Uniform*</code>为它分配一些值。使用<code>GL.Uniform1</code>，我们实际上可以为纹理采样器分配一个位置值，这样我们就可以在片段着色器中一次设置多个纹理。纹理的位置更常见地称为纹理单元。纹理的默认单元是0，这是默认的活动纹理单元，因此我们在上一节中没有分配位置；请注意，并非所有的图形驱动程序都会分配默认的纹理单元，因此上一节可能对您没有渲染。</p><p>纹理单元的主要目的是允许我们在着色器中使用多于一个纹理。通过为采样器分配纹理单元，我们可以一次绑定多个纹理，只要我们先激活相应的纹理单元。就像GL.BindTexture一样，我们可以使用GL.ActiveTexture激活纹理单元，传入我们想要使用的纹理单元：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.ActiveTexture(TextureUnit.Texture0); <span class="hljs-comment">// 绑定纹理之前先激活纹理单元</span><br>GL.BindTexture(TextureTarget.Texture2D, texture);<br></code></pre></td></tr></table></figure><p>激活了一个纹理单元之后，后续的GL.BindTexture调用将把纹理绑定到当前活动的纹理单元。纹理单元Texture0总是默认激活的，所以当使用GL.BindTexture时，我们不需要激活任何纹理单元。</p><p>OpenGL应该至少有16个纹理单元供您使用，您可以使用Texture0到Texture15来激活它们。</p><p>然而，我们仍然需要编辑片段着色器以接受另一个采样器。现在应该相对简单：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-comment">/* ... */</span><br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture1;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture2;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = <span class="hljs-built_in">mix</span>(<span class="hljs-built_in">texture</span>(texture1, TexCoord), <span class="hljs-built_in">texture</span>(texture2, TexCoord), <span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终的输出颜色现在是两个纹理查找的组合。GLSL的内置mix函数接受两个值作为输入，并根据其第三个参数进行线性插值。如果第三个值是0.0，它将返回第一个输入；如果是1.0，它将返回第二个输入值。值为0.2将返回第一个输入颜色的80%和第二个输入颜色的20%，从而得到两个纹理的混合色。</p><p>现在我们想要加载和创建另一个纹理；您现在应该熟悉了这些步骤。确保创建另一个纹理对象，加载图像并使用GL.TexImage2D生成最终的纹理。对于第二个纹理，我们将使用一个学习OpenGL时你的面部表情的图像：</p><p>要使用第二个纹理（和第一个纹理），我们需要稍微更改渲染过程，将两个纹理绑定到相应的纹理单元。首先，转到Texture.cs，并像这样修改Use函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>(<span class="hljs-params">TextureUnit unit = TextureUnit.Texture0</span>)</span><br>&#123;<br>    GL.ActiveTexture(unit);<br>    GL.BindTexture(TextureTarget.Texture2D, Handle);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在OnLoad中添加一个新属性来保存新纹理，并加载它。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Texture texture2;<br><br>...<br><br>texture2 = <span class="hljs-keyword">new</span> Texture(<span class="hljs-string">&quot;awesomeface.png&quot;</span>);<br></code></pre></td></tr></table></figure><p>新纹理已经准备好了，现在我们必须设置着色器uniform变量。在Shader.cs中添加以下函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetInt</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> location = GL.GetUniformLocation(Handle, name);<br><br>    GL.Uniform1(location, <span class="hljs-keyword">value</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数简化了设置着色器uniform变量的过程。采样器在CPU中表示为整数；将uniform设置为整数，它将检查纹理单元。</p><p>在OnLoad中创建纹理后，立即添加以下行：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">shader.SetInt(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">0</span>);<br>shader.SetInt(<span class="hljs-string">&quot;texture2&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这将uniform纹理1设置为使用纹理单元0中的内容，并将纹理2设置为使用纹理单元1中的内容。</p><p>最后，在OnRenderFrame中进行如下修改：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.Clear(ClearBufferMask.ColorBufferBit);<br>GL.BindVertexArray(VertexArrayObject);<br><br>texture.Use(TextureUnit.Texture0);<br>texture2.Use(TextureUnit.Texture1);<br>shader.Use();<br><br>GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br><br>Context.SwapBuffers();<br><br><span class="hljs-keyword">base</span>.OnRenderFrame(e);<br></code></pre></td></tr></table></figure><p>绑定了两个纹理并且着色器正确设置后，您现在应该看到以下结果：</p><h3 id="完整代码-1">完整代码</h3><h4 id="form1.cs-1">Form1.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Diagnostics;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> OpenTK.WinForms;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Windows.Forms.VisualStyles.VisualStyleElement;<br><span class="hljs-keyword">using</span> OpenTK.Mathematics;<br><span class="hljs-keyword">using</span> OpenTK.Windowing.GraphicsLibraryFramework;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br><br>        <span class="hljs-built_in">float</span>[] vertices =<br>        &#123;<br>            <span class="hljs-comment">//Position          Texture coordinates</span><br>             <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-comment">// 右上</span><br>             <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 右下</span><br>            <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下</span><br>            <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>  <span class="hljs-comment">// 左上</span><br>        &#125;;<br>        <span class="hljs-built_in">uint</span>[] indices = &#123;  <span class="hljs-comment">// note that we start from 0!</span><br>            <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,   <span class="hljs-comment">// first triangle</span><br>            <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    <span class="hljs-comment">// second triangle</span><br>        &#125;;<br>        <span class="hljs-built_in">int</span> VertexBufferObject;<br>        <span class="hljs-built_in">int</span> vertexArrayObject;<br>        <span class="hljs-built_in">int</span> ElementBufferObject;<br>        <span class="hljs-keyword">private</span> Texture _texture;<br>        <span class="hljs-keyword">private</span> Texture _texture2;<br>        Shader shader;<br>        Stopwatch timer;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Form1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.ClearColor(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>            <br><br>            <span class="hljs-comment">// Create and bind VAO</span><br>            vertexArrayObject = GL.GenVertexArray();<br>            GL.BindVertexArray(vertexArrayObject);<br><br>            <span class="hljs-comment">// Create and bind VBO</span><br>            VertexBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>            <span class="hljs-comment">// Provide vertex data to the VBO</span><br>            GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><br>            ElementBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ElementArrayBuffer, ElementBufferObject);<br>            GL.BufferData(BufferTarget.ElementArrayBuffer, indices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">uint</span>), indices, BufferUsageHint.StaticDraw);<br><br>            shader = <span class="hljs-keyword">new</span> Shader(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.vert&quot;</span>, <span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.frag&quot;</span>);<br>            timer = <span class="hljs-keyword">new</span> Stopwatch();<br>            shader.Use();<br><br>            <span class="hljs-comment">// Specify the vertex attribute pointers</span><br>            GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>            GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-built_in">int</span> texCoordLocation = GL.GetAttribLocation(shader.Handle, <span class="hljs-string">&quot;aTexCoord&quot;</span>);<br>            GL.EnableVertexAttribArray(texCoordLocation);<br>            GL.VertexAttribPointer(texCoordLocation, <span class="hljs-number">2</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br><br>            _texture = Texture.LoadFromFile(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/Resources/container.png&quot;</span>);<br>            _texture.Use(TextureUnit.Texture0);<br><br>            _texture2 = Texture.LoadFromFile(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/Resources/awesomeface.png&quot;</span>);<br>            _texture2.Use(TextureUnit.Texture1);<br><br>            shader.SetInt(<span class="hljs-string">&quot;texture0&quot;</span>, <span class="hljs-number">0</span>);<br>            shader.SetInt(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Paint</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, PaintEventArgs e</span>)</span><br>        &#123;<br>            GL.Clear(ClearBufferMask.ColorBufferBit);<br><br>            GL.BindVertexArray(vertexArrayObject);<br><br>            _texture.Use(TextureUnit.Texture0);<br>            _texture2.Use(TextureUnit.Texture1);<br>            shader.Use();<br><br>            GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br><br>            glControl1.SwapBuffers();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_SizeChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> deltaTime</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//var input = KeyboardState;</span><br><br>            <span class="hljs-comment">//if (input.IsKeyDown(Keys.Escape))</span><br>            <span class="hljs-comment">//&#123;</span><br>            <span class="hljs-comment">//    Close();</span><br>            <span class="hljs-comment">//&#125;</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">timer1_Tick</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">float</span> deltaTime = (<span class="hljs-built_in">float</span>)timer.Elapsed.TotalSeconds;<br>            timer.Restart();<br><br>            OnUpdate(deltaTime);<br>            <br>            glControl1.Invalidate();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="texture.cs-1">Texture.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> System.Drawing;<br><span class="hljs-keyword">using</span> System.Drawing.Imaging;<br><span class="hljs-keyword">using</span> PixelFormat = OpenTK.Graphics.OpenGL.PixelFormat;<br><span class="hljs-keyword">using</span> StbImageSharp;<br><span class="hljs-keyword">using</span> System.IO;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Texture</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Handle;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture <span class="hljs-title">LoadFromFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// Generate handle</span><br>            <span class="hljs-built_in">int</span> handle = GL.GenTexture();<br><br>            <span class="hljs-comment">// Bind the handle</span><br>            GL.ActiveTexture(TextureUnit.Texture0);<br>            GL.BindTexture(TextureTarget.Texture2D, handle);<br><br>            <span class="hljs-comment">// For this example, we&#x27;re going to use .NET&#x27;s built-in System.Drawing library to load textures.</span><br><br>            <span class="hljs-comment">// OpenGL has it&#x27;s texture origin in the lower left corner instead of the top left corner,</span><br>            <span class="hljs-comment">// so we tell StbImageSharp to flip the image when loading.</span><br>            StbImage.stbi_set_flip_vertically_on_load(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// Here we open a stream to the file and pass it to StbImageSharp to load.</span><br>            <span class="hljs-keyword">using</span> (Stream stream = File.OpenRead(path))<br>            &#123;<br>                ImageResult image = ImageResult.FromStream(stream, ColorComponents.RedGreenBlueAlpha);<br><br>                <span class="hljs-comment">// Now that our pixels are prepared, it&#x27;s time to generate a texture. We do this with GL.TexImage2D.</span><br>                <span class="hljs-comment">// Arguments:</span><br>                <span class="hljs-comment">//   The type of texture we&#x27;re generating. There are various different types of textures, but the only one we need right now is Texture2D.</span><br>                <span class="hljs-comment">//   Level of detail. We can use this to start from a smaller mipmap (if we want), but we don&#x27;t need to do that, so leave it at 0.</span><br>                <span class="hljs-comment">//   Target format of the pixels. This is the format OpenGL will store our image with.</span><br>                <span class="hljs-comment">//   Width of the image</span><br>                <span class="hljs-comment">//   Height of the image.</span><br>                <span class="hljs-comment">//   Border of the image. This must always be 0; it&#x27;s a legacy parameter that Khronos never got rid of.</span><br>                <span class="hljs-comment">//   The format of the pixels, explained above. Since we loaded the pixels as RGBA earlier, we need to use PixelFormat.Rgba.</span><br>                <span class="hljs-comment">//   Data type of the pixels.</span><br>                <span class="hljs-comment">//   And finally, the actual pixels.</span><br>                GL.TexImage2D(TextureTarget.Texture2D, <span class="hljs-number">0</span>, PixelInternalFormat.Rgba, image.Width, image.Height, <span class="hljs-number">0</span>, PixelFormat.Rgba, PixelType.UnsignedByte, image.Data);<br>            &#125;<br><br>            <span class="hljs-comment">// Now that our texture is loaded, we can set a few settings to affect how the image appears on rendering.</span><br><br>            <span class="hljs-comment">// First, we set the min and mag filter. These are used for when the texture is scaled down and up, respectively.</span><br>            <span class="hljs-comment">// Here, we use Linear for both. This means that OpenGL will try to blend pixels, meaning that textures scaled too far will look blurred.</span><br>            <span class="hljs-comment">// You could also use (amongst other options) Nearest, which just grabs the nearest pixel, which makes the texture look pixelated if scaled too far.</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The default settings for both of these are LinearMipmap. If you leave these as default but don&#x27;t generate mipmaps,</span><br>            <span class="hljs-comment">// your image will fail to render at all (usually resulting in pure black instead).</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.Linear);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br><br>            <span class="hljs-comment">// Now, set the wrapping mode. S is for the X axis, and T is for the Y axis.</span><br>            <span class="hljs-comment">// We set this to Repeat so that textures will repeat when wrapped. Not demonstrated here since the texture coordinates exactly match</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br><br>            <span class="hljs-comment">// Next, generate mipmaps.</span><br>            <span class="hljs-comment">// Mipmaps are smaller copies of the texture, scaled down. Each mipmap level is half the size of the previous one</span><br>            <span class="hljs-comment">// Generated mipmaps go all the way down to just one pixel.</span><br>            <span class="hljs-comment">// OpenGL will automatically switch between mipmaps when an object gets sufficiently far away.</span><br>            <span class="hljs-comment">// This prevents moiré effects, as well as saving on texture bandwidth.</span><br>            <span class="hljs-comment">// Here you can see and read about the morié effect https://en.wikipedia.org/wiki/Moir%C3%A9_pattern</span><br>            <span class="hljs-comment">// Here is an example of mips in action https://en.wikipedia.org/wiki/File:Mipmap_Aliasing_Comparison.png</span><br>            GL.GenerateMipmap(GenerateMipmapTarget.Texture2D);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Texture(handle);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Texture</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> glHandle</span>)</span><br>        &#123;<br>            Handle = glHandle;<br>        &#125;<br><br>        <span class="hljs-comment">// Activate texture</span><br>        <span class="hljs-comment">// Multiple textures can be bound, if your shader needs more than just one.</span><br>        <span class="hljs-comment">// If you want to do that, use GL.ActiveTexture to set which slot GL.BindTexture binds to.</span><br>        <span class="hljs-comment">// The OpenGL standard requires that there be at least 16, but there can be more depending on your graphics card.</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>(<span class="hljs-params">TextureUnit unit</span>)</span><br>        &#123;<br>            GL.ActiveTexture(unit);<br>            GL.BindTexture(TextureTarget.Texture2D, Handle);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.cs-1">Shader.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shader</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Handle &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; _uniformLocations;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shader</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> vertexPath, <span class="hljs-built_in">string</span> fragmentPath</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">string</span> VertexShaderSource = File.ReadAllText(vertexPath);<br>            <span class="hljs-built_in">int</span> vertexShader = GL.CreateShader(ShaderType.VertexShader);<br>            GL.ShaderSource(vertexShader, VertexShaderSource);<br>            GL.CompileShader(vertexShader);<br><br><br>            <span class="hljs-built_in">string</span> FragmentShaderSource = File.ReadAllText(fragmentPath);<br>            <span class="hljs-built_in">int</span> fragmentShader = GL.CreateShader(ShaderType.FragmentShader);<br>            GL.ShaderSource(fragmentShader, FragmentShaderSource);<br>            GL.CompileShader(fragmentShader);<br><br>            <span class="hljs-comment">// Create shader program and link shaders</span><br>            Handle = GL.CreateProgram();<br>            GL.AttachShader(Handle, vertexShader);<br>            GL.AttachShader(Handle, fragmentShader);<br>            GL.LinkProgram(Handle);<br><br>            <span class="hljs-comment">// Clean up individual shaders</span><br>            GL.DetachShader(Handle, vertexShader);<br>            GL.DetachShader(Handle, fragmentShader);<br>            GL.DeleteShader(fragmentShader);<br>            GL.DeleteShader(vertexShader);<br><br>            GL.GetProgram(Handle, GetProgramParameterName.ActiveUniforms, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> numberOfUniforms);<br>            _uniformLocations = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;();<br><br>            <span class="hljs-comment">// Loop over all the uniforms,</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; numberOfUniforms; i++)<br>            &#123;<br>                <span class="hljs-comment">// get the name of this uniform,</span><br>                <span class="hljs-keyword">var</span> key = GL.GetActiveUniform(Handle, i, <span class="hljs-keyword">out</span> _, <span class="hljs-keyword">out</span> _);<br><br>                <span class="hljs-comment">// get the location,</span><br>                <span class="hljs-keyword">var</span> location = GL.GetUniformLocation(Handle, key);<br><br>                <span class="hljs-comment">// and then add it to the dictionary.</span><br>                _uniformLocations.Add(key, location);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span><br>        &#123;<br>            GL.UseProgram(Handle);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetInt</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> data</span>)</span><br>        &#123;<br>            GL.UseProgram(Handle);<br>            GL.Uniform1(_uniformLocations[name], data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.vert-1">shader.vert</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoord;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>    texCoord = aTexCoord;<br><br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.frag-1">shader.frag</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outputColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture0;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture1;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    outputColor = <span class="hljs-built_in">mix</span>(<span class="hljs-built_in">texture</span>(texture0, texCoord), <span class="hljs-built_in">texture</span>(texture1, texCoord), <span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变换">变换</h2><p>我们已经知道如何创建对象，给它们上色和/或使用纹理给它们赋予详细的外观，但它们仍然不那么有趣，因为它们都是静态对象。我们可以尝试通过改变它们的顶点并重新配置它们的缓冲区来使它们移动，但这很麻烦，而且会消耗大量的处理能力。有更好的方法来转换对象，那就是使用（多个）矩阵对象。</p><p>矩阵是非常强大的数学构造，起初似乎令人望而生畏，但一旦你逐渐习惯了它们，它们将证明极其有用。当讨论矩阵时，我们将不得不对一些数学进行简要的探讨，对于更倾向于数学的读者，我将提供进一步阅读的额外资源。</p><p>然而，要完全理解变换，我们首先必须在讨论矩阵之前深入了解一些向量。本章的重点是为您提供我们以后需要的基本数学背景。如果这些主题很难，尽量理解它们，以后需要时随时回到本页面复习概念。</p><p>对上一节的图片进行旋转和缩放</p><p>首先引入<code>using OpenTK.Mathematics;</code></p><p>glControl1_Paint:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> transform = Matrix4.Identity;<br>transform = transform * Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(<span class="hljs-number">90.0f</span>));<br>transform = transform * Matrix4.CreateScale(<span class="hljs-number">1.1f</span>);<br>transform = transform * Matrix4.CreateTranslation(<span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>);<br></code></pre></td></tr></table></figure><p>这段代码是使用OpenGL数学库进行矩阵变换的示例。让我解释一下每一步的含义：</p><ol type="1"><li><p><code>Matrix4.Identity</code>:这是一个单位矩阵，表示没有任何变换。它是一个4x4的矩阵，对角线上的元素为1，其余为0。</p></li><li><p><code>Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(90.0f))</code>:这一行代码创建了一个绕着Z轴旋转90度的旋转矩阵。<code>MathHelper.DegreesToRadians()</code>是一个函数，用于将角度转换为弧度，因为大多数数学库使用弧度来表示角度。</p></li><li><p><code>Matrix4.CreateScale(1.1f)</code>:这一行代码创建了一个缩放矩阵，将对象沿着X、Y和Z方向各放大1.1倍。这意味着对象在每个方向上都会增加10%的大小。</p></li><li><p><code>Matrix4.CreateTranslation(0.1f, 0.1f, 0.1f)</code>:最后一行代码创建了一个平移矩阵，将对象沿着X、Y和Z方向各移动0.1个单位。</p></li></ol><p>在这些操作之后，<code>transform</code>矩阵将包含所有这些变换的组合。如果将这个矩阵应用到对象的顶点上，对象就会按照这些变换进行旋转、缩放和平移。</p><p>剩下看官方代码</p><h2 id="坐标系">坐标系</h2><p>在上节中，我们学习了如何利用矩阵通过转换矩阵来转换所有顶点。OpenGL希望在每次顶点着色器运行后，我们希望变得可见的所有顶点都位于归一化设备坐标中。也就是说，每个顶点的x、y和z坐标应该在-1.0和1.0之间；超出此范围的坐标将不可见。我们通常做的是在一个我们自己配置的范围内指定坐标，并在顶点着色器中将这些坐标转换为NDC。然后将这些NDC坐标传递给光栅化器，以将它们转换为屏幕上的2D坐标/像素。</p><p>将坐标转换为NDC，然后转换为屏幕坐标通常是逐步完成的，我们将一个对象的顶点转换为几个坐标系统，最后将它们转换为屏幕坐标。将它们转换为几个中间坐标系统的优点是，某些操作/计算在特定坐标系统中更容易，这很快就会变得明显。对我们来说，共有5种不同的重要坐标系统：</p><ol type="1"><li>局部空间（或对象空间）</li><li>世界空间</li><li>观察空间（或眼睛空间）</li><li>裁剪空间</li><li>屏幕空间</li></ol><p>在最终成为片段之前，这些坐标系统中的每一个都是顶点将被转换为的不同状态。</p><p>您现在可能对空间或坐标系统到底是什么感到困惑，所以我们将以更易于理解的方式解释它们，通过展示整体图像和每个特定空间实际执行的操作。</p><h3 id="全局视角">全局视角</h3><p>为了将一个坐标空间中的坐标转换到下一个坐标空间中，我们将使用几个变换矩阵，其中最重要的是模型（Model）、视图（View）和投影（Projection）矩阵。我们的顶点坐标首先从局部空间开始作为局部坐标，然后进一步转换为世界坐标、观察坐标、裁剪坐标，最终以屏幕坐标结束。下图展示了这个过程，并显示了每个转换的作用：</p><p><img src="8-coordinate_systems.png" /></p><ol type="1"><li><p>局部坐标是相对于对象的局部原点的坐标；它们是对象起始的坐标。</p></li><li><p>接下来的步骤是将局部坐标转换为世界空间坐标，这些坐标是相对于更大的世界的坐标。这些坐标是相对于世界的全局原点的，与许多其他对象一起放置在相对于世界原点的位置。</p></li><li><p>接下来，我们将世界坐标转换为视图空间坐标，以使每个坐标都是从摄像机或观察者的视角看到的。</p></li><li><p>当坐标处于视图空间时，我们希望将它们投影到裁剪坐标中。裁剪坐标被处理为-1.0和1.0的范围，并确定哪些顶点将出现在屏幕上。</p></li><li><p>最后，我们将裁剪坐标转换为屏幕坐标，这个过程称为视口变换，它将坐标从-1.0和1.0转换为由GL.Viewport定义的坐标范围。然后，得到的坐标被发送到光栅化器，将它们转换为片段。</p></li></ol><p>你可能已经对每个单独的空间有了一些了解。我们将顶点转换为所有这些不同的空间的原因是，某些操作在特定坐标系统中更有意义或更容易使用。例如，当修改对象时，在局部空间中进行修改是最合理的，而在世界坐标系中计算与其他对象位置相关的某些操作是最合理的，依此类推。如果我们愿意，我们可以定义一个从局部空间到裁剪空间的转换矩阵，但这样会给我们留下更少的灵活性。</p><p>我们将在下面更详细地讨论每个坐标系。</p><h4 id="局部空间">局部空间</h4><p>局部空间是与你的对象相关的坐标空间，即你的对象起始的地方。想象一下，你在建模软件（如Blender）中创建了一个立方体。你的立方体的原点可能在（0,0,0），即使你的立方体最终可能在你的最终应用程序中位于不同的位置。你创建的所有模型的初始位置可能都是（0,0,0）。因此，你模型的所有顶点都在局部空间中：它们都是相对于你的对象的局部坐标。</p><p>我们使用的容器的顶点被指定为介于-0.5和0.5之间的坐标，以0.0作为原点。这些是局部坐标。</p><h4 id="世界空间">世界空间</h4><p>如果我们直接将所有的对象导入应用程序中，它们可能都堆叠在世界原点（0,0,0）附近，这不是我们想要的。我们希望为每个对象定义一个位置，将它们放置在一个更大的世界中。世界空间中的坐标正是它们听起来的样子：所有顶点相对于（游戏）世界的坐标。这是一个坐标空间，你希望将你的对象转换到这个空间中，以使它们分散在各个地方（最好以一种真实的方式）。你的对象的坐标是从局部空间转换到世界空间的；这是通过模型矩阵完成的。</p><p>模型矩阵是一个转换矩阵，可以平移、缩放和/或旋转你的对象，将其放置在世界中的一个位置/方向上。可以将其想象为通过缩小房屋（在局部空间中有点太大了）、将其平移到郊区城镇并在y轴上稍微向左旋转一点，以便它与邻近的房屋整齐地配合。你也可以将前面教程中的矩阵想象成一种模型矩阵，用于将容器的局部坐标转换到场景/世界中的某个不同位置。</p><h4 id="视图空间">视图空间</h4><p>视图空间通常被称为OpenGL的摄像机（有时也称为相机空间或眼睛空间）。视图空间是将世界空间坐标转换为位于用户视图前方的坐标的结果。因此，视图空间就是从摄像机视角看到的空间。通常通过一系列平移和旋转来实现视图空间的转换，以便将某些物体转换到摄像机前面。这些组合的变换通常存储在一个视图矩阵中，该矩阵将世界坐标转换为视图空间。在下一个教程中，我们将详细讨论如何创建这样一个视图矩阵来模拟一个摄像机。</p><h4 id="剪裁空间">剪裁空间</h4><p>在每次顶点着色器运行结束时，OpenGL期望坐标位于特定范围内，任何超出此范围的坐标都将被裁剪。被裁剪的坐标将被丢弃，因此剩下的坐标将成为在屏幕上可见的片段。这也是裁剪空间得名的原因。</p><p>由于将所有可见坐标指定为范围-1.0和1.0并不直观，我们会指定我们自己的坐标集并将其转换回NDC，因为OpenGL期望它们是NDC。</p><p>为了将顶点坐标从视图空间转换为裁剪空间，我们定义了一个称为投影矩阵的矩阵，该矩阵指定了每个维度中的坐标范围，例如-1000和1000。然后，投影矩阵将在指定范围内的坐标转换为规范化设备坐标（-1.0，1.0）。所有超出此范围的坐标将不会映射到-1.0和1.0之间，因此将被裁剪。对于我们在投影矩阵中指定的范围，例如坐标（1250，500，750）将不可见，因为x坐标超出了范围，因此会转换为NDC中大于1.0的坐标，因此被裁剪。</p><blockquote><p>请注意，如果一个图元的一部分（例如一个三角形）超出了裁剪体积，OpenGL将重构该三角形为一个或多个三角形，以适应裁剪范围内。</p></blockquote><p>投影矩阵创建的视图框称为视锥体，位于该视锥体内的每个坐标将出现在用户的屏幕上。将坐标从指定范围转换为NDC并映射到2D视图空间坐标的整个过程称为投影，因为投影矩阵将3D坐标投影到易于映射到2D规范化设备坐标的坐标。</p><p>一旦所有顶点转换为裁剪空间，将执行最终操作，称为透视除法，其中我们将位置向量的x、y和z分量除以向量的齐次w分量；透视除法是将4D裁剪空间坐标转换为3D规范化设备坐标。这一步在每次顶点着色器运行结束时自动执行。</p><p>在这个阶段之后，将结果坐标映射到屏幕坐标（使用glViewport的设置），并转换为片段。</p><p>将视图坐标转换为裁剪坐标的投影矩阵可以采用两种不同形式，每种形式定义了自己独特的视锥体。我们可以创建正交投影矩阵或透视投影矩阵。</p><h3 id="正交投影">正交投影</h3><p>正交投影矩阵定义了一个立方体般的视锥体，它定义了剪裁空间，其中每个顶点在此盒子外部都会被裁剪。创建正交投影矩阵时，我们指定可见视锥体的宽度、高度和长度。在使用正交投影矩阵将坐标转换为裁剪空间后，所有落入此视锥体内部的坐标都不会被裁剪。视锥体看起来有点像一个容器：</p><p><img src="8-orthographic_frustum.png" /></p><p>视锥体定义了可见坐标，并由宽度、高度和近平面和远平面来指定。任何位于近平面前面的坐标都会被裁剪，对于位于远平面后面的坐标也是一样。正交投影视锥体直接将视锥体内的所有坐标映射到规范化设备坐标，因为每个向量的w分量保持不变；如果w分量等于1.0，则透视除法不会改变坐标。</p><p>要创建一个正交投影矩阵，我们使用<code>OpenTK</code>的<code>CreateOrthographicOffCenter</code>方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4.CreateOrthographicOffCenter(<span class="hljs-number">0.0f</span>, <span class="hljs-number">800.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">600.0f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure><p>前两个参数指定了视锥体的左边界和右边界，第三和第四个参数指定了视锥体的底部和顶部。通过这4个点，我们定义了近平面和远平面的大小，然后第5和第6个参数定义了近平面和远平面之间的距离。这个特定的投影矩阵将所有在这些x、y和z范围值之间的坐标转换为规范化设备坐标。</p><p>正交投影矩阵直接将坐标映射到您屏幕的2D平面，但实际上，直接投影会产生不真实的结果，因为投影不考虑透视。这就是透视投影矩阵为我们修正的内容。</p><h3 id="透视投影">透视投影</h3><p>如果你曾经欣赏过现实生活中的图形，你会注意到远处的物体看起来要小得多。这种奇怪的效果是我们所谓的透视。透视在望着无限公路或铁路的尽头时尤为明显，就像下面的图片所示：</p><p><img src="8-perspective.png" /></p><p>正如你所看到的，由于透视，线条在远处似乎重合。透视投影正是试图模仿这种效果，它使用透视投影矩阵来实现。投影矩阵将给定的视锥体范围映射到裁剪空间，但也以一种方式操纵每个顶点坐标的w值，使得离观察者越远的顶点坐标，其w分量越高。一旦坐标被转换到裁剪空间，它们就位于-w到w的范围内（范围之外的任何坐标都会被裁剪）。OpenGL要求可见坐标必须落在-1.0到1.0的范围内，作为最终顶点着色器的输出，因此一旦坐标位于裁剪空间中，透视除法就会应用到裁剪空间坐标上：<span class="math display">\[out=\begin{pmatrix}x/w\\y/w\\z/w\end{pmatrix}\]</span>每个顶点坐标的每个分量都被它的w分量除以，使得顶点距离观察者越远，顶点坐标就越小。这也是为什么w分量很重要的另一个原因，因为它帮助我们进行透视投影。得到的坐标随后处于规范化设备空间中。如果你有兴趣弄清楚正交投影和透视投影矩阵是如何实际计算的（并且不怕数学），我可以推荐这篇由Songho撰写的优秀文章。</p><p>在OpenTK中可以使用以下方式创建透视投影矩阵：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(<span class="hljs-number">45.0f</span>), (<span class="hljs-built_in">float</span>)width / (<span class="hljs-built_in">float</span>)height, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure><p>这段代码创建了一个透视投影矩阵。它通过参数指定了一个大的视锥体，定义了可见空间，视锥体之外的任何东西都不会出现在裁剪空间中，因此会被裁剪掉。透视视锥体可以想象成一个非均匀形状的盒子，其中每个在这个盒子内部的坐标都会映射到裁剪空间中的一个点。下面是一个透视视锥体的图像：<code>Matrix4.CreatePerspectiveFieldOfView</code></p><p><img src="8-perspective_frustum.png" /></p><p>第一个参数定义了fovy值，代表视场角（y代表垂直轴，因此是垂直视场角），并设置了视景体的大小。为了获得逼真的视图，通常将其设置为45度，但如果想要更像《毁灭战士》（Doom）风格的结果，可以将其设置为更高的值。第二个参数设置了纵横比，通过将视口的宽度除以其高度来计算。第三个和第四个参数设置了视锥体的近平面和远平面。通常将近距离设置为0.1f，远距离设置为100.0f。在视锥体的近平面和远平面之间以及内部的所有顶点都将被渲染。</p><blockquote><p>当透视矩阵的近平面值设置得稍微过高（例如10.0f）时，OpenGL会裁剪所有靠近相机的坐标（在0.0f和10.0f之间），这在视频游戏中会产生一个熟悉的视觉效果，即如果你靠近某些物体，你可以看穿它们。</p></blockquote><p>在使用正交投影时，每个顶点坐标都直接映射到裁剪空间，没有任何复杂的透视除法（实际上仍然进行了透视除法，但w分量不受影响（保持为1），因此没有效果）。由于正交投影不使用透视投影，因此远处的物体看起来不会变小，这会产生一种奇怪的视觉效果。因此，正交投影主要用于2D渲染以及一些建筑或工程应用中，在这些应用中我们不希望顶点受到透视的扭曲。用于3D建模的应用程序（如Blender）有时会使用正交投影进行建模，因为它更准确地描绘了每个对象的尺寸。下面你会看到Blender中两种投影方法的比较：</p><p><img src="8-perspective_orthographic.png" /></p><p>你可以看到，使用透视投影时，远处的顶点看起来要小得多，而在正交投影中，每个顶点与用户的距离相同。</p><h3 id="结合起来">结合起来</h3><p>我们为前面提到的每个步骤创建一个变换矩阵：模型、视图和投影矩阵。然后，顶点坐标被转换为裁剪坐标，如下所示：<span class="math display">\[V_{clip}=M_{projection}\cdot M_{view}\cdot M_{model}\cdot V_{local}\]</span>请注意，矩阵乘法的顺序是相反的（记住我们需要从右向左阅读矩阵乘法）。然后，将得到的顶点分配给顶点着色器中的gl_Position，然后OpenGL将自动执行透视除法和裁剪。</p><blockquote><p>然后呢？顶点着色器的输出要求坐标在裁剪空间中，这就是我们刚刚通过变换矩阵完成的。OpenGL然后对裁剪空间坐标执行透视除法，将它们转换为标准化设备坐标。然后，OpenGL使用GL.Viewport的参数将标准化设备坐标映射到屏幕坐标，在这里，每个坐标对应屏幕上的一个点（在我们的情况下是800x600屏幕）。这个过程被称为视口变换。</p></blockquote><p>这是一个难以理解的话题，所以如果你对每个空间的具体用途仍然不太清楚，也不必担心。在接下来的教程中，我们将看到如何实际运用这些坐标空间，并且会有足够的示例跟随在这些教程中。</p><h3 id="前往3d">前往3D</h3><p>现在我们知道如何将 3D 坐标转换为 2D坐标，我们可以开始展示我们的对象作为真正的 3D对象，而不是到目前为止我们一直展示的平淡的 2D 平面。</p><p>为了开始绘制 3D图形，我们首先创建一个模型矩阵。模型矩阵包括我们想要应用的平移、缩放和/或旋转，以将所有对象的顶点转换为全局世界空间。让我们通过绕x 轴旋转一下我们的平面，使其看起来好像躺在地板上。模型矩阵如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4 model = Matrix4.CreateRotationX(MathHelper.DegreesToRadians(<span class="hljs-number">-55.0f</span>));<br></code></pre></td></tr></table></figure><p>通过将顶点坐标与这个模型矩阵相乘，我们将顶点坐标转换为世界坐标。我们的平面略微位于地板上，因此代表了全局世界中的平面。</p><p>接下来，我们需要创建一个视图矩阵。我们想向后稍微移动场景，这样对象就变得可见（当在世界空间时，我们位于原点（0,0,0））。要在场景中移动，可以考虑以下内容：</p><ul><li>将相机向后移动，相当于将整个场景向前移动。</li></ul><p>这正是视图矩阵所做的，我们将整个场景向相机所在位置的反方向移动。因为我们想向后移动，而且由于OpenGL 是一个右手坐标系统，所以我们必须沿着正的 z 轴移动。我们通过沿着负z 轴平移场景来实现这一点。这会给人一种我们正在向后移动的印象。</p><blockquote><p>按照惯例，OpenGL 是一个右手坐标系统。这基本上意味着正 x轴在你的右边，正 y 轴向上，正 z 轴向后。想象一下，你的屏幕是 3个轴的中心，正 z 轴穿过屏幕朝向你。轴的方向如下所示：右手坐标系</p><p>要理解为什么它被称为右手坐标系，请按照以下步骤操作：</p><ol type="1"><li>将你的右手沿着正 y 轴伸展，手向上。</li><li>让你的大拇指指向右边。</li><li>让你的食指指向上方。</li><li>然后将你的中指向下弯曲 90 度。</li></ol><p>如果你做得对，你的大拇指应该指向正 x 轴，食指指向正 y 轴，中指指向正z 轴。如果你用左手这样做，你会发现 z轴是相反的。这被称为左手坐标系，DirectX通常使用它。请注意，在标准化设备坐标中，OpenGL实际上使用左手坐标系（投影矩阵会切换坐标系的左右性）。</p></blockquote><p>我们将在下一篇教程中更详细地讨论如何在场景中移动。目前，视图矩阵如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 注意我们将场景向我们想要移动的反方向进行平移。</span><br>Matrix4 view = Matrix4.CreateTranslation(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-3.0f</span>);<br></code></pre></td></tr></table></figure><p>我们需要定义的最后一件事是投影矩阵。我们想要在场景中使用透视投影，因此我们将声明投影矩阵如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(<span class="hljs-number">45.0f</span>), Width / Height, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure><p>现在我们已经创建了变换矩阵，我们应该将它们传递给我们的着色器。首先让我们在顶点着色器中将变换矩阵声明为uniform，并将它们与顶点坐标相乘：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br>...<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// 注意我们从右到左读取乘法</span><br>    <span class="hljs-built_in">gl_Position</span> =  <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>) * model * view * projection;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还应该将矩阵发送到着色器中（通常在每次渲染迭代中执行，因为变换矩阵往往会经常变化）：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">shader.SetMatrix4(<span class="hljs-string">&quot;model&quot;</span>, model);<br>shader.SetMatrix4(<span class="hljs-string">&quot;view&quot;</span>, view);<br>shader.SetMatrix4(<span class="hljs-string">&quot;projection&quot;</span>, projection);<br></code></pre></td></tr></table></figure><p>现在，我们的顶点坐标经过了模型、视图和投影矩阵的变换，最终对象应该是：</p><p>向后倾斜，靠在地板上。 离我们有一点远。以透视方式显示（随着顶点越来越远，它应该变小）。让我们检查一下结果是否确实满足了这些要求：</p><h2 id="相机">相机</h2><p>在之前的教程中，我们讨论了视图矩阵以及如何使用视图矩阵在场景中移动（我们稍微向后移动了一点）。OpenGL本身并不熟悉摄像机的概念，但我们可以尝试通过将场景中的所有物体向相反方向移动来模拟摄像机，从而产生我们在移动的错觉。</p><p>在本教程中，我们将讨论如何在OpenGL中设置摄像机。我们将讨论一种FPS风格的摄像机，它允许您在3D场景中自由移动。在本教程中，我们还将讨论键盘和鼠标输入，并以一个自定义摄像机类结束。</p><h3 id="相机视图空间">相机/视图空间</h3><p>当我们谈论相机/视图空间时，我们指的是从相机的角度来看所有顶点坐标，相机被视为场景的原点：视图矩阵将所有世界坐标转换为相对于相机位置和方向的视图坐标。要定义一个相机，我们需要它在世界空间中的位置、它所看的方向，以及从相机指向右侧和向上的向量。一个细心的读者可能会注意到，实际上我们要创建一个由相机位置作为原点的具有三个垂直单位轴的坐标系。</p><p><img src="9-camera_axes.png" /></p><h4 id="位置">位置</h4><p>获取相机位置很容易。相机位置基本上是世界空间中指向相机位置的向量。我们将相机设置在上一个教程中设置的相同位置：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 Position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">3.0f</span>);<br></code></pre></td></tr></table></figure><p>不要忘记，正z轴穿过屏幕指向您，因此如果我们希望相机向后移动，我们沿着正z轴移动。</p><h4 id="相机方向">相机方向</h4><p>下一个所需的向量是相机的方向，即它指向的方向。目前，我们让相机指向我们场景的原点：(0,0,0)。记住，如果我们从彼此中减去两个向量，我们得到的是这两个向量的差向量？因此，从场景原点向量中减去相机位置向量得到方向向量。由于我们知道相机指向负z方向，我们希望方向向量指向相机的正z轴。如果我们交换减法顺序，我们现在得到一个指向相机正z轴的向量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 cameraTarget = Vector3.Zero;<br>Vector3 cameraDirection = Vector3.Normalize(cameraPos - cameraTarget);<br></code></pre></td></tr></table></figure><p>“方向向量”这个名称并不是最合适的选择，因为实际上它指向的是与其目标相反的方向。</p><h4 id="右轴">右轴</h4><p>我们需要的下一个向量是一个右向量，表示相机空间的正x轴。为了获得右向量，我们使用一个小技巧，首先指定一个指向上方的上向量（在世界空间中）。然后，我们对上向量和第2步中的方向向量进行叉乘。由于叉乘的结果是两个向量的垂直向量，我们将得到一个指向正x轴方向的向量（如果我们交换向量，我们将得到一个指向负x轴的向量）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 up = Vector3.UnitY;<br>Vector3 cameraRight = Vector3.Normalize(Vector3.Cross(up, cameraDirection));<br></code></pre></td></tr></table></figure><h4 id="上轴">上轴</h4><p>现在我们有了x轴向量和z轴向量，获取指向相机正y轴的向量相对较容易：我们对右向量和方向向量进行叉乘：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 cameraUp = Vector3.Cross(cameraDirection, cameraRight);<br></code></pre></td></tr></table></figure><p>通过使用叉乘和一些技巧，我们能够创建形成视图/相机空间的所有向量。对于数学倾向的读者来说，这个过程在线性代数中被称为Gram-Schmidt过程。使用这些相机向量，我们现在可以创建一个非常有用的LookAt矩阵来创建相机。</p><h3 id="lookat">LookAt</h3><p>矩阵的一个伟大之处在于，如果你使用3个垂直（或非线性）的轴定义了一个坐标空间，你可以创建一个包含这3个轴加上一个平移向量的矩阵，通过与该矩阵相乘，你可以将任何向量转换到该坐标空间。这正是LookAt矩阵的作用，现在我们有了3个垂直的轴和一个位置向量来定义相机空间，我们可以创建自己的LookAt矩阵：<span class="math display">\[LookAt=\begin{bmatrix}R_x&amp;R_y&amp;R_z&amp;0\\U_x&amp;U_y&amp;U_z&amp;0\\D_x&amp;D_y&amp;D_z&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix}*\begin{bmatrix}1&amp;0&amp;0&amp;-P_x\\0&amp;1&amp;0&amp;-P_y\\0&amp;0&amp;1&amp;-P_z\\0&amp;0&amp;0&amp;1\\\end{bmatrix}\]</span>其中，R是右向量，U是上向量，D是方向向量，P是相机的位置向量。请注意，位置向量是反转的，因为我们最终希望将世界向相反方向移动。使用这个LookAt矩阵作为我们的视图矩阵有效地将所有世界坐标转换为我们刚刚定义的视图空间。LookAt矩阵的作用正是它的名字所描述的：它创建一个指向给定目标的视图矩阵。</p><p>幸运的是，OpenTK已经为我们完成了所有这些工作。我们只需要指定相机位置、目标位置和一个在世界空间中表示上向量的向量（我们用于计算右向量的上向量）。OpenTK然后创建我们可以用作视图矩阵的LookAt矩阵：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4 view = Matrix4.LookAt(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">3.0f</span>), <br>       <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>                        <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>));<br></code></pre></td></tr></table></figure><p><code>Matrix4.LookAt</code>函数分别需要位置、目标和上向量。这将创建一个与上一教程中使用的视图矩阵相同的视图矩阵。</p><h3 id="走动">走动</h3><p>现在是时候实际处理一些玩家输入并使我们的窗口响应了！首先，我们需要设置一个摄像机系统，因此在程序的顶部定义一些摄像机变量会很有用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">float</span> speed = <span class="hljs-number">1.5f</span>;<br><br>Vector3 position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">3.0f</span>);<br>Vector3 front = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-1.0f</span>);<br>Vector3 up = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,  <span class="hljs-number">0.0f</span>);<br></code></pre></td></tr></table></figure><p>在这里，我们引入了一个新的变量，以及用于LookAt函数的变量。speed变量将帮助我们定义相机移动时的速度。现在，LookAt函数变为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">view = Matrix4.LookAt(position, position + front, up);<br></code></pre></td></tr></table></figure><p>首先，我们将相机位置设置为之前定义的Position。方向是当前位置加上我们刚刚定义的方向向量。这确保了无论我们如何移动，相机都会保持朝向目标方向。让我们通过在按下某些键时更新Position向量来稍微调整这些变量。</p><p>我们已经看过如何在OnUpdateFrame函数中获取用户输入，现在我们可以扩展此功能以移动相机。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdateFrame</span>(<span class="hljs-params">FrameEventArgs e</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!IsFocused) <span class="hljs-comment">// check to see if the window is focused</span><br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    KeyboardState input = KeyboardState;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.W))<br>    &#123;<br>        position += front * speed; <span class="hljs-comment">//Forward </span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.S))<br>    &#123;<br>        position -= front * speed; <span class="hljs-comment">//Backwards</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.A))<br>    &#123;<br>        position -= Vector3.Normalize(Vector3.Cross(front, up)) * speed; <span class="hljs-comment">//Left</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.D))<br>    &#123;<br>        position += Vector3.Normalize(Vector3.Cross(front, up)) * speed; <span class="hljs-comment">//Right</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.Space))<br>    &#123;<br>        position += up * speed; <span class="hljs-comment">//Up </span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.LeftShift))<br>    &#123;<br>        position -= up * speed; <span class="hljs-comment">//Down</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>请注意，在顶部我们还检查窗口是否获得焦点，如果没有，就返回，这样可以避免窗口不在焦点时出现问题。</p></blockquote><p>每当我们按下WASD键中的一个时，相机的位置会相应地更新。如果我们想向前或向后移动，就会从位置向量中加或减去前向量。如果我们想侧向移动，我们会进行叉乘以创建一个右向量，并相应地沿着右向量移动。这样就产生了使用相机时熟悉的横向移动效果。此外，我们还添加了上升（空格键）或下降（LShift键）的功能，这与上升和下降相同，只是作用于上向量而不是前向量。</p><p>请注意，我们对结果右向量进行了归一化处理。如果我们不对该向量进行归一化处理，叉乘的结果可能会基于前变量而返回不同大小的向量。如果我们不对该向量进行归一化处理，我们移动的速度将取决于相机的方向，而不是保持一致的移动速度。</p><p>到目前为止，您应该已经能够以一种在不同系统中速度可能略有不同但您可能需要调整的速度移动相机了。</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenTK</tag>
      
      <tag>OpenGL</tag>
      
      <tag>图像渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2024/01/23/git/"/>
    <url>/2024/01/23/git/</url>
    
    <content type="html"><![CDATA[<h1 id="配置">配置</h1><p>设置代理：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> http.proxy http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">1184</span><br>git config <span class="hljs-literal">--global</span> https.proxy http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">1184</span><br></code></pre></td></tr></table></figure><p>其中<code>1184</code>是本机代理的端口号</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WSL指南</title>
    <link href="/2023/11/07/WSL%E6%8C%87%E5%8D%97/"/>
    <url>/2023/11/07/WSL%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="wsl">WSL</h1><ul><li><strong>Windows Subsystem for Linux</strong></li><li>微软自己出的一个系统支持比较好的能在windows环境下打开的linux系统</li></ul><h2 id="常用命令">常用命令</h2><blockquote><ul><li>将终端关闭，WSL系统并不会关闭，需要手动进行关闭</li><li>每个终端没有权限直接操作内核关机，例如在shutdown命令或是reboot命令是不被允许的</li></ul></blockquote><ul><li>关闭所有版本（分发）的虚拟机</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--shutdown</span><br></code></pre></td></tr></table></figure><ul><li>关闭指定版本（分发）的虚拟机</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">-t</span> &lt;分发&gt;<br></code></pre></td></tr></table></figure><ul><li>查看当前所有分发虚拟机的状态</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">-l</span> <span class="hljs-literal">--all</span> <span class="hljs-literal">-v</span><br></code></pre></td></tr></table></figure><ul><li>设定默认打开的虚拟机</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">-s</span> &lt;分发&gt;<br></code></pre></td></tr></table></figure><ul><li>导出虚拟机分发至一个指定路径</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--export</span> &lt;分发&gt; &lt;储存包路径&gt;<br></code></pre></td></tr></table></figure><ul><li>导入虚拟机分发至一个指定路径</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--import</span> &lt;分发名字&gt; &lt;安装位置&gt; &lt;储存包路径&gt;  <span class="hljs-literal">--version</span> &lt;wsl版本&gt;<br></code></pre></td></tr></table></figure><ul><li>注销分发并删除根文件系统</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--unregister</span> &lt;分发&gt;<br></code></pre></td></tr></table></figure><h2 id="迁移">迁移</h2><ul><li>在<code>Microsoft Store</code>中下载的系统，默认存储在C盘中，占用较大内存空间</li><li>步骤如下：<ol type="1"><li>通过<code>wsl -l --running</code>查看正在运行的子系统</li><li>若有正在运行的子系统，则通过<code>wsl -t &lt;DistributionName&gt;</code>来终止其运行</li><li>利用<code>wsl --export &lt;DistributionName&gt; &lt;FileName&gt;</code>来备份子系统，结果会得到一个<code>tar</code>归档文件。<ul><li>假设有名为<code>Ubuntu-20.04</code>的子系统，想要将结果文件保存为<code>Ubuntu2004.tar</code>（同时指定其路径即为<code>D:\wsl\Ubuntu2004.tar</code>），则调用的命令为<code>wsl --export Ubuntu-20.04 D:\wsl\Ubuntu2004.tar</code></li></ul></li><li>使用<code>wsl --unregister Ubuntu-20.04</code>注销原始子系统。</li><li>然后利用<code>wsl --import &lt;DistributionName&gt; &lt;InstallLocation&gt; &lt;FileName&gt;</code>来恢复子系统。</li><li><code>ubuntu2004.exe config --default-user 用户名</code></li></ol></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS进阶</title>
    <link href="/2023/11/04/ROS%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/11/04/ROS%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="ros-进阶">ROS 进阶</h1><h2 id="配置方法">配置方法</h2><ul><li><p>添加自定义头文件方式：<ahref="https://blog.csdn.net/qq_37945352/article/details/83303382">ROS中添加自定义头文件的方式_ros服务中添加自己包生成的头文件-CSDN博客</a></p></li><li><p>ROS中使用opencv方式：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(OpenCV REQUIRED)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">include</span> <span class="hljs-variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(opencv_test_node <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span> <span class="hljs-variable">$&#123;OpenCV_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="消息处理">消息处理</h2><h3 id="图像消息">图像消息</h3><ul><li><p><code>sensor_msgs/Image</code></p><ul><li><p>运行<code>rosmsg info sensor_msgs/Image</code>即可查看该消息的具体格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">std_msgs/Header header<br>  uint32 <span class="hljs-built_in">seq</span><br>  time stamp<br>  string frame_id<br>uint32 height<br>uint32 width<br>string encoding<br>uint8 is_bigendian<br>uint32 step<br>uint8[] data<br></code></pre></td></tr></table></figure></li><li><p><ahref="https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/Image.html">sensor_msgs/ImageDocumentation (ros.org)</a></p></li></ul></li><li><p>如果要使用<code>OpenCV</code>对图像进行处理，需要借助<code>cv_bridge</code>。CvBridge是一个ROS库，提供ROS和OpenCV之间的接口</p><ul><li><a href="http://wiki.ros.org/cv_bridge">cv_bridge - ROSWiki</a></li></ul></li></ul><h2 id="gazebo">Gazebo</h2><ul><li>在Gazebo中环境模型是以<code>.world</code>的文件进行保存</li><li>我们可以通过ros中的launch来启动加载world文件</li><li>在Gazebo中，机器人模型是通过URDF文件来描述的，URDF文件本质是xml格式</li><li>详见：<ahref="http://wiki.ros.org/urdf">http://wiki.ros.org/urdf</a></li><li><code>check_urdf mybot.urdf</code>检测urdf语法是否正确</li><li>我们可以通过ros中的launch来启动加载urdf文件</li><li>xacro文件是对urdf文件的补充，详见：<ahref="http://wiki.ros.org/xacro">xacro - ROS Wiki</a></li><li>gazebo插件：<ahref="https://classic.gazebosim.org/tutorials?tut=ros_gzplugins">Gazebo: Tutorial : Gazebo plugins in ROS (gazebosim.org)</a></li><li>gazebo标签的用法：https://classic.gazebosim.org/tutorials?tut=ros_urdf&amp;cat=connect_ros</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS基础入门</title>
    <link href="/2023/10/21/ROS%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2023/10/21/ROS%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="ros-安装">ROS 安装</h1><h2 id="操作系统">操作系统</h2><ul><li>使用 Ubuntu 系统<ul><li>虚拟机安装<ul><li>简单</li><li>硬件支持一般</li><li>初学者</li></ul></li><li>硬盘安装<ul><li>复杂</li><li>硬件支持好</li><li>有一定经验的开发者</li></ul></li></ul></li><li>系统版本匹配<ul><li>系统版本匹配参考：<ahref="http://wiki.ros.org/cn/ROS/Installation">cn/ROS/Installation - ROSWiki</a></li><li>采用版本：ROS Noetic Ninjemys + Ubuntu 20.04</li><li>建议在安装完操作系统后，制作一个快照，方便后期恢复初始系统</li></ul></li></ul><h2 id="编程语言">编程语言</h2><ul><li>在 Ros 中，采用 Python 和 C++ 两种语言进行开发，对 Python的支持可能不是特别完善。</li></ul><h3 id="安装-c-编译器和-python-解释器">安装 C++ 编译器和 Python解释器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install g++<br>sudo apt-get install python<br></code></pre></td></tr></table></figure><h2 id="安装ros">安装ROS</h2><ul><li><p>教程：<ahref="http://wiki.ros.org/cn/noetic/Installation/Ubuntu">cn/noetic/Installation/Ubuntu- ROS Wiki</a></p></li><li><p>安装 rosdep：<a href="http://wiki.ros.org/rosdep">rosdep - ROSWiki</a></p></li><li><p>测试安装成功，运行样例程序（以下三条命令运行在三个终端上）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">roscore<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun turtlesim turtlesim_node<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun turtlesim turtle_teleop_key<br></code></pre></td></tr></table></figure></li><li><p>至此 ROS 安装成功</p></li></ul><h1 id="ros-介绍">ROS 介绍</h1><ul><li><p>ROS = 通信机制 + 开发工具 + 应用功能 + 生态系统</p><ul><li>通信机制：松耦合分布式通信</li><li>开发工具：命令行、TF 坐标变换、Gazebo、Rviz、QT 工具箱</li><li>应用功能：很多</li><li>生态系统：<ul><li>发行版</li><li>软件源</li><li>ROS wiki：记录 ROS 信息文档的主要论坛</li><li>邮件列表</li><li>ROS Answers</li><li>博客：<ahref="http://www.ros.org/news">http://www.ros.org/news</a></li></ul></li></ul></li><li><p>节点 Node 和 节点管理器 ROS Master</p><ul><li>节点：执行单元<ul><li>执行具体任务的进行、独立运行的可执行文件</li><li>不同节点可使用不同的编程语言，可分布式运行在不同主机中</li><li>节点在系统中的名称必须是唯一的</li></ul></li><li>节点管理器：控制中心<ul><li>为节点提供命名和注册服务</li><li>跟踪和记录 话题 / 服务 通信，辅助结点相互查找、建立连接</li><li>提供参数服务器，节点使用此服务器存储和检索运行时的参数</li></ul></li></ul></li><li><p>话题 Topic：异步通信机制</p><ul><li>节点间用来传输数据的重要总线</li><li>使用<code>发布/订阅</code>模式，数据由发布者传输到订阅者，同一个话题的订阅者或发布者可以不唯一</li></ul></li><li><p>消息 Message：话题数据</p><ul><li>具有一定的类型和数据结构，包括 ROS提供的标准类型和用户自定义类型</li><li>使用编程语言无关的<code>.msg</code>文件定义，编译过程中生成对应的代码文件</li></ul></li><li><p>服务 Service：同步通信机制</p><ul><li>使用<code>客户端/服务器</code>模式，客户端发送请求数据，服务器完成处理后返回应答数据</li><li>使用编程语言无关的<code>.srv</code>文件定义请求和应答数据结构，编译过程中生成对应的代码文件</li></ul></li><li><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">话题</th><th style="text-align: center;">服务</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">同步性</td><td style="text-align: center;">异步</td><td style="text-align: center;">同步</td></tr><tr class="even"><td style="text-align: center;">通信模型</td><td style="text-align: center;">发布/订阅</td><td style="text-align: center;">客户端/服务器</td></tr><tr class="odd"><td style="text-align: center;">底层协议</td><td style="text-align: center;">ROSTCP/ROSUDP</td><td style="text-align: center;">ROSTCP/ROSUDP</td></tr><tr class="even"><td style="text-align: center;">反馈机制</td><td style="text-align: center;">无</td><td style="text-align: center;">有</td></tr><tr class="odd"><td style="text-align: center;">缓冲区</td><td style="text-align: center;">有</td><td style="text-align: center;">无</td></tr><tr class="even"><td style="text-align: center;">实时性</td><td style="text-align: center;">弱</td><td style="text-align: center;">强</td></tr><tr class="odd"><td style="text-align: center;">节点关系</td><td style="text-align: center;">多对多</td><td style="text-align: center;">一对多</td></tr><tr class="even"><td style="text-align: center;">使用场景</td><td style="text-align: center;">数据传输</td><td style="text-align: center;">逻辑处理</td></tr></tbody></table></li><li><p>参数 Parameter：全局共享字典</p><ul><li>可通过网络访问的共享、多变量字典</li><li>节点使用此服务器来存储和检索运行时的参数</li><li>适合存储静态、非二进制的配置参数，不适合存储动态配置的参数</li></ul></li><li><p>功能包 Package</p><ul><li>ROS 软件中的基本单元，包含节点源码、配置文件、数据定义等</li></ul></li><li><p>功能包清单 Package manifest</p><ul><li>记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等</li></ul></li><li><p>元功能包 Meta Packages</p><ul><li>组织多个用于同一目的功能包</li></ul></li></ul><h1 id="ros-操作">ROS 操作</h1><h2 id="命令行工具">命令行工具</h2><ul><li>常用命令<ul><li>rostopic</li><li>rosservice</li><li>rosnode</li><li>rosparam</li><li>rosmsg</li><li>rossrv</li><li>rosbag</li></ul></li></ul><h2 id="创建工作空间与功能包">创建工作空间与功能包</h2><ul><li><p>工作空间 workspace 是一个存放工程开发相关文件的文件夹</p><ul><li>src：代码空间</li><li>build：编译空间</li><li>devel：开发空间</li><li>install：安装空间</li></ul></li><li><p>创建工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/catkin_ws/src<br><span class="hljs-built_in">cd</span> ~/catkin_ws/src<br>catkin_init_workspace<br></code></pre></td></tr></table></figure></li><li><p>编译工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws/<br>catkin_make<br></code></pre></td></tr></table></figure></li><li><p>设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash<br></code></pre></td></tr></table></figure></li><li><p>检查环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$ROS_PACKAGE_PATH</span><br></code></pre></td></tr></table></figure></li><li><p>同一个工作空间下，不允许存在同名功能包。不同工作空间下，允许存在同名功能包。</p></li><li><p>创建功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws/src<br>catkin_create_pkg test_pkg std_msgs rospy roscpp<br></code></pre></td></tr></table></figure></li><li><p>编译功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws<br>catkin_make<br><span class="hljs-built_in">source</span> ~/catkin_ws/devel/setup.bash<br></code></pre></td></tr></table></figure></li></ul><h1 id="ros-编程开发">ROS 编程开发</h1><h2 id="发布者-publisher">发布者 Publisher</h2><h3 id="c-版本">C++ 版本</h3><ul><li><p>learning_topic/velocity_publisher.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/Twist.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ROS节点初始化</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;velocity_publisher&quot;</span>);<br><br><span class="hljs-comment">// 创建节点句柄</span><br>ros::NodeHandle n;<br><br><span class="hljs-comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span><br>ros::Publisher turtle_vel_pub = n.<span class="hljs-built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 设置循环的频率</span><br><span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>&#123;<br>    <span class="hljs-comment">// 初始化geometry_msgs::Twist类型的消息</span><br>geometry_msgs::Twist vel_msg;<br>vel_msg.linear.x = <span class="hljs-number">0.5</span>;<br>vel_msg.angular.z = <span class="hljs-number">0.2</span>;<br><br>    <span class="hljs-comment">// 发布消息</span><br>turtle_vel_pub.<span class="hljs-built_in">publish</span>(vel_msg);<br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, <br>vel_msg.linear.x, vel_msg.angular.z);<br><br>    <span class="hljs-comment">// 按照循环频率延时</span><br>    loop_rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>learning_topic/CMakeLists.txt</p><ul><li><p>以下代码要放在创建的功能包中的cmakelists.txt的install上面</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(velocity_publisher src/velocity_publisher.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(velocity_publisher <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><p>第一句是将<code>src/velocity_publisher.cpp</code>程序文件，编译成<code>velocity_publisher</code>可执行文件</p></li><li><p>第二句是将可执行文件<code>velocity_publisher</code>与<code>ros</code>相关库进行链接</p></li></ul></li><li><p>然后进行重新编译</p></li><li><p>如果为了避免每次打开命令行都要输入<code>source</code>，可以将<code>source</code>命令加入到主文件夹的<code>.bashrc</code>隐藏文件下（ctrl+ h 查看隐藏文件）</p></li></ul><h3 id="python-版本">Python 版本</h3><ul><li><p>为了跟<code>C++</code>版本进行区分，将<code>Python</code>版本代码，放到<code>/home/bjx/catkin_ws/src/learning_topic/scripts</code>文件夹中</p></li><li><p><code>Python</code>代码一定要有可执行权限，可以在<code>右键-属性-权限-执行</code>处进行修改，也可以通过命令行修改<code>chmod a+x hello.py</code></p></li><li><p><code>scripts/velocity_publisher.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment">########################################################################</span><br><span class="hljs-comment">####          Copyright 2020 GuYueHome (www.guyuehome.com).          ###</span><br><span class="hljs-comment">########################################################################</span><br><br><span class="hljs-comment"># 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> geometry_msgs.msg <span class="hljs-keyword">import</span> Twist<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">velocity_publisher</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;velocity_publisher&#x27;</span>, anonymous=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span><br>    turtle_vel_pub = rospy.Publisher(<span class="hljs-string">&#x27;/turtle1/cmd_vel&#x27;</span>, Twist, queue_size=<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">#设置循环的频率</span><br>    rate = rospy.Rate(<span class="hljs-number">10</span>) <br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():<br><span class="hljs-comment"># 初始化geometry_msgs::Twist类型的消息</span><br>        vel_msg = Twist()<br>        vel_msg.linear.x = <span class="hljs-number">0.5</span><br>        vel_msg.angular.z = <span class="hljs-number">0.2</span><br><br><span class="hljs-comment"># 发布消息</span><br>        turtle_vel_pub.publish(vel_msg)<br>    rospy.loginfo(<span class="hljs-string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, <br>vel_msg.linear.x, vel_msg.angular.z)<br><br><span class="hljs-comment"># 按照循环频率延时</span><br>        rate.sleep()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">try</span>:<br>        velocity_publisher()<br>    <span class="hljs-keyword">except</span> rospy.ROSInterruptException:<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li><p><code>#!/usr/bin/env python</code>是为了说明python文件为可执行文件，而不是脚本文件。</p></li><li><p><code># coding:utf-8</code>是保证编码格式。</p></li></ul></li><li><p>learning_topic/CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br>  scripts/velocity_publisher.py<br>  DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>再重新编译</p></li><li><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun learning_topic velocity_publisher.py<br></code></pre></td></tr></table></figure></li></ul><h2 id="订阅者-subscriber">订阅者 Subscriber</h2><h3 id="c-版本-1">C++ 版本</h3><ul><li><p>/src/pose_subscriber.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;turtlesim/Pose.h&quot;</span></span><br><br><span class="hljs-comment">// 接收到订阅的消息后，会进入消息回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">poseCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> turtlesim::Pose::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 将接收到的消息打印出来</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg-&gt;x, msg-&gt;y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化ROS节点</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;pose_subscriber&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span><br>    ros::Subscriber pose_sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;/turtle1/pose&quot;</span>, <span class="hljs-number">10</span>, poseCallback);<br><br>    <span class="hljs-comment">// 循环等待回调函数</span><br>    ros::<span class="hljs-built_in">spin</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>learning_topic/CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(pose_subscriber src/pose_subscriber.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(pose_subscriber <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><p>重新编译后，通过键盘修改小海龟位置参数，命令行也会同步出现位置的修改信息</p></li></ul><h3 id="python-版本-1">Python 版本</h3><ul><li><p>/scripts/pose_subscriber.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> turtlesim.msg <span class="hljs-keyword">import</span> Pose<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">poseCallback</span>(<span class="hljs-params">msg</span>):<br>    rospy.loginfo(<span class="hljs-string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg.x, msg.y)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pose_subscriber</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;pose_subscriber&#x27;</span>, anonymous=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span><br>    rospy.Subscriber(<span class="hljs-string">&quot;/turtle1/pose&quot;</span>, Pose, poseCallback)<br><br><span class="hljs-comment"># 循环等待回调函数</span><br>    rospy.spin()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pose_subscriber()<br></code></pre></td></tr></table></figure></li><li><p>learning_topic/CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br>  scripts/pose_subscriber.py<br>  DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>再重新编译</p></li><li><p>执行命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">rosrun learning_topic pose_subscriber.py<br></code></pre></td></tr></table></figure></li></ul><h2 id="话题消息">话题消息</h2><ul><li>当 ROS提供的消息类型无法满足我们的需要的时候，我们可以自己定义一个消息类型，以满足程序传输数据的要求。</li><li>此处我们以一个个人信息的消息发布为例，演示自定义话题的流程。</li></ul><h3 id="自定义话题消息">自定义话题消息</h3><ul><li><p>在<code>learning_topic</code>文件夹下创建文件夹<code>msg</code>用于管理所有的自定义消息类型</p></li><li><p>在<code>msg</code>文件夹下创建文件<code>Person.msg</code>文件，内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs msg">string name<br>uint8 sex<br>uint8 age<br><br>uint8 unknown = 0<br>uint8 male    = 1<br>uint8 female  = 2<br></code></pre></td></tr></table></figure></li><li><p>在<code>package.xml</code>中添加功能包依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>message_generation<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exec_depend</span>&gt;</span>message_runtime<span class="hljs-tag">&lt;/<span class="hljs-name">exec_depend</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</code>：这一行指定了在构建（编译）该ROS软件包时所需的依赖项。具体来说，它表示该软件包依赖于名为<code>message_generation</code>的软件包，用于生成ROS消息（Message）的包。在构建时，软件包将使用<code>message_generation</code>中的工具来处理和生成消息，以确保软件包正确地与其他ROS节点通信。</p></li><li><p><code>&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</code>：这一行指定了在运行时（当软件包被执行时）所需的依赖项。它表示该软件包在运行时依赖于名为<code>message_runtime</code> 的软件包。<code>message_runtime</code>包含运行时库，这些库允许软件包在运行时解析和使用ROS消息。</p></li><li><p>这些依赖关系的明确定义有助于ROS工具正确构建和部署软件包，以确保它们在运行时具有所需的依赖项。当构建和运行ROS软件包时，ROS工具（如<code>catkin_make</code>和<code>rosrun</code>）将自动处理这些依赖关系，以确保软件包能够正常工作。</p></li></ul></li><li><p>在功能包中的<code>CMakeLists.txt</code>中添加编译选项</p><ul><li><p>在<code>find_package</code>中添加功能包<code>message_generation</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">add_message_files(FILES Person.msg)<br>generate_messages(DEPENDENCIES std_msgs)<br></code></pre></td></tr></table></figure></li><li><p><code>add_message_files(FILES Person.msg)</code>：这一行代码告诉ROS构建系统，要将名为<code>Person.msg</code>的消息文件添加到该软件包中。这是一种将自定义消息定义添加到ROS软件包的方式。<code>Person.msg</code>文件包含了消息的结构和字段定义。当你运行<code>catkin_make</code>等构建工具时，ROS构建系统会处理这些消息定义文件，并生成相应的消息代码，以便在ROS程序中使用。</p></li><li><p><code>generate_messages(DEPENDENCIES std_msgs)</code>：这一行代码告诉ROS构建系统在生成消息时依赖于其他消息包。在这种情况下，它依赖于<code>std_msgs</code>软件包，这是ROS中包含许多标准消息类型的软件包。这意味着，如果你的<code>Person.msg</code>消息定义中使用了<code>std_msgs</code>中定义的消息类型，你需要指定这个依赖项，以确保生成的消息代码能够正确引用<code>std_msgs</code> 中的消息类型。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_package(<br><span class="hljs-comment">#  INCLUDE_DIRS include</span><br><span class="hljs-comment">#  LIBRARIES learning_topic</span><br>   CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime<br><span class="hljs-comment">#  DEPENDS system_lib</span><br>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>重新编译，之后在<code>/home/bjx/catkin_ws/devel/include/learning_topic</code>中可以看到编译生成的一个头文件</p></li></ul><h3 id="c-版本-2">C++ 版本</h3><h4 id="发布者">发布者</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将发布/person_info话题，自定义消息类型learning_topic::Person</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;learning_topic/Person.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ROS节点初始化</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;person_publisher&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span><br>    ros::Publisher person_info_pub = n.<span class="hljs-built_in">advertise</span>&lt;learning_topic::Person&gt;(<span class="hljs-string">&quot;/person_info&quot;</span>, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">// 设置循环的频率</span><br>    <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>    &#123;<br>        <span class="hljs-comment">// 初始化learning_topic::Person类型的消息</span><br>    learning_topic::Person person_msg;<br>person_msg.name = <span class="hljs-string">&quot;Tom&quot;</span>;<br>person_msg.age  = <span class="hljs-number">18</span>;<br>person_msg.sex  = learning_topic::Person::male;<br><br>        <span class="hljs-comment">// 发布消息</span><br>person_info_pub.<span class="hljs-built_in">publish</span>(person_msg);<br><br>       <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Publish Person Info: name:%s  age:%d  sex:%d&quot;</span>, <br>  person_msg.name.<span class="hljs-built_in">c_str</span>(), person_msg.age, person_msg.sex);<br><br>        <span class="hljs-comment">// 按照循环频率延时</span><br>        loop_rate.<span class="hljs-built_in">sleep</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(person_publisher src/person_publisher.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(person_publisher <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">add_dependencies</span>(person_publisher <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)<br></code></pre></td></tr></table></figure><h4 id="订阅者">订阅者</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;learning_topic/Person.h&quot;</span></span><br><br><span class="hljs-comment">// 接收到订阅的消息后，会进入消息回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">personInfoCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> learning_topic::Person::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 将接收到的消息打印出来</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, <br> msg-&gt;name.<span class="hljs-built_in">c_str</span>(), msg-&gt;age, msg-&gt;sex);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化ROS节点</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;person_subscriber&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span><br>    ros::Subscriber person_info_sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;/person_info&quot;</span>, <span class="hljs-number">10</span>, personInfoCallback);<br><br>    <span class="hljs-comment">// 循环等待回调函数</span><br>    ros::<span class="hljs-built_in">spin</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(person_subscriber src/person_subscriber.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(person_subscriber <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">add_dependencies</span>(person_subscriber <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)<br></code></pre></td></tr></table></figure><h4 id="运行程序">运行程序</h4><ul><li>编译</li><li>运行程序，发现输出个人信息</li><li>rosmaster是用于帮助建立连接，一旦连接成功建立，就不在需要master了。可以尝试关闭roscore，此时消息传输不会停止出错</li></ul><h3 id="python-版本-2">Python 版本</h3><h4 id="发布者-1">发布者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/user/bin/env python</span><br><span class="hljs-comment"># -*- coidng: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将发布/person_info话题，自定义消息类型learning_topic::Person</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> learning_topic.msg <span class="hljs-keyword">import</span> Person<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">velocity_publihser</span>():<br>    <span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;person_publisher&#x27;</span>, anonymous=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-comment"># 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span><br>    person_info_pub = rospy.Publisher(<span class="hljs-string">&#x27;/person_info&#x27;</span>, Person, queue_size=<span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">#设置循环的频率</span><br>    rate = rospy.Rate(<span class="hljs-number">10</span>) <br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():<br>        <span class="hljs-comment"># 初始化learning_topic::Person类型的消息</span><br>        person_msg = Person()<br>        person_msg.name = <span class="hljs-string">&quot;Tom&quot;</span><br>        person_msg.age  = <span class="hljs-number">18</span><br>        person_msg.sex  = Person.male<br><br>        <span class="hljs-comment"># 发布消息</span><br>        person_info_pub.publish(person_msg)<br>        rospy.loginfo(<span class="hljs-string">&quot;Publsh person message[%s, %d, %d]&quot;</span>,person_msg.name, person_msg.age, person_msg.sex)<br><br>        <span class="hljs-comment"># 按照循环频率延时</span><br>        rate.sleep()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">try</span>:<br>        velocity_publihser()<br>    <span class="hljs-keyword">except</span> rospy.ROSInterruptException:<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li><code>CMakeLists.txt</code>中添加配置</li></ul><h4 id="订阅者-1">订阅者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> learning_topic.msg <span class="hljs-keyword">import</span> Person<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">personInfoCallback</span>(<span class="hljs-params">msg</span>):<br>    rospy.loginfo(<span class="hljs-string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, <br> msg.name, msg.age, msg.sex)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person_subscriber</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;person_subscriber&#x27;</span>, anonymous=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span><br>    rospy.Subscriber(<span class="hljs-string">&quot;/person_info&quot;</span>, Person, personInfoCallback)<br><br><span class="hljs-comment"># 循环等待回调函数</span><br>    rospy.spin()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    person_subscriber()<br></code></pre></td></tr></table></figure><ul><li><code>CMakeLists.txt</code>中添加配置</li></ul><h4 id="运行程序-1">运行程序</h4><ul><li>编译</li><li>运行</li></ul><h2 id="客户端-client">客户端 Client</h2><ul><li><p>从本节开始，学习服务的相关实现</p></li><li><p>本节用到的例子是创建一个新的小海龟</p></li><li><p>创建一个新的功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_create_pkg learning_service roscpp rospy std_msgs geometry_msgs turtlesim<br></code></pre></td></tr></table></figure></li></ul><h3 id="c-版本-3">C++ 版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;turtlesim/Spawn.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化ROS节点</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;turtle_spawn&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>ros::NodeHandle node;<br><br>    <span class="hljs-comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;/spawn&quot;</span>);<br>ros::ServiceClient add_turtle = node.<span class="hljs-built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="hljs-string">&quot;/spawn&quot;</span>);<br><br>    <span class="hljs-comment">// 初始化turtlesim::Spawn的请求数据</span><br>turtlesim::Spawn srv;<br>srv.request.x = <span class="hljs-number">2.0</span>;<br>srv.request.y = <span class="hljs-number">2.0</span>;<br>srv.request.name = <span class="hljs-string">&quot;turtle2&quot;</span>;<br><br>    <span class="hljs-comment">// 请求服务调用</span><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]&quot;</span>, <br> srv.request.x, srv.request.y, srv.request.name.<span class="hljs-built_in">c_str</span>());<br><br>add_turtle.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-comment">// 显示服务调用结果</span><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Spwan turtle successfully [name:%s]&quot;</span>, srv.response.name.<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(turtle_spawn src/turtle_spawn.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(turtle_spawn <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">roscore<br>rosrun turtlesim turtlesim_node<br>rosrun learning_service turtle_spawn<br></code></pre></td></tr></table></figure><ul><li>编译运行后，此时会发现出现两只小海龟</li></ul><h3 id="python-版本-3">Python 版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn</span><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> turtlesim.srv <span class="hljs-keyword">import</span> Spawn<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">turtle_spawn</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;turtle_spawn&#x27;</span>)<br><br><span class="hljs-comment"># 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span><br>    rospy.wait_for_service(<span class="hljs-string">&#x27;/spawn&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        add_turtle = rospy.ServiceProxy(<span class="hljs-string">&#x27;/spawn&#x27;</span>, Spawn)<br><br><span class="hljs-comment"># 请求服务调用，输入请求数据</span><br>        response = add_turtle(<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-string">&quot;turtle2&quot;</span>)<br>        <span class="hljs-keyword">return</span> response.name<br>    <span class="hljs-keyword">except</span> rospy.ServiceException <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Service call failed: %s&quot;</span>%e)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-comment">#服务调用并显示调用结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Spwan turtle successfully [name:%s]&quot;</span> %(turtle_spawn())) <br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br> scripts/turtle_spawn.py<br>DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure><ul><li>编译运行后，此时会发现出现两只小海龟</li></ul><h2 id="服务器端-server">服务器端 Server</h2><ul><li>步骤<ol type="1"><li>初始化ROS结点</li><li>创建Server实例</li><li>循环等待服务请求，进入回调函数</li><li>在回调函数中完成服务功能的处理，并反馈应答数据</li></ol></li></ul><h3 id="c-版本-4">C++ 版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/Twist.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;std_srvs/Trigger.h&gt;</span></span><br><br>ros::Publisher turtle_vel_pub;<br><span class="hljs-type">bool</span> pubCommand = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// service回调函数，输入参数req，输出参数res</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">commandCallback</span><span class="hljs-params">(std_srvs::Trigger::Request  &amp;req,</span></span><br><span class="hljs-params"><span class="hljs-function">         std_srvs::Trigger::Response &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>pubCommand = !pubCommand;<br><br>    <span class="hljs-comment">// 显示请求数据</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Publish turtle velocity command [%s]&quot;</span>, pubCommand==<span class="hljs-literal">true</span>?<span class="hljs-string">&quot;Yes&quot;</span>:<span class="hljs-string">&quot;No&quot;</span>);<br><br><span class="hljs-comment">// 设置反馈数据</span><br>res.success = <span class="hljs-literal">true</span>;<br>res.message = <span class="hljs-string">&quot;Change turtle command state!&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ROS节点初始化</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;turtle_command_server&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 创建一个名为/turtle_command的server，注册回调函数commandCallback</span><br>    ros::ServiceServer command_service = n.<span class="hljs-built_in">advertiseService</span>(<span class="hljs-string">&quot;/turtle_command&quot;</span>, commandCallback);<br><br><span class="hljs-comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span><br>turtle_vel_pub = n.<span class="hljs-built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">// 循环等待回调函数</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Ready to receive turtle command.&quot;</span>);<br><br><span class="hljs-comment">// 设置循环的频率</span><br><span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-keyword">while</span>(ros::<span class="hljs-built_in">ok</span>())<br>&#123;<br><span class="hljs-comment">// 查看一次回调函数队列</span><br>    ros::<span class="hljs-built_in">spinOnce</span>();<br><br><span class="hljs-comment">// 如果标志为true，则发布速度指令</span><br><span class="hljs-keyword">if</span>(pubCommand)<br>&#123;<br>geometry_msgs::Twist vel_msg;<br>vel_msg.linear.x = <span class="hljs-number">0.5</span>;<br>vel_msg.angular.z = <span class="hljs-number">0.2</span>;<br>turtle_vel_pub.<span class="hljs-built_in">publish</span>(vel_msg);<br>&#125;<br><br><span class="hljs-comment">//按照循环频率延时</span><br>    loop_rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(turtle_command_server src/turtle_command_server.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(turtle_command_server <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">roscore<br>rosrun turtlesim turtlesim_node<br>rosrun learning_service turtle_command_server<br>rosservice call /turtle_command <span class="hljs-string">&quot;&#123;&#125;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="python-版本-4">Python 版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">import</span> thread, time<br><span class="hljs-keyword">from</span> geometry_msgs.msg <span class="hljs-keyword">import</span> Twist<br><span class="hljs-keyword">from</span> std_srvs.srv <span class="hljs-keyword">import</span> Trigger, TriggerResponse<br><br>pubCommand = <span class="hljs-literal">False</span><br>turtle_vel_pub = rospy.Publisher(<span class="hljs-string">&#x27;/turtle1/cmd_vel&#x27;</span>, Twist, queue_size=<span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">command_thread</span>():<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-keyword">if</span> pubCommand:<br>vel_msg = Twist()<br>vel_msg.linear.x = <span class="hljs-number">0.5</span><br>vel_msg.angular.z = <span class="hljs-number">0.2</span><br>turtle_vel_pub.publish(vel_msg)<br><br>time.sleep(<span class="hljs-number">0.1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">commandCallback</span>(<span class="hljs-params">req</span>):<br><span class="hljs-keyword">global</span> pubCommand<br>pubCommand = <span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>-pubCommand)<br><br><span class="hljs-comment"># 显示请求数据</span><br>rospy.loginfo(<span class="hljs-string">&quot;Publish turtle velocity command![%d]&quot;</span>, pubCommand)<br><br><span class="hljs-comment"># 反馈数据</span><br><span class="hljs-keyword">return</span> TriggerResponse(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Change turtle command state!&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">turtle_command_server</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;turtle_command_server&#x27;</span>)<br><br><span class="hljs-comment"># 创建一个名为/turtle_command的server，注册回调函数commandCallback</span><br>    s = rospy.Service(<span class="hljs-string">&#x27;/turtle_command&#x27;</span>, Trigger, commandCallback)<br><br><span class="hljs-comment"># 循环等待回调函数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Ready to receive turtle command.&quot;</span>) <br><br>    thread.start_new_thread(command_thread, ())<br>    rospy.spin()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    turtle_command_server()<br></code></pre></td></tr></table></figure><ul><li><code>C++</code>中的<code>ros::spinOnce()</code>在<code>Python</code>中是没有实现的，只有<code>rospy.spin()</code>。所以要通过多线程机制，来实现<code>ros::spinOnce()</code>同样的功能。</li><li>如果使用的是<code>Python3</code>，需要将<code>thread</code>改成<code>_thread</code></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br> scripts/turtle_spawn.py scripts/turtle_command_server.py<br>DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure><ul><li>上面脚本在后面跟着写即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">roscore<br>rosrun turtlesim turtlesim_node<br>rosrun learning_service turtle_command_server<br>rosservice call /turtle_command <span class="hljs-string">&quot;&#123;&#125;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="服务数据">服务数据</h2><h3 id="自定义服务数据">自定义服务数据</h3><ul><li><p>在<code>learning_service</code>文件夹下创建创建文件夹<code>srv</code>来管理所有自定义服务数据</p></li><li><p>在<code>srv</code>文件夹下创建文件<code>Person.srv</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs srv">string name<br>uint8  age<br>uint8  sex<br><br>uint8 unknown = 0<br>uint8 male    = 1<br>uint8 female  = 2<br>---<br>string result<br></code></pre></td></tr></table></figure><ul><li><code>---</code>上面是请求的格式，下面是应答的格式</li></ul></li><li><p>在<code>package.xml</code>中添加功能包依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>message_generation<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exec_depend</span>&gt;</span>message_runtime<span class="hljs-tag">&lt;/<span class="hljs-name">exec_depend</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在功能包中的<code>CMakeLists.txt</code>中添加编译选项</p><ul><li><p>在<code>find_package</code>中添加功能包<code>message_generation</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">add_service_files(FILES Person.srv)<br>generate_messages(DEPENDENCIES std_msgs)<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_package(<br><span class="hljs-comment">#  INCLUDE_DIRS include</span><br><span class="hljs-comment">#  LIBRARIES learning_topic</span><br>   CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime<br><span class="hljs-comment">#  DEPENDS system_lib</span><br>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>重新编译，之后在<code>/home/bjx/catkin_ws/devel/include/learning_service</code>中可以看到编译生成的三个头文件</p></li></ul><h3 id="c-版本-5">C++ 版本</h3><h4 id="客户端">客户端</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将请求/show_person服务，服务数据类型learning_service::Person</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;learning_service/Person.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化ROS节点</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;person_client&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>ros::NodeHandle node;<br><br>    <span class="hljs-comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;/show_person&quot;</span>);<br>ros::ServiceClient person_client = node.<span class="hljs-built_in">serviceClient</span>&lt;learning_service::Person&gt;(<span class="hljs-string">&quot;/show_person&quot;</span>);<br><br>    <span class="hljs-comment">// 初始化learning_service::Person的请求数据</span><br>learning_service::Person srv;<br>srv.request.name = <span class="hljs-string">&quot;Tom&quot;</span>;<br>srv.request.age  = <span class="hljs-number">20</span>;<br>srv.request.sex  = learning_service::Person::Request::male;<br><br>    <span class="hljs-comment">// 请求服务调用</span><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Call service to show person[name:%s, age:%d, sex:%d]&quot;</span>, <br> srv.request.name.<span class="hljs-built_in">c_str</span>(), srv.request.age, srv.request.sex);<br><br>person_client.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-comment">// 显示服务调用结果</span><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Show person result : %s&quot;</span>, srv.response.result.<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(person_client src/person_client.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(person_client <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">add_dependencies</span>(person_client <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)<br></code></pre></td></tr></table></figure><h4 id="服务端">服务端</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将执行/show_person服务，服务数据类型learning_service::Person</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;learning_service/Person.h&quot;</span></span><br><br><span class="hljs-comment">// service回调函数，输入参数req，输出参数res</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">personCallback</span><span class="hljs-params">(learning_service::Person::Request  &amp;req,</span></span><br><span class="hljs-params"><span class="hljs-function">         learning_service::Person::Response &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 显示请求数据</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name.<span class="hljs-built_in">c_str</span>(), req.age, req.sex);<br><br><span class="hljs-comment">// 设置反馈数据</span><br>res.result = <span class="hljs-string">&quot;OK&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ROS节点初始化</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;person_server&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 创建一个名为/show_person的server，注册回调函数personCallback</span><br>    ros::ServiceServer person_service = n.<span class="hljs-built_in">advertiseService</span>(<span class="hljs-string">&quot;/show_person&quot;</span>, personCallback);<br><br>    <span class="hljs-comment">// 循环等待回调函数</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Ready to show person informtion.&quot;</span>);<br>    ros::<span class="hljs-built_in">spin</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(person_server src/person_server.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(person_server <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">add_dependencies</span>(person_server <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)<br></code></pre></td></tr></table></figure><h3 id="python-版本-5">Python 版本</h3><h4 id="客户端-1">客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将请求/show_person服务，服务数据类型learning_service::Person</span><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> learning_service.srv <span class="hljs-keyword">import</span> Person, PersonRequest<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person_client</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;person_client&#x27;</span>)<br><br><span class="hljs-comment"># 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span><br>    rospy.wait_for_service(<span class="hljs-string">&#x27;/show_person&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        person_client = rospy.ServiceProxy(<span class="hljs-string">&#x27;/show_person&#x27;</span>, Person)<br><br><span class="hljs-comment"># 请求服务调用，输入请求数据</span><br>        response = person_client(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">20</span>, PersonRequest.male)<br>        <span class="hljs-keyword">return</span> response.result<br>    <span class="hljs-keyword">except</span> rospy.ServiceException <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Service call failed: %s&quot;</span>%e) <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-comment">#服务调用并显示调用结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Show person result : %s&quot;</span> %(person_client()))<br></code></pre></td></tr></table></figure><ul><li>在<code>catkin_install_python</code>中加入该文件</li></ul><h4 id="服务端-1">服务端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将执行/show_person服务，服务数据类型learning_service::Person</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> learning_service.srv <span class="hljs-keyword">import</span> Person, PersonResponse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">personCallback</span>(<span class="hljs-params">req</span>):<br><span class="hljs-comment"># 显示请求数据</span><br>    rospy.loginfo(<span class="hljs-string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name, req.age, req.sex)<br><br><span class="hljs-comment"># 反馈数据</span><br>    <span class="hljs-keyword">return</span> PersonResponse(<span class="hljs-string">&quot;OK&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person_server</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;person_server&#x27;</span>)<br><br><span class="hljs-comment"># 创建一个名为/show_person的server，注册回调函数personCallback</span><br>    s = rospy.Service(<span class="hljs-string">&#x27;/show_person&#x27;</span>, Person, personCallback)<br><br><span class="hljs-comment"># 循环等待回调函数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Ready to show person informtion.&quot;</span>) <br>    rospy.spin()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    person_server()<br></code></pre></td></tr></table></figure><p>在<code>catkin_install_python</code>中加入该文件</p><h2 id="参数">参数</h2><ul><li><p>在 ROS Master 中有一个参数服务器 ParameterServer，是一个全局字典，用于保存各个节点之间的配置参数。</p></li><li><p>创建功能包<code>learning_parameter</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws/src<br>catkin_create_pkg learning_parameter roscpp rospy std_srvs<br></code></pre></td></tr></table></figure></li></ul><h3 id="参数命令行使用">参数命令行使用</h3><ul><li><p>列出当前所有参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam list<br></code></pre></td></tr></table></figure></li><li><p>显示某个参数值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam get param_key<br></code></pre></td></tr></table></figure></li><li><p>设置某个参数值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam <span class="hljs-built_in">set</span> param_key param_value<br></code></pre></td></tr></table></figure><ul><li>在设置小海龟的背景颜色案例中，设置完颜色，还有请求一下服务，运行命令<code>rosservice call /clear '&#123;&#125;'</code>，背景颜色方才改变。</li></ul></li><li><p>保存参数到文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam dump file_name<br></code></pre></td></tr></table></figure></li><li><p>从文件读取参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam load file_name<br></code></pre></td></tr></table></figure></li><li><p>删除参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam delete param_key<br></code></pre></td></tr></table></figure></li><li><p>在 ROS 中，如果参数比较多，会用到 YAML 参数文件，格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">rosdistro:</span> <span class="hljs-string">&#x27;noetic</span><br><span class="hljs-string"></span><br><span class="hljs-string">  &#x27;</span><br><span class="hljs-attr">roslaunch:</span><br>  <span class="hljs-attr">uris:</span><br>    <span class="hljs-attr">host_bjx__44977:</span> <span class="hljs-string">http://bjx:44977/</span><br><span class="hljs-attr">rosversion:</span> <span class="hljs-string">&#x27;1.16.0</span><br><span class="hljs-string"></span><br><span class="hljs-string">  &#x27;</span><br><span class="hljs-attr">run_id:</span> <span class="hljs-string">c713a7d4-753e-11ee-84ae-234d4d1e8e05</span><br><span class="hljs-attr">turtlesim:</span><br>  <span class="hljs-attr">background_b:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">background_g:</span> <span class="hljs-number">86</span><br>  <span class="hljs-attr">background_r:</span> <span class="hljs-number">69</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="编程方法">编程方法</h3><h4 id="c-版本-6">C++ 版本</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程设置/读取海龟例程中的参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;std_srvs/Empty.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> red, green, blue;<br><br>    <span class="hljs-comment">// ROS节点初始化</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;parameter_config&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle node;<br><br>    <span class="hljs-comment">// 读取背景颜色参数</span><br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_r&quot;</span>, red);<br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_g&quot;</span>, green);<br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_b&quot;</span>, blue);<br><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);<br><br><span class="hljs-comment">// 设置背景颜色参数</span><br>ros::param::<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;/turtlesim/background_r&quot;</span>, <span class="hljs-number">255</span>);<br>ros::param::<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;/turtlesim/background_g&quot;</span>, <span class="hljs-number">255</span>);<br>ros::param::<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;/turtlesim/background_b&quot;</span>, <span class="hljs-number">255</span>);<br><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>);<br><br>    <span class="hljs-comment">// 读取背景颜色参数</span><br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_r&quot;</span>, red);<br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_g&quot;</span>, green);<br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_b&quot;</span>, blue);<br><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Re-get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);<br><br><span class="hljs-comment">// 调用服务，刷新背景颜色</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;/clear&quot;</span>);<br>ros::ServiceClient clear_background = node.<span class="hljs-built_in">serviceClient</span>&lt;std_srvs::Empty&gt;(<span class="hljs-string">&quot;/clear&quot;</span>);<br>std_srvs::Empty srv;<br>clear_background.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(parameter_config src/parameter_config.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(parameter_config <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><ul><li>一定要注意参数名是否正确</li><li>上面的get和set并不是唯一的获取参数的值的方法，还有其他方法，具体参考<ahref="http://wiki.ros.org/Parameter%20Server">http://wiki.ros.org/ParameterServer</a></li></ul><h4 id="python-版本-6">Python 版本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程设置/读取海龟例程中的参数</span><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> std_srvs.srv <span class="hljs-keyword">import</span> Empty<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parameter_config</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;parameter_config&#x27;</span>, anonymous=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 读取背景颜色参数</span><br>    red   = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_r&#x27;</span>)<br>    green = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_g&#x27;</span>)<br>    blue  = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_b&#x27;</span>)<br><br>    rospy.loginfo(<span class="hljs-string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue)<br><br><span class="hljs-comment"># 设置背景颜色参数</span><br>    rospy.set_param(<span class="hljs-string">&quot;/turtlesim/background_r&quot;</span>, <span class="hljs-number">255</span>)<br>    rospy.set_param(<span class="hljs-string">&quot;/turtlesim/background_g&quot;</span>, <span class="hljs-number">255</span>)<br>    rospy.set_param(<span class="hljs-string">&quot;/turtlesim/background_b&quot;</span>, <span class="hljs-number">255</span>)<br><br>    rospy.loginfo(<span class="hljs-string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>)<br><br><span class="hljs-comment"># 读取背景颜色参数</span><br>    red   = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_r&#x27;</span>)<br>    green = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_g&#x27;</span>)<br>    blue  = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_b&#x27;</span>)<br><br>    rospy.loginfo(<span class="hljs-string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue)<br><br><span class="hljs-comment"># 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span><br>    rospy.wait_for_service(<span class="hljs-string">&#x27;/clear&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        clear_background = rospy.ServiceProxy(<span class="hljs-string">&#x27;/clear&#x27;</span>, Empty)<br><br><span class="hljs-comment"># 请求服务调用，输入请求数据</span><br>        response = clear_background()<br>        <span class="hljs-keyword">return</span> response<br>    <span class="hljs-keyword">except</span> rospy.ServiceException <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Service call failed: %s&quot;</span>%e) <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    parameter_config()<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br>scripts/parameter_config.py<br>DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure><h2 id="坐标系管理">坐标系管理</h2><ul><li>ROS 中的坐标系管理系统 TF (TransForm)</li><li>任意两个三维坐标的坐标变换，都可以通过一个四阶矩阵来表示</li><li>TF 默认记录10秒钟之内所有坐标系之间的位置关系</li><li>TF 坐标变换的实现<ul><li>广播 TF 变换</li><li>监听 TF 变换</li></ul></li></ul><h3 id="使用方法">使用方法</h3><ul><li><p>下载小海龟的 tf 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install ros-noetic-turtle-tf<br></code></pre></td></tr></table></figure></li><li><p>运行 launch 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">roslaunch turtle_tf turtle_tf_demo.launch<br></code></pre></td></tr></table></figure></li><li><p>运行键盘控制程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun turtlesim turtle_teleop_key<br></code></pre></td></tr></table></figure></li><li><p>view_frames 是一个图形化的调试工具，并且可以输出当前的tf关系到pdf 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun tf view_frames<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>【问题解决】：</p><ol type="1"><li>如果在运行launch的过程中，出现rospkg的报错，很有可能是由于系统中存在多个Python，解决方案：http://t.csdnimg.cn/iRmvW</li><li>如果在运行tf的过程中，报错，需要修改代码，解决方案：https://www.cnblogs.com/QMark/p/15098334.html</li></ol></blockquote><ul><li><p>把特定坐标系之间的平移旋转关系打印到终端控制台上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun tf tf_echo turtle1 turtle2<br></code></pre></td></tr></table></figure><ul><li><p>以上命令可以直观的将 turtle2 坐标系到 turtle1坐标系的坐标变换矩阵展示出来</p></li><li><p>输出结果为：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">At time 1698634776.960<br>- Translation: [0.000, 0.000, 0.000]<br>- Rotation: in Quaternion [<span class="hljs-string">-0</span>.000, <span class="hljs-string">-0</span>.000, 0.640, 0.769]<br>            in RPY (radian) [<span class="hljs-string">-0</span>.000, <span class="hljs-string">-0</span>.000, 1.388]<br>            in RPY (degree) [<span class="hljs-string">-0</span>.000, <span class="hljs-string">-0</span>.000, 79.536]<br></code></pre></td></tr></table></figure></li></ul></li><li><p>更加可视化的工具 rviz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun rviz rviz -d <span class="hljs-string">&#x27;rospack find turtle_tf&#x27;</span> /rviz/turtle_rviz.rviz<br></code></pre></td></tr></table></figure></li></ul><h3 id="坐标系广播和监听的编程实现">坐标系广播和监听的编程实现</h3><ul><li><p>创建功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws/src<br>catkin_create_pkg learning_tf roscpp rospy tf turtlesim<br></code></pre></td></tr></table></figure></li></ul><h4 id="c-版本-7">C++ 版本</h4><h5 id="tf-广播器代码">tf 广播器代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tf/transform_listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/Twist.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;turtlesim/Spawn.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 初始化ROS节点</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;my_tf_listener&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>ros::NodeHandle node;<br><br><span class="hljs-comment">// 请求产生turtle2</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;/spawn&quot;</span>);<br>ros::ServiceClient add_turtle = node.<span class="hljs-built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="hljs-string">&quot;/spawn&quot;</span>);<br>turtlesim::Spawn srv;<br>add_turtle.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-comment">// 创建发布turtle2速度控制指令的发布者</span><br>ros::Publisher turtle_vel = node.<span class="hljs-built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建tf的监听器</span><br>tf::TransformListener listener;<br><br><span class="hljs-function">ros::Rate <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-number">10.0</span>)</span></span>;<br><span class="hljs-keyword">while</span> (node.<span class="hljs-built_in">ok</span>())<br>&#123;<br><span class="hljs-comment">// 获取turtle1与turtle2坐标系之间的tf数据</span><br>tf::StampedTransform transform;<br><span class="hljs-keyword">try</span><br>&#123;<br>listener.<span class="hljs-built_in">waitForTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">3.0</span>));<br>listener.<span class="hljs-built_in">lookupTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), transform);<br>&#125;<br><span class="hljs-built_in">catch</span> (tf::TransformException &amp;ex) <br>&#123;<br><span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>,ex.<span class="hljs-built_in">what</span>());<br>ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">1.0</span>).<span class="hljs-built_in">sleep</span>();<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span><br>geometry_msgs::Twist vel_msg;<br>vel_msg.angular.z = <span class="hljs-number">4.0</span> * <span class="hljs-built_in">atan2</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(),<br>                        transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>());<br>vel_msg.linear.x = <span class="hljs-number">0.5</span> * <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>(), <span class="hljs-number">2</span>) +<br>                      <span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(), <span class="hljs-number">2</span>));<br>turtle_vel.<span class="hljs-built_in">publish</span>(vel_msg);<br><br>rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>步骤：<ol type="1"><li>定义 TF 广播器</li><li>创建坐标变换值</li><li>发布坐标变换</li></ol></li></ul><h5 id="tf-监听器代码">tf 监听器代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tf/transform_listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/Twist.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;turtlesim/Spawn.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 初始化ROS节点</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;my_tf_listener&quot;</span>);<br><br><span class="hljs-comment">// 创建节点句柄</span><br>ros::NodeHandle node;<br><br><span class="hljs-comment">// 请求产生turtle2</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;/spawn&quot;</span>);<br>ros::ServiceClient add_turtle = node.<span class="hljs-built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="hljs-string">&quot;/spawn&quot;</span>);<br>turtlesim::Spawn srv;<br>add_turtle.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-comment">// 创建发布turtle2速度控制指令的发布者</span><br>ros::Publisher turtle_vel = node.<span class="hljs-built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建tf的监听器</span><br>tf::TransformListener listener;<br><br><span class="hljs-function">ros::Rate <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-number">10.0</span>)</span></span>;<br><span class="hljs-keyword">while</span> (node.<span class="hljs-built_in">ok</span>())<br>&#123;<br><span class="hljs-comment">// 获取turtle1与turtle2坐标系之间的tf数据</span><br>tf::StampedTransform transform;<br><span class="hljs-keyword">try</span><br>&#123;<br>listener.<span class="hljs-built_in">waitForTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">3.0</span>));<br>listener.<span class="hljs-built_in">lookupTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), transform);<br>&#125;<br><span class="hljs-built_in">catch</span> (tf::TransformException &amp;ex)<br>&#123;<br><span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>, ex.<span class="hljs-built_in">what</span>());<br>ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">1.0</span>).<span class="hljs-built_in">sleep</span>();<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span><br>geometry_msgs::Twist vel_msg;<br>vel_msg.angular.z = <span class="hljs-number">4.0</span> * <span class="hljs-built_in">atan2</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(), transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>());<br>vel_msg.linear.x = <span class="hljs-number">0.5</span> * <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>(), <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(), <span class="hljs-number">2</span>));<br>turtle_vel.<span class="hljs-built_in">publish</span>(vel_msg);<br><br>rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)<br><span class="hljs-keyword">add_executable</span>(turtle_tf_listener src/turtle_tf_listener.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(turtle_tf_broadcaster <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(turtle_tf_broadcaster <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws<br>catkin_make<br><span class="hljs-built_in">source</span> devel/setup.bash<br>roscore<br>rosrun turtlesim turtlesim_node<br>rosrun learning_tf turtle_tf_broadcaster __name:=turtle1_tf_broadcaster /turtle1<br>rosrun learning_tf turtle_tf_broadcaster __name:=turtle2_tf_broadcaster /turtle2<br>rosrun learning_tf turtle_tf_listener<br>rosrun turtlesim turtle_teleop_key<br></code></pre></td></tr></table></figure><ul><li>上面第6行中，<code>/turtle1</code>是输入参数，<code>__name:=turtle1_tf_broadcaster</code>是重映射</li></ul><h4 id="python-版本-7">Python 版本</h4><h5 id="tf-广播器代码-1">tf 广播器代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将请求/show_person服务，服务数据类型learning_service::Person</span><br><br><span class="hljs-keyword">import</span> roslib<br><br>roslib.load_manifest(<span class="hljs-string">&quot;learning_tf&quot;</span>)<br><span class="hljs-keyword">import</span> rospy<br><br><span class="hljs-keyword">import</span> tf<br><span class="hljs-keyword">import</span> turtlesim.msg<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_turtle_pose</span>(<span class="hljs-params">msg, turtlename</span>):<br>    br = tf.TransformBroadcaster()<br>    br.sendTransform(<br>        (msg.x, msg.y, <span class="hljs-number">0</span>),<br>        tf.transformations.quaternion_from_euler(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, msg.theta),<br>        rospy.Time.now(),<br>        turtlename,<br>        <span class="hljs-string">&quot;world&quot;</span>,<br>    )<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    rospy.init_node(<span class="hljs-string">&quot;turtle_tf_broadcaster&quot;</span>)<br>    turtlename = rospy.get_param(<span class="hljs-string">&quot;~turtle&quot;</span>)<br>    rospy.Subscriber(<br>        <span class="hljs-string">&quot;/%s/pose&quot;</span> % turtlename, turtlesim.msg.Pose, handle_turtle_pose, turtlename<br>    )<br>    rospy.spin()<br></code></pre></td></tr></table></figure><h5 id="tf-监听器代码-1">tf 监听器代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将请求/show_person服务，服务数据类型learning_service::Person</span><br><br><span class="hljs-keyword">import</span> roslib<br><br>roslib.load_manifest(<span class="hljs-string">&quot;learning_tf&quot;</span>)<br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> tf<br><span class="hljs-keyword">import</span> geometry_msgs.msg<br><span class="hljs-keyword">import</span> turtlesim.srv<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    rospy.init_node(<span class="hljs-string">&quot;turtle_tf_listener&quot;</span>)<br><br>    listener = tf.TransformListener()<br><br>    rospy.wait_for_service(<span class="hljs-string">&quot;spawn&quot;</span>)<br>    spawner = rospy.ServiceProxy(<span class="hljs-string">&quot;spawn&quot;</span>, turtlesim.srv.Spawn)<br>    spawner(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;turtle2&quot;</span>)<br><br>    turtle_vel = rospy.Publisher(<br>        <span class="hljs-string">&quot;turtle2/cmd_vel&quot;</span>, geometry_msgs.msg.Twist, queue_size=<span class="hljs-number">1</span><br>    )<br><br>    rate = rospy.Rate(<span class="hljs-number">10.0</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():<br>        <span class="hljs-keyword">try</span>:<br>            (trans, rot) = listener.lookupTransform(<br>                <span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, rospy.Time(<span class="hljs-number">0</span>)<br>            )<br>        <span class="hljs-keyword">except</span> (<br>            tf.LookupException,<br>            tf.ConnectivityException,<br>            tf.ExtrapolationException,<br>        ):<br>            <span class="hljs-keyword">continue</span><br><br>        angular = <span class="hljs-number">4</span> * math.atan2(trans[<span class="hljs-number">1</span>], trans[<span class="hljs-number">0</span>])<br>        linear = <span class="hljs-number">0.5</span> * math.sqrt(trans[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + trans[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span>)<br>        cmd = geometry_msgs.msg.Twist()<br>        cmd.linear.x = linear<br>        cmd.angular.z = angular<br>        turtle_vel.publish(cmd)<br><br>        rate.sleep()<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br>scripts/turtle_tf_broadcaster.py<br>DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br><br>catkin_install_python(PROGRAMS<br>scripts/turtle_tf_listener.py<br>DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws<br>catkin_make<br><span class="hljs-built_in">source</span> devel/setup.bash<br>roscore<br>rosrun turtlesim turtlesim_node<br>rosrun learning_tf turtle_tf_broadcaster.py __name:=turtle1_tf_broadcaster _turtle:=turtle1<br>rosrun learning_tf turtle_tf_broadcaster.py __name:=turtle2_tf_broadcaster _turtle:=turtle2<br>rosrun learning_tf turtle_tf_listener<br>rosrun turtlesim turtle_teleop_key<br></code></pre></td></tr></table></figure><h2 id="launch-启动文件">launch 启动文件</h2><h3 id="介绍">介绍</h3><ul><li><p>Launch 文件：通过 XML 文件实现多节点的配置和启动（可自动启动 ROSMaster）</p></li><li><p>launch 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;launch&gt;</code>为文件的根元素</li><li><code>&lt;node&gt;</code>为启动节点<ul><li><code>pkg</code>：节点所在功能包名称</li><li><code>type</code>：节点的可执行文件名称</li><li><code>name</code>：节点运行时的名称</li><li><code>output</code>：控制节点是否要将控制信息打印到当前终端</li><li><code>respawn</code>：控制节点挂掉后，是否进行重启</li><li><code>required</code>：是否在launch文件，该结点一定要启动起来</li><li><code>ns</code>：namespace 命名空间</li><li><code>args</code>：结点的输入参数</li><li>前三个属性是必须属性，后面的属性为可选属性</li></ul></li><li><code>&lt;param name="output_frame" value="odom" /&gt;</code><ul><li>设置 ROS 系统运行中的参数，存储在参数服务器中</li><li><code>name</code>：参数名</li><li><code>value</code>：参数值</li></ul></li><li><code>&lt;rosparam file="params.yaml" command="load" ns="params" /&gt;</code><ul><li>加载参数文件中多个参数</li></ul></li><li><code>&lt;arg name="arg-name" default="arg-value" /&gt;</code><ul><li>launch 文件内部的局部变量，仅限于 launch 文件使用</li><li><code>name</code>：参数名</li><li><code>value</code>：参数值</li><li>调用方法：<ul><li><code>&lt;param name="foo" value="$(arg arg-name)" /&gt;</code></li><li><code>&lt;node name="node" pkg="package" type="type" args="$(arg arg-name)" /&gt;</code></li></ul></li></ul></li><li><code>&lt;remap from="/turtlebot/cmd_vel" to="/cmd_vel" /&gt;</code><ul><li>重映射 ROS 计算图资源的命名</li><li><code>from</code>：原命名</li><li><code>to</code>：映射之后的命名</li></ul></li><li><code>&lt;include file="$(dirname)/other.launch" /&gt;</code><ul><li>包含其他 launch 文件，类似 C 语言中的头文件包含</li><li><code>file</code>：包含的其他 launc 文件路径</li><li>包含的文件会运行一遍</li></ul></li><li>其他详见：<ahref="https://wiki.ros.org/roslaunch/xml">https://wiki.ros.org/roslaunch/xml</a></li></ul></li></ul><h3 id="代码实现">代码实现</h3><ul><li><p>创建<code>learning_launch</code>功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_create_pkg learning_launch<br></code></pre></td></tr></table></figure><ul><li>不需要任何依赖</li></ul></li><li><p>在<code>learning_launch</code>功能包下创建文件夹<code>launch</code></p></li><li><p>创建文件<code>simple.launch</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;person_subscriber&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;talker&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;person_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;listener&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>编译：<code>catkin_make</code></li><li>启动：<code>roslaunch learning_launch simple.launch</code></li></ul></li><li><p>创建文件<code>turtlesim_parameter_config.launch</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;/turtle_number&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle_name1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Tom&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle_name2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Jerry&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">rosparam</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;$(find learning_launch)/config/param.yaml&quot;</span> <span class="hljs-attr">command</span>=<span class="hljs-string">&quot;load&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>创建文件夹：<code>catkin_ws/src/learning_launch/config</code></p></li><li><p>创建文件：<code>param.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">A:</span> <span class="hljs-number">123</span><br><span class="hljs-attr">B:</span> <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-attr">group:</span><br>  <span class="hljs-attr">C:</span> <span class="hljs-number">456</span><br>  <span class="hljs-attr">D:</span> <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><ul><li>其中<code>group</code>是命名空间</li></ul></li><li><p>启动：<code>roslaunch learning_launch turtlesim_parameter_config.launch</code></p></li><li><p>查看参数：<code>rosparam list</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/turtle_number<br>/turtlesim_node/A<br>/turtlesim_node/B<br>/turtlesim_node/group/C<br>/turtlesim_node/group/D<br>/turtlesim_node/turtle_name1<br>/turtlesim_node/turtle_name2<br></code></pre></td></tr></table></figure><ul><li>以上为运行的<code>launch</code>文件中设置的参数</li></ul></li></ul></li><li><p>创建文件<code>start_tf_demo_c++.launch</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Turtlesim Node--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teleop&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;/turtle1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle1_tf_broadcaster&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;/turtle2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle2_tf_broadcaster&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_listener&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;listener&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">roslaunch learning_launch start_tf_demo_c++.launch<br></code></pre></td></tr></table></figure></li><li><p>创建文件<code>start_tf_demo_py.launch</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Turtlesim Node--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teleop&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle1_tf_broadcaster&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster.py&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;turtle1&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle2_tf_broadcaster&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster.py&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;turtle2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_listener.py&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;listener&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">roslaunch learning_launch start_tf_demo_py.launch<br></code></pre></td></tr></table></figure></li><li><p>创建<code>turtlesim_remap.launch</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;$(find learning_launch)/launch/simple.launch&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">remap</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&quot;/turtle1/cmd_vel&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/cmd_vel&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="可视化工具">可视化工具</h1><ul><li><p>Qt 工具箱：</p><ul><li>rqt_console：日志输出工具</li><li>rqt_graph：计算图可视化工具</li><li>rqt_plot：数据绘图工具</li><li>rqt_image_view：图像渲染工具</li><li>rqt：命令行直接输入该命令，会打开所有qt工具箱的集合窗口</li></ul></li><li><p>Rviz：</p><ul><li><p>三维可视化工具</p></li><li><p>可以使用XML对机器人、周围物理等任何实物进行尺寸、质量、位置、材质、关节等属性的描述，并且在界面中呈现出来</p></li><li><p>可以通过图形化的方式，实时显示机器人传感器的信息、机器人的运动状态、周围环境的变化等信息</p></li><li><p>rviz通过机器人模型参数、机器人发布的传感信息等数据，为用户进行所有可检测信息的图形化显示。用户和开发者也可以在rviz的控制界面下，通过按钮、滑动条、数值等方式，控制机器人的行为</p></li><li><p>启动方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">roscore<br>rosrun rviz rviz<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Gazebo：</p><ul><li>强大的三维物理仿真平台</li><li>强大的物理引擎、高质量的图形渲染、方便的编程与图形接口、开源免费</li><li>应用场景：<ul><li>测试机器人算法</li><li>机器人的设计</li><li>现实场景下的回溯测试</li></ul></li></ul></li></ul><h1 id="其他学习资料">其他学习资料</h1><p><a href="http://www.autolabor.com.cn/book/ROSTutorials/">Introduction· Autolabor-ROS机器人入门课程《ROS理论与实践》零基础教程</a></p>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ROS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker指北</title>
    <link href="/2023/10/16/Docker%E6%8C%87%E5%8C%97/"/>
    <url>/2023/10/16/Docker%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="docker">Docker</h1><h2 id="快速上手">快速上手</h2><ul><li>docker镜像交流社区：<ahref="https://hub.docker.com/">https://hub.docker.com/</a></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-d</span> \<br>  <span class="hljs-literal">--name</span> mysql \<br>  <span class="hljs-literal">-p</span> <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> \<br>  <span class="hljs-literal">-e</span> TZ=Asia/Shanghai \<br>  <span class="hljs-literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="hljs-number">123</span> \<br>  mysql<br></code></pre></td></tr></table></figure><ul><li><p><code>docker run -d</code>：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</p></li><li><p><code>--name mysql</code> :给容器起个名字叫<code>mysql</code>，你可以叫别的</p></li><li><p><code>-p 3306:3306</code> : 设置端口映射。</p><ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将宿主机端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式：<code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><p><code>-e TZ=Asia/Shanghai</code> :配置容器内进程运行时的一些参数</p><ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><p><code>mysql</code> :设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像</p><ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li><li><p>官方文档：<ahref="https://docs.docker.com/">https://docs.docker.com/</a></p></li><li><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;"><strong>命令</strong></th><th style="text-align: center;"><strong>说明</strong></th><th style="text-align: center;"><strong>文档地址</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">docker pull</td><td style="text-align: center;">拉取镜像</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/pull/">dockerpull</a></td></tr><tr class="even"><td style="text-align: center;">docker push</td><td style="text-align: center;">推送镜像到DockerRegistry</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/push/">dockerpush</a></td></tr><tr class="odd"><td style="text-align: center;">docker images</td><td style="text-align: center;">查看本地镜像</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/images/">dockerimages</a></td></tr><tr class="even"><td style="text-align: center;">docker rmi</td><td style="text-align: center;">删除本地镜像</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/rmi/">dockerrmi</a></td></tr><tr class="odd"><td style="text-align: center;">docker run</td><td style="text-align: center;">创建并运行容器（不能重复创建）</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/run/">dockerrun</a></td></tr><tr class="even"><td style="text-align: center;">docker stop</td><td style="text-align: center;">停止指定容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/stop/">dockerstop</a></td></tr><tr class="odd"><td style="text-align: center;">docker start</td><td style="text-align: center;">启动指定容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/start/">dockerstart</a></td></tr><tr class="even"><td style="text-align: center;">docker restart</td><td style="text-align: center;">重新启动容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/restart/">dockerrestart</a></td></tr><tr class="odd"><td style="text-align: center;">docker rm</td><td style="text-align: center;">删除指定容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr class="even"><td style="text-align: center;">docker ps</td><td style="text-align: center;">查看容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/ps/">dockerps</a></td></tr><tr class="odd"><td style="text-align: center;">docker logs</td><td style="text-align: center;">查看容器运行日志</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/logs/">dockerlogs</a></td></tr><tr class="even"><td style="text-align: center;">docker exec</td><td style="text-align: center;">进入容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/exec/">dockerexec</a></td></tr><tr class="odd"><td style="text-align: center;">docker save</td><td style="text-align: center;">保存镜像到本地压缩文件</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/save/">dockersave</a></td></tr><tr class="even"><td style="text-align: center;">docker load</td><td style="text-align: center;">加载本地压缩文件到镜像</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/load/">dockerload</a></td></tr><tr class="odd"><td style="text-align: center;">docker inspect</td><td style="text-align: center;">查看容器详细信息</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/inspect/">dockerinspect</a></td></tr></tbody></table></li><li><p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-comment"># Docker开机自启</span><br>systemctl enable docker<br><br><span class="hljs-comment"># Docker容器开机自启</span><br>docker update <span class="hljs-literal">--restart</span>=always [容器名/容器<span class="hljs-type">id</span>]<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sudo docker exec <span class="hljs-literal">-it</span> nginx bash<br></code></pre></td></tr></table></figure></li></ul><h2 id="深入了解">深入了解</h2><ul><li><p>容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong>。</p></li><li><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机目录</strong>之间映射的桥梁。</p></li><li><p><img src="数据卷.png" alt="数据卷" /></p></li><li><p>将容器中的目录与宿主机目录关联起来，称为<strong>挂载</strong>。此时，操作宿主机中的对应文件目录，就是操作容器内的对应文件目录</p><ul><li><code>/var/lib/docker/volumes</code>这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为<code>/数据卷名/_data</code>。</li></ul></li><li><table><thead><tr class="header"><th style="text-align: center;"><strong>命令</strong></th><th style="text-align: center;"><strong>说明</strong></th><th style="text-align: center;"><strong>文档地址</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">docker volume create</td><td style="text-align: center;">创建数据卷</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/volume_create/">dockervolume create</a></td></tr><tr class="even"><td style="text-align: center;">docker volume ls</td><td style="text-align: center;">查看所有数据卷</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr class="odd"><td style="text-align: center;">docker volume rm</td><td style="text-align: center;">删除指定数据卷</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr class="even"><td style="text-align: center;">docker volume inspect</td><td style="text-align: center;">查看某个数据卷的详情</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr class="odd"><td style="text-align: center;">docker volume prune</td><td style="text-align: center;">清除数据卷</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/volume_prune/">dockervolume prune</a></td></tr></tbody></table></li><li><p>如果容器已经创建了，是没有办法再去挂载的，所以要在容器创建的时候就指明挂载。</p></li><li><p>创建容器的过程中，数据卷会自动创建。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-d</span> <span class="hljs-literal">--name</span> nginx <span class="hljs-literal">-p</span> <span class="hljs-number">80</span>:<span class="hljs-number">80</span> <span class="hljs-literal">-v</span> html:/usr/share/nginx/html nginx<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机指南</title>
    <link href="/2023/10/13/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E5%8D%97/"/>
    <url>/2023/10/13/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机各类问题解决方案">虚拟机各类问题解决方案</h1><ul><li><ahref="https://blog.csdn.net/KRISNAT/article/details/124107032">完美解决VMware安装后没有VMnet1和VMnet8的问题_虚拟机没有vmnet1和vmnet8-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/518319836">Ubuntu22.04vm虚拟机使用宿主机Clash for Windows - 知乎 (zhihu.com)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu指南</title>
    <link href="/2023/08/01/Ubuntu%E6%8C%87%E5%8D%97/"/>
    <url>/2023/08/01/Ubuntu%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<ul><li>更换国内镜像：<ahref="https://blog.csdn.net/Dr_Myst/article/details/125041187?ops_request_misc=%7B%22request%5Fid%22%3A%22169087103016800182159331%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169087103016800182159331&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125041187-null-null.142%5Ev91%5Econtrol_2,239%5Ev12%5Econtrol2&amp;utm_term=ubuntu20.04更换国内源&amp;spm=1018.2226.3001.4187">Ubuntu20.04更换国内镜像源（阿里、网易163、清华、中科大）_ubuntu国内镜像源_MidoQ的博客-CSDN博客</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式数据库总结</title>
    <link href="/2023/05/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <url>/2023/05/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第12章-绪论分布式数据库系统设计-总结">第1、2章绪论&amp;分布式数据库系统设计 总结</h1><ol type="1"><li><p>数据库根据其数据模型，可分为<code>关系型数据库(RDBMS)</code>和<code>非关系型数据库(NOSQL)</code>。根据部署架构，可分为<code>集中式数据库</code>和<code>分布式数据库</code>。</p></li><li><p><spanclass="math inline">\(E-R\)</span>模型主要包括<code>实体、属性、联系、连接</code>。</p></li><li><p>在关系<span class="math inline">\(R\)</span>中选择操作记做：<spanclass="math inline">\(\sigma_F(R)=\{r|r\in R\wedgeF(r=&#39;真&#39;)\}\)</span></p></li><li><p>已知两个关系<span class="math inline">\(R\)</span>和<spanclass="math inline">\(S\)</span>如图所示，求关系<spanclass="math inline">\(R\)</span>和<spanclass="math inline">\(S\)</span>的广义笛卡尔积。</p></li><li><p>分布式数据库物理上分散而逻辑上集中的内涵是：<code>指站点之间不是互不相关的，它们是一个逻辑整体，并由一个统一的分布式数据库管理系统进行管理。</code></p></li><li><p>分布式数据库数据分布透明性的内涵是：<code>是指用户不必关心数据是如何被逻辑分片的(数据分片透明性)，不必关心数据及其片段是否被复制及复制副本的个数（数据复制透明性）,也不必关心数据及其片段的物理位置分布的细节(数据位置造明性)，同时也不必关心局部场地上数据库支持哪种数据模型（局部数据模型透明性）。</code></p></li><li><p>数据分片有三种基本方法：<code>水平分片、垂直分片和混合分片。</code></p></li><li><p>闸述数据分片要遵守的原则：</p><ul><li><code>完备性原则</code>：要把全局关系的所有数据映射到各个片段中绝不允许有属于全局关系的数据却不属于它的任何一个片段。</li><li><code>可重构原则</code>：保证能够由同一个全局关系的各个片段来重建该全局关系，对于水平分片可用并操作重构全局关系，对于垂直分片可用连接操作重构全局关系。</li><li><code>不相交原则</code>：一个全局关系被分割后所得的各数据片段互不重叠(对水平分片) 或只包含主键重叠(对垂直分片)。</li></ul></li><li><p>数据分布的含义和方式是：<code>数据分布指分布式数据库中的数据根据需要将数据划分成逻辑片段，按某种策略把数据分片所得的逻辑片段分散地存储在各个站点上。</code>数据分布有<code>集中式、分割式、复制式和混合式。</code></p></li><li><p>数据库系统通常采用三级模式结构，是数据库系统内部系统结构，三级模式分别为：<code>外模式、概念模式、内模式。</code></p></li><li><p>分布式数据库模式结构包括：<code>全局外模式、全局概念模式、分片模式、分配模式、局部概念模式和局部内模式。</code></p></li><li><p>一个分布式数据库管理系统一般应包括四个基本功能模块分别是，<code>查询处理模块、完整性处理模块、调度处理模块和可靠性处理模块。</code></p></li><li><p>分布式数据库的数据分布独立性的含义是：<code>指用户或用户程序使用分布式数据库如同使用集中式数据库那样，不必关心全局数据的分布情况，包括全局数据的逻辑分片情况、逻辑片段的站点位置分配情况，以及各站点上数据库的数据模型等。也就是说，全局数据的逻辑分片、片段的物理位置分配、各站点数据库的数据模型等情况对用户和用户程序透明。</code></p></li><li><p>分布式数据库的分片透明性是指：<code>用户编写应用程序只对全局关系进行操作，不必考虑数据的逻辑分片，当分片模式改变时，只要改变全局概念模式到分片模式之间的映像，就不会影响用户程序，从而实现了数据分片透明性。</code></p></li><li><p>分布式数据库的位置透明性含义是：<code>位置透明性包含两种情形：一种是各片段被复制情况也称复制透明性或数据冗余透明性；另一种是片段及其各副本的站点位置分配情况。当分布式数据库具有位置透明性时，用户编写应用程序要了解全局数据的数据分片情况，但不必了解各逻辑片段的复制副本情况，也不必关心各片段及其副本的站点位置分配情况。</code></p></li><li><p>考全局关系 <span class="math inline">\(SUPPLIER(SNO, SNAME,CITY)\)</span> 被划分为两个逻辑片段<spanclass="math inline">\(S_1\)</span>和<spanclass="math inline">\(S_2\)</span>，若片段<spanclass="math inline">\(S_1\)</span>存放在站点<spanclass="math inline">\(L_1\)</span>上，而片段<spanclass="math inline">\(S_2\)</span>有一个副本，分别存放在站点<spanclass="math inline">\(L_2\)</span>和站点<spanclass="math inline">\(L_3\)</span>上。现在编写一个名为 SUPQUIRY的简单查询应用程序，它将从终端接收一个供应商号，查询该供应商号相应的供应商名，并将它显示在屏幕上。将分析这个应用在逐步减低分布透明性的不同层次上，如何来编写访问此数据库的程序。</p><ul><li><p>分片透明性：只需要考虑全局数据模型，不必考虑数据的如何分片<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">Read(terminal, $SNO);<br><span class="hljs-keyword">Select</span> SNAME <span class="hljs-keyword">into</span> $SNAME<br><span class="hljs-keyword">FROM</span> SUPPLIER<br><span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span>$SNO;<br>WRITE(terminal, $SNAME);<br></code></pre></td></tr></table></figure></p></li><li><p>位置透明性：需要考虑数据的分片，不需要考虑数据的分配<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">Read(terminal, $SNO);<br><span class="hljs-keyword">Select</span> SNAME <span class="hljs-keyword">into</span> $SNAME<br><span class="hljs-keyword">FROM</span> SUPPLIER1<br><span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span>$SNO;<br>if <span class="hljs-keyword">not</span> # FOUND <span class="hljs-keyword">then</span><br><span class="hljs-keyword">Select</span> SNAME <span class="hljs-keyword">into</span> $SNAME<br><span class="hljs-keyword">FROM</span> SUPPLIER2<br><span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span>$SNO;<br>WRITE(terminal, $SNAME);<br></code></pre></td></tr></table></figure></p></li><li><p>本地映射透明性：需要考虑数据的分配，不需要考虑本地的存储位置<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">Read(terminal, $SNO);<br><span class="hljs-keyword">Select</span> SNAME <span class="hljs-keyword">into</span> $SNAME<br><span class="hljs-keyword">FROM</span> SUPPLIER1 <span class="hljs-keyword">AT</span> SITE1<br><span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span>$SNO;<br>if <span class="hljs-keyword">not</span> # FOUND <span class="hljs-keyword">then</span><br><span class="hljs-keyword">Select</span> SNAME <span class="hljs-keyword">into</span> $SNAME<br><span class="hljs-keyword">FROM</span> SUPPLIER2 <span class="hljs-keyword">AT</span> SITE3<br><span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span>$SNO;<br>WRITE(terminal, $SNAME);<br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>分布式数据库的优点有哪些：<code>良好的可靠性和可用性</code>，<code>提高系统效率，降低通信费用</code>，<code>较大的灵活性和可伸缩性</code>，<code>经济性和保护投资</code>，<code>适应组织的分布式管理和控制</code>，<code>数据分布具有透明性和站点具有较好的自治性</code>（良、提、较、经、适、数）。</p></li><li><p>分布式数据库系统设计的两种方法分别是：<code>组合法</code>和<code>重构法</code></p></li><li><p>自顶向下设计分布式数据库的主要步骤包括：<code>需求分析、概念设计、逻辑设计、分布设计和物理设计。</code></p></li><li><p>基本水平分片是指：<code>以关系自身的属性性质为基础，执行“选择”操作，将关系分割成若干个不相交的片段。</code></p></li><li><p>导出水平分片是指：<code>从另一个关系的属性性质或水平分片推导出来。</code></p></li><li><p>垂直分片问题和垂直群集问题的区别是：<code>垂直分片的组必须只在某个键属性上重叠，其他属性不可重叠，而垂直群集的组在其他属性上也可以重叠。</code></p></li><li><p>已知<span class="math inline">\(EMP(E\)</span>#<spanclass="math inline">\(, NAME, SAL, TEL, MAGNUM, DEPT)\)</span>，假定Key：<span class="math inline">\(E\)</span>#，主要用<spanclass="math inline">\(Sa\)</span>站点查询<spanclass="math inline">\(NAME,SAL,TEL\)</span>;<spanclass="math inline">\(Sc\)</span>站点查询<spanclass="math inline">\(NAME,MAGNUM,DEPT\)</span>。给出了一个垂直分片和垂直群集。</p><ul><li>垂直分片：<span class="math inline">\(EMP1(E\)</span>#<spanclass="math inline">\(,NAME,SAL,TEL)\)</span>，<spanclass="math inline">\(EMP2(E\)</span>#<spanclass="math inline">\(,MAGNUM,DEPT)\)</span></li><li>垂直群集：<span class="math inline">\(EMP1(E\)</span>#<spanclass="math inline">\(,NAME,SAL,TEL)\)</span>，<spanclass="math inline">\(EMP2(E\)</span>#<spanclass="math inline">\(,NAME,MAGNUM,DEPT)\)</span></li></ul></li><li><p>针对分布式数据库的数据分配的方法</p><ul><li>非冗余：<code>最佳适应法</code></li><li>冗余分配的设计可选用以下两种方法的一种：<code>所有得益站点法</code>和<code>附加复制法</code>。</li></ul></li><li><p>数据库设计的步骤：</p><ul><li>自顶向下设计分布式数据库步骤：<code>需求分析、概念设计、逻辑设计、分布设计、物理设计</code></li><li>DATA-D设计步骤：<code>需求分析、概念设计、分布要求设计、全局逻辑设计、分布设计、局部逻辑设计、局部物理设计</code></li></ul></li></ol><h1id="第34章-分布式数据库的查询处理和优化分布式数据库中事务管理和恢复">第3、4章分布式数据库的查询处理和优化&amp;分布式数据库中事务管理和恢复</h1><ol type="1"><li><p>在关系代数操作中，五种基本操作为：<code>并</code>、<code>交</code>、<code>笛卡尔积</code>、<code>选择</code>、<code>投影</code></p></li><li><p>设关系R和S如下图所示，求关系R和S的连接：<spanclass="math inline">\(R\infty_{C&lt;E}S\)</span>：</p></li></ol><p><span class="math display">\[R=\\begin{array}{|c|c|c|}\hline A&amp;B&amp;C\\\hline a1&amp;b1&amp;5\\\hline a1&amp;b2&amp;6\\\hline a2&amp;b3&amp;8\\\hline a2&amp;b4&amp;12\\\hline\end{array}\ \ \ \S=\\begin{array}{|c|c|c|}\hline B&amp;E\\\hline b1&amp;3\\\hline b2&amp;7\\\hline b3&amp;10\\\hline b3&amp;2\\\hline b5&amp;2\\\hline\end{array}\\R\infty_{C&lt;E}S=\begin{array}{|c|c|c|}\hline A&amp;R.B&amp;C&amp;R.B&amp;E\\\hline a1&amp;b1&amp;5&amp;b2&amp;7\\\hline a1&amp;b1&amp;5&amp;b3&amp;10\\\hline a1&amp;b2&amp;6&amp;b2&amp;7\\\hline a1&amp;b2&amp;6&amp;b3&amp;10\\\hline a2&amp;b3&amp;8&amp;b3&amp;10\\\hline\end{array}\]</span></p><blockquote><p>各种连接操作合集：</p><ul><li>笛卡尔积：R（m个元组，n个属性），S（a个元组，b个属性），笛卡尔积结果有（a* m个元组，n + b个属性）</li><li>连接运算（<spanclass="math inline">\(\theta\)</span>连接）：从两个关系的笛卡尔积中选取属性间满足一定条件的元组，涉及到两个关系中的属性的比较。</li><li>等值连接：<spanclass="math inline">\(\theta\)</span>为“=”的连接操作</li><li>自然连接：是一种特殊的等值连接，要求两个关系中进行比较的分量必须是相同的属性组，并且要在结果中把重复的属性去掉。<ul><li>【重点】注意是去掉重复的属性，即相同属性名的属性只出现一次，而等值连接中是重复属性重复出现</li></ul></li><li>半连接：自然连接后，仅保留左关系中的属性</li></ul></blockquote><ol start="3" type="1"><li>教学数据库中，有三个全局关系：学生信息<spanclass="math inline">\(S(S\#,SNAME,AGE,SEX)\)</span>，课程设置关系<spanclass="math inline">\(C(C\#,CNAME,TEACHER)\)</span>，选课关系<spanclass="math inline">\(SC(S\#,C\#,GRADE)\)</span>，查询选修课程号为<spanclass="math inline">\(C03\)</span>的学生姓名。请写出该查询要求的其中一种的关系代数表达式，并画出对应的查询树<ul><li>关系代数表达式：<spanclass="math inline">\(\pi_{SNAME}(\sigma_{S.S\#=SC.S\# \wedgeSC.C\#=&#39;C03&#39;}(S\times SC))\)</span></li><li>查询树：<img src="image-20230530201619560.png" /></li></ul></li><li>设关系R和S如下图所示，求关系R和S的等值连接<spanclass="math inline">\(R\infty_{R.B=S.B}S\)</span></li></ol><p><span class="math display">\[R=\\begin{array}{|c|c|c|}\hline A&amp;B&amp;C\\\hline a1&amp;b1&amp;5\\\hline a1&amp;b2&amp;6\\\hline a2&amp;b3&amp;8\\\hline a2&amp;b4&amp;12\\\hline\end{array}\ \ \ \S=\\begin{array}{|c|c|c|}\hline B&amp;E\\\hline b1&amp;3\\\hline b2&amp;7\\\hline b3&amp;10\\\hline b3&amp;2\\\hline b5&amp;2\\\hline\end{array}\\R\infty_{R.B=S.B}S=\begin{array}{|c|c|c|}\hline A&amp;R.B&amp;C&amp;R.B&amp;E\\\hline a1&amp;b1&amp;5&amp;b1&amp;3\\\hline a2&amp;b2&amp;6&amp;b2&amp;7\\\hline a2&amp;b3&amp;8&amp;b3&amp;10\\\hline a2&amp;b3&amp;8&amp;b3&amp;2\\\hline\end{array}\]</span></p><ol start="5" type="1"><li>设关系R和S如下图所示，求关系R和S的半连接<spanclass="math inline">\(R\propto S\)</span></li></ol><p><span class="math display">\[R=\\begin{array}{|c|c|c|}\hline A&amp;B&amp;C\\\hline a1&amp;b1&amp;5\\\hline a1&amp;b2&amp;6\\\hline a2&amp;b3&amp;8\\\hline a2&amp;b4&amp;12\\\hline\end{array}\ \ \ \S=\\begin{array}{|c|c|c|}\hline B&amp;E\\\hline b1&amp;3\\\hline b2&amp;7\\\hline b3&amp;10\\\hline b3&amp;2\\\hline b5&amp;2\\\hline\end{array}\\R\propto S=\begin{array}{|c|c|c|}\hline A&amp;B&amp;C\\\hline a1&amp;b1&amp;5\\\hline a1&amp;b2&amp;6\\\hline a2&amp;b3&amp;8\\\hline\end{array}\]</span></p><ol start="6" type="1"><li><p>查询代价公式：</p><ul><li><p>集中式：<span class="math inline">\(QC=I/O代价 +CPU代价\)</span></p></li><li><p>分布式：<span class="math inline">\(QC=I/O代价 + CPU代价 +通信代价\)</span></p><ul><li>通信代价：<span class="math inline">\(TC(X)=C_0+C_1\timesX\)</span></li></ul></li></ul></li><li><p>分布式环境下的查询可分为三种类型：<code>局部查询</code>、<code>远程查询</code>、<code>全局查询</code></p></li><li><p>分布式查询处理的层次结构：<code>查询分解</code>（转换为关系代数表达式）、<code>数据本地化</code>（将全局关系代数表达式转换为局部的关系代数表达式）、<code>全局优化</code>（找出分片查询的最佳操纵次序，使得代价函数最小）、<code>局部优化</code>（进行局部数据查询优化）</p></li><li><p>阐述基于关系代数等价变换优化算法的基本原理：</p><ul><li><code>把查询问题转变为关系代数表达式，分析得到查询树（语法树），进行从全局到片段的变换得到基于片段上的查询树，然后利用关系代数式等价变换规则的优化算法，尽可能先执行选择和投影操作。这样，一方面可以减少其后操作的操作量，另一方面可以减少操作次数。对该查询树进行优化，从而达到查询优化的目的。</code></li></ul></li><li><p>关系代数等价变换规则</p><ul><li><img src="关系代数等价变换规则.png" alt="事务状态转换图" style="zoom: 50%;" /></li></ul></li><li><p>阐述水平分片关系优化的基本思想：</p><ul><li><code>首先，尽可能把选择条件下移到分片的限定关系处（分片条件），再把分片的限定关系与选择条件进行比较，去掉它们之间存在矛盾的相应片段，如果最后剩下一个水平片段，则重构全局关系的操作中，就可去掉“并”操作 (至少可减少“并”操作的次数)。</code></li></ul></li><li><p>阐述垂直分片关系优化的基本思想：</p><ul><li><code>把垂直分片所用到的属性集，与查询条件（查询表达式）中的投影操作所涉及的属性集相比较，去掉无关的垂直片段。如果只剩下一个垂直片段与查询有关时，去掉重构全局关系的“连接”操作 （至少可减少“连接”操作的次数）。</code></li></ul></li><li><p>请利用半连接方法来表示连接操作</p><ul><li><spanclass="math inline">\(R\infty_{A=B}S=(R\propto_{A=B}S)\infty_{A=B}S=(R\infty_{A=B}(\pi_B(S))\infty_{A=B}S)\)</span></li></ul></li><li><p>阐述采用半连接算法优化连接操作的基本思想：</p><ul><li>采用半连接操作的分布式查询处理的本质是在从一个站点传送关系到另一个站点做连接之前，先除去那些与连接无关的数据，减少做连接操作的关系中的数据量，从而减少传输的代价。因此，基于半连接算法优化连接查询，其基本原理是经半连接操作，可减少操作关系的数据量，从而减少站点间数据的传输量。所以，如果只需要一个关系中的一小部分元组参与和另一个关系连接的话,这是一个使数据传输量最小化的非常有效的方案,此时有<spanclass="math inline">\(T_{半}&lt;T_{全}\)</span>，采用半连接方案是合适的。</li></ul></li><li><p>阐述数据库中事务的概念</p><ul><li><code>事务是访问或更新各种数据项的最小逻辑工作单位；</code></li><li><code>它是一个操作序列；</code></li><li><code>它可以使数据库从一个一致状态到另外一个一致状态；</code></li><li><code>事务必须保证数据库的一致性；</code></li><li><code>事务执行期间数据库可能不一致。</code></li><li>单位、序列、状态、一致性、不一致</li></ul></li><li><p>阐述事务的ACID特性</p><ul><li><code>原子性 Atomicity：事务的操作要么全部执行，要门全部不执行，保证数据库一致性状态。</code></li><li><code>一致性 Consistency：事务的正确性、串行性。</code></li><li><code>隔离性 Isolation：单个事务的执行不应该感知其他事务的存在，因此事务执行的中间结果应该对其他事务隐藏</code></li><li><code>持久性 Durability：当事务提交后，其操作的结果将永久化</code></li></ul></li><li><p>列举分布式事务的状态</p><ul><li><code>活动：从事务开始执行的初始状态开始，事务执行中保持该状态</code></li><li><code>部分提交：事务的最后一个语句执行后进入该状态</code></li><li><code>失败：一旦发现事务不能正常执行时进入该状态</code></li><li><code>夭折：当事务被回滚后，数据库恢复到事务开始执行前的状态。事务夭折后有两种选择</code><ul><li><code>重启动 redo：仅当没有内部错误逻辑时</code></li><li><code>杀死 undo</code></li></ul></li><li><code>提交：当事务成功执行后</code></li><li><img src="事务状态转换图.png" alt="事务状态转换图" style="zoom: 50%;" /></li></ul></li><li><p>分布式事务管理器的功能有哪些</p><ul><li><code>保证分布式事务ACID特性</code></li><li><code>负责协调由该站点发出的所有分布式事务的执行</code></li><li><code>支持分布式事务执行位置透明性</code></li></ul></li><li><p>本地事务管理器 LTM 的功能</p><ul><li><code>保证本地事务 ACID 特性</code></li><li><code>维护日志</code></li><li><code>参与适当的并发控制</code></li></ul></li><li><p>分布式事务执行的控制模型有哪些</p><ul><li><code>主从模型：主、从控制器，LTM之间无通信</code><ul><li><img src="主从控制模型.png" /></li></ul></li><li><code>三角模型：LTM之间可以传递数据，避免了主从之间不必要的传输</code><ul><li><img src="三角控制模型.png" alt="三角控制模型" style="zoom: 67%;" /></li></ul></li><li><code>层次控制模型：LTM还可创建Agent，控制其他LTM执行，比前两种复杂</code><ul><li><img src="层次控制模型.png" alt="层次控制模型" style="zoom: 67%;" /></li></ul></li></ul></li><li><p>什么时候达到事务的提交点</p><ul><li><code>当事务T所有的站点数据库存取操作都已成功执行，所有操作对数据库的影响都已记录在日志中，到达提交点。</code></li></ul></li><li><p>如图所示的故障时刻和提交点的位置，以及每个事务的执行时间区间，请问那些事务需要redo，那些事务需要 undo</p><ul><li><img src="image-20230530205049811.png" alt="image-20230530205049811" style="zoom: 67%;" /></li><li>事务<span class="math inline">\(T_2\)</span>和事务<spanclass="math inline">\(T_3\)</span>需要 redo，事务<spanclass="math inline">\(T_4\)</span>需要 undo</li><li>有逻辑错误的 undo，在上一个检查点到下一个检查点之间的提交的事务redo</li></ul></li><li><p>故障类型：</p><ul><li>事务故障</li><li>系统故障</li><li>介质故障<ul><li>前三种称为站点故障</li></ul></li><li>通讯故障</li></ul></li><li><p>两阶段提交协议包括哪两个阶段</p><ul><li><code>第一阶段：表决阶段</code></li><li><code>第二阶段：执行阶段</code></li></ul></li><li><p>阐述两阶段提交协议：<code>（应该会考）</code></p><ul><li><code>表决阶段：首先，协调者给所有参与者发送“准备”消息，进入等待状态。其次，参与者收到“准备”消息后，检查是否能够提交本地事务，如能，给协调者发送“建议提交”消息，进入就绪状态；如不能，给协调者发送“建议撤销”消息，可以单方面撤销。第三，协调者收到所有参与者的消息后，他就做出是否提交事务的决定，只要有一个参与者投了反对票,就决定撤销整个事务，发送“全局撤销”消息给所有参与者，进入撒销状态，否则，就决定提交整个事务，发送“全局提交”消息给所有参与者，进入提交状态。</code></li><li><code>执行阶段：实现表决阶段的决定，提交或者撤销。</code></li></ul></li><li><p>阐述主文本更新法的思想：</p><ul><li><code>指定主副本，修改只对主副本进行，修改辅助副本时，也按在主副本上执行的更新顺序执行。</code></li></ul></li></ol><h1 id="第56章-分布式数据库中的并发控制分布式数据库中的可靠性">第5、6章分布式数据库中的并发控制&amp;分布式数据库中的可靠性</h1><ol type="1"><li>分布式数据库并发控制的作用<ul><li><code>解决多个分布式事务对数据并发执行的正确性</code></li><li><code>保证数据库的完整性和一致性</code></li></ul></li><li>什么是可串行化调度<ul><li><code>如果一个调度等价于某个串行调度，则该调度称为可串行化调度。也就是说，该调度可以通过一系列非冲突动作的交换操作使其成为可串行化调度</code></li></ul></li><li>优先图的画法</li><li>调度<span class="math inline">\(S\)</span>的可串行化的条件是<ul><li><code>当且仅当优先图中没有闭环时，调度$S$是可串行化的</code></li></ul></li><li>并发控制算法：<ul><li><code>悲观法</code><ul><li><code>加锁法</code><ul><li><code>集中式加锁</code></li><li><code>主副本加锁</code></li><li><code>分布式加锁</code></li></ul></li><li><code>时标排序法</code><ul><li><code>基本时标排序</code></li><li><code>多版本时标排序</code></li><li><code>保守时标排序</code></li></ul></li><li><code>混合法</code></li></ul></li><li><code>乐观法</code><ul><li><code>加锁法</code></li><li><code>时标排序法</code></li></ul></li></ul></li><li>分布式数据库系统并发控制机制的封锁技术中，锁的类型有哪几种？<ul><li><code>共享锁：Share 锁、S 锁或者读锁</code></li><li><code>排他锁：eXclusive 锁，X锁，拒绝锁或写锁</code></li><li><code>更新锁：Update 锁、U 锁</code></li></ul></li><li>两阶段封锁协议的两阶段指的是哪两个阶段<ul><li><code>上升阶段（成长阶段）：获取 Lock 阶段（只能获取锁）</code></li><li><code>收缩阶段（衰退阶段）：释放 Lock 阶段（只能解锁）</code></li></ul></li><li>保守两阶段封锁协议：<ul><li><code>事务在开始执行前就持有所有锁</code></li><li><code>要预先定义读集和写集</code></li></ul></li><li>严格两阶段封锁协议的特点：<ul><li><code>事务在提交或者撤销之前，绝对不释放任何一个写锁。</code></li><li><code>事务结束时（提交或者撤销），同时释放所有锁。</code></li></ul></li><li>严酷两阶段封锁协议的特点：</li></ol><ul><li><code>事务在提交或者撤销之前，绝对不释放任何一个锁。</code></li><li><code>事务结束时（提交或者撤销），同时释放所有锁。</code></li></ul><ol start="11" type="1"><li>保守和严酷的区别<ul><li><code>保守一开始就处在收缩阶段</code></li><li><code>严酷一直处于扩张阶段</code></li></ul></li><li>意向锁的类型：<ul><li><code>意向共享锁（IS）：指示在其后代节点上将会请求共享锁，即如果对某个对象加 IS 锁，表示它的后代结点拟加共享锁。</code></li><li><code>意向排他锁（IX）：指示在其后代节点上将会请求排他锁，即如果对某个对象加 IX 锁，表示它的后代结点拟加排他锁。</code></li><li><code>共享意向排他锁（SIX）：指示当前节点处在共享方式的封锁中，但是在它的某些后代节点中将会请求排他锁。即如果对一个数据对象加 SIX 锁，表示对它加共享锁，再加 IX 锁（SIX = S + IX）。例如：对某个表加 SIX 锁，则表示该事务要读整个表（加 S 锁），同时会更新个别元组（加 IX 锁）。</code></li></ul></li><li>有死锁危险时，事务退出已占有的资源，有两种方法<ul><li><code>等待-死亡（Wait-Die）：总是重启较年轻的事务（非占先权）</code><ul><li><code>老的等待、新的死亡</code></li></ul></li><li><code>受伤-等待（Wound-Wait）：年轻的等待年老的，较年轻的重启，而重启事务并不一定是目前正申请的事务（占先权）</code><ul><li><code>老的受伤（阻塞）、新的等待</code></li></ul></li></ul></li><li>保守时标法的思想是什么<ul><li><code>一种消除重启动的方法，通过缓冲年轻的操作。直至年长的操作执行完成，因此操作不会被拒绝，事务也绝不被重启动。</code></li></ul></li><li>MTTR、MTTF、MTBF、MTBR</li><li>三阶段提交协议比两阶段提交协议在协调者和参与者增加了什么状态<ul><li><code>准备提交状态</code></li></ul></li><li>分布式可靠性协议有哪些协议组成<ul><li><code>提交协议、终结协议、恢复协议</code></li></ul></li><li>提交协议的作用<ul><li><code>详细说明提交命令是如何执行的</code></li></ul></li><li>分布式系统的终结协议的作用是什么<ul><li><code>在执行一个分布式事务时，若一个站点出现故障，可以调用终止协议使得其他站点也停止该事务</code></li></ul></li><li>恢复协议：<ul><li><code>详细说明恢复命令是如何执行的</code></li></ul></li><li>阐述事务阻断的含义<ul><li><code>某个站点上本来可以终结（提交或撤销）的子事务，由于分布式数据库系统出现故障，必须等待到故障恢复（其占有的资源不释放）</code></li></ul></li><li>用自己的语言阐述三阶段提交协议<ul><li><img src="三阶段提交协议.png" alt="image-20230530205049811" style="zoom: 67%;" /></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>分布式数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典神经网络-Inception</title>
    <link href="/2023/05/26/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-Inception/"/>
    <url>/2023/05/26/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-Inception/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>Inception 是一种经典的神经网络架构，由斯坦福大学的研究团队于 2014年提出。它的设计灵感来自人类视觉系统的分层处理方式。</p><p>Inception 网络的主要创新是引入了 Inception模块，这是一种并行结构，它同时进行多种不同大小的卷积操作，并通过最大池化和平均池化来融合不同尺度的特征图。这种并行操作能够有效地捕捉不同层次的视觉特征，使网络能够在不同尺度和层次上进行信息提取。</p><p>Inception 网络的整体结构是一个深度卷积神经网络，包含多个堆叠的Inception模块和全局平均池化层。它通过多层卷积和池化操作来逐步提取和组合图像的特征，最后通过全连接层进行分类或回归任务。</p><p>Inception网络在图像分类、目标检测和图像分割等计算机视觉任务中取得了很好的效果。它的创新之处在于通过并行操作和多尺度特征融合，提高了网络对于不同尺度和层次的特征的感知能力，使得网络在处理复杂图像时更加有效和准确。</p><p>Inception 网络的成功也启发了后续的神经网络设计，例如 InceptionV2、Inception V3 等版本的网络，它们进一步优化了 Inception模块的结构和参数设置，提高了网络的性能和效率。Inception网络的创新思想对于神经网络的发展和应用具有重要的影响。</p><p>inception 是盗梦空间的英文名，最初论文的参考文献1就写了该电影</p><h1 id="inception-v1">Inception V1</h1><p>Inception V1，也被称为 GoogLeNet，是第一个采用 Inception模块的神经网络架构。它的设计目标是解决传统深度神经网络在参数数量和计算复杂度上的问题。InceptionV1 采用了多个并行的 Inception模块，其中包含了不同尺度的卷积操作和池化操作。通过多个并行分支的组合，网络能够在不同尺度上提取图像特征，并通过适当的参数共享来减少网络的参数量。此外，InceptionV1 还引入了<spanclass="math inline">\(1\times1\)</span>的卷积操作，用于减少通道维度的计算负担，并提高特征的表达能力。</p><p>GoogLeNet 在 2014 年的 ImageNet图像分类挑战中获得了优异的成绩，表明了 Inception架构在深度神经网络中的有效性和实用性。它的创新思想影响了后续的神经网络设计，并成为了许多重要模型的基础。</p><p>GoogLeNet 中最后五个字母是为了致敬 LeNet 网络</p><p>用不同大小的卷积核对图像进行卷积，把卷积得到的结果concatenate结合在一起</p><p>inception模块</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>conda指南</title>
    <link href="/2023/05/25/conda%E6%8C%87%E5%8D%97/"/>
    <url>/2023/05/25/conda%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="conda-使用教程">Conda 使用教程</h1><h2 id="扫盲">扫盲</h2><p>安装教程：https://zhuanlan.zhihu.com/p/459601766</p><p>Anaconda 是专注于数据分析的 Python 发行版本，包含了 conda、Python 等190 多个科学包及其依赖项。</p><h2 id="命令">命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">conda list<span class="hljs-comment"># 查看环境中的所有包</span><br>conda install XXX<span class="hljs-comment"># 安装 XXX 包</span><br>conda remove XXX<span class="hljs-comment"># 删除 XXX 包</span><br>conda env list<span class="hljs-comment"># 列出所有环境</span><br>conda create <span class="hljs-literal">-n</span> XXX<span class="hljs-comment"># 创建名为 XXX 的环境，-n 为 -name</span><br>conda create <span class="hljs-literal">-n</span> env_name jupyter notebook<span class="hljs-comment"># 创建虚拟环境，同时将jupyter notebook加入环境中</span><br>activate noti / source activate noti<span class="hljs-comment"># 启用/激活环境</span><br>conda env remove <span class="hljs-literal">--name</span> noti<span class="hljs-comment"># 删除指定环境</span><br>deactivate / source deactivate<span class="hljs-comment"># 退出环境</span><br>jupyter notebook<span class="hljs-comment"># 打开Jupyter Notebook</span><br>conda config <span class="hljs-literal">--remove-key</span> channels<span class="hljs-comment"># 换回默认源</span><br></code></pre></td></tr></table></figure><h2 id="配置清华镜像">配置清华镜像</h2><p>https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch快速入门</title>
    <link href="/2023/05/13/Pytorch%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2023/05/13/Pytorch%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>Pytorch官方教程：<a href="https://pytorch.org/tutorials/">Welcome toPyTorch Tutorials — PyTorch Tutorials 2.0.1+cu117 documentation</a></p><h1 id="张量-tensors">张量 TENSORS</h1><p>张量是一种特殊的数据结构，与数组和矩阵非常相似。在 PyTorch中，我们使用张量对模型的输入和输出以及模型的参数进行编码。</p><p>张量类似于NumPy 的ndarrays，不同之处在于张量可以在 GPU或其他硬件加速器上运行。事实上，张量和 NumPy数组通常可以共享相同的底层内存，从而无需复制数据。张量也针对自动微分进行了优化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><h2 id="初始化张量">初始化张量</h2><h3 id="直接来自数据">直接来自数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">data = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br>x_data = torch.tensor(data)<br></code></pre></td></tr></table></figure><h3 id="来自-numpy-数组">来自 NumPy 数组</h3><p>可以从NumPy数据创建张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np_array = np.array(data)<br>x_np = torch.from_numpy(np_array)<br></code></pre></td></tr></table></figure><h3 id="从另一个张量">从另一个张量</h3><p>除非明确覆盖，否则新张量保留参数张量的属性（形状、数据类型）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x_ones = torch.ones_like(x_data) <span class="hljs-comment"># retains the properties of x_data</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Ones Tensor: \n <span class="hljs-subst">&#123;x_ones&#125;</span> \n&quot;</span>)<br><br>x_rand = torch.rand_like(x_data, dtype=torch.<span class="hljs-built_in">float</span>) <span class="hljs-comment"># overrides the datatype of x_data</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Random Tensor: \n <span class="hljs-subst">&#123;x_rand&#125;</span> \n&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="使用随机值或常数值">使用随机值或常数值</h3><p><code>shape</code>是张量维度的元组。在下面的函数中，它决定了输出张量的维数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">shape = (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,)<br>rand_tensor = torch.rand(shape)<br>ones_tensor = torch.ones(shape)<br>zeros_tensor = torch.zeros(shape)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Random Tensor: \n <span class="hljs-subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Ones Tensor: \n <span class="hljs-subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Zeros Tensor: \n <span class="hljs-subst">&#123;zeros_tensor&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="张量的属性">张量的属性</h2><p>张量属性描述了它们的形状、数据类型和存储它们的设备。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.rand(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Shape of tensor: <span class="hljs-subst">&#123;tensor.shape&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Datatype of tensor: <span class="hljs-subst">&#123;tensor.dtype&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Device tensor is stored on: <span class="hljs-subst">&#123;tensor.device&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>tensor.device</code>：说明该张量存储在哪个设备上，有cpu等</p><h2 id="张量运算">张量运算</h2><p>具体运算：https://pytorch.org/docs/stable/torch.html</p><p>此处仅简要了解</p><p>以上张量运算的每一步都可以再GPU上运行（速度通常高于CPU）、</p><p>默认情况下，张量是在 CPU 上创建的。我们需要使用方法将张量显式移动到GPU <code>.to</code>（在检查 GPU可用性之后）。请记住，跨设备复制大型张量在时间和内存方面可能会很昂贵！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将 tensor 移动到GPU，如果GPU可用的话</span><br><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>    tensor = tensor.to(<span class="hljs-string">&quot;cuda&quot;</span>)<br></code></pre></td></tr></table></figure><p>类似于 numpy 的索引和切片操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.ones(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;First row: <span class="hljs-subst">&#123;tensor[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;First column: <span class="hljs-subst">&#123;tensor[:, <span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Last column: <span class="hljs-subst">&#123;tensor[..., -<span class="hljs-number">1</span>]&#125;</span>&quot;</span>)<br>tensor[:,<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(tensor)<br></code></pre></td></tr></table></figure><p>连接张量，可以使用torch.cat沿着给定维度连接一系列张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = torch.cat([tensor, tensor, tensor], dim=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(t1)<br></code></pre></td></tr></table></figure><h3 id="算术运算">算术运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以下 y1, y2, y3 有相同的值</span><br>y1 = tensor @ tensor.T<br>y2 = tensor.matmul(tensor.T)<br><br>y3 = torch.rand_like(y1)<br>torch.matmul(tensor, tensor.T, out=y3)<br><br><br><span class="hljs-comment"># 以下 z1, z2, z3 有相同的值</span><br>z1 = tensor * tensor<br>z2 = tensor.mul(tensor)<br><br>z3 = torch.rand_like(tensor)<br>torch.mul(tensor, tensor, out=z3)<br></code></pre></td></tr></table></figure><p>对于单元素张量，可以取其值并转化为 python 中的基本元素类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">agg = tensor.<span class="hljs-built_in">sum</span>()<br>agg_item = agg.item()<br><span class="hljs-built_in">print</span>(agg_item, <span class="hljs-built_in">type</span>(agg_item))<br></code></pre></td></tr></table></figure><h3 id="就地操作">就地操作</h3><p>如果需要将运算结果存储其中一个操作数中，则在运算后加上下划线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;tensor&#125;</span> \n&quot;</span>)<br>tensor.add_(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(tensor)<br></code></pre></td></tr></table></figure><blockquote><p>就地操作可以节省一些内存，但在计算导数时可能会出现问题，因为会立即丢失历史记录。因此，不鼓励使用它们。</p></blockquote><h2 id="桥接-numpy">桥接 NumPy</h2><p>CPU 和 NumPy数组上的张量可以共享它们的底层内存位置，改变一个就会改变另一个。</p><h3 id="张量到-numpy-数组">张量到 NumPy 数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">t = torch.ones(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t: <span class="hljs-subst">&#123;t&#125;</span>&quot;</span>)<br>n = t.numpy()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n: <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>对张量进行操作，即对 Numpy 数组进行操作</p><h3 id="numpy-数组到-tensor">NumPy 数组到 Tensor</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">n = np.ones(<span class="hljs-number">5</span>)<br>t = torch.from_numpy(n)<br></code></pre></td></tr></table></figure><h1 id="数据集和数据加载器">数据集和数据加载器</h1><p>处理数据样本的代码可能会变得混乱且难以维护；理想情况下，我们希望数据集代码与模型训练代码分离，以提高可读性和模块化。PyTorch提供了两种数据原语：<code>torch.utils.data.DataLoader</code>和<code>torch.utils.data.Dataset</code>允许使用预加载的数据集以及自己的数据。<code>Dataset</code>存储样本及其相应的标签，<code>DataLoader</code>将一个迭代器包装在<code>Dataset</code> 周围，以便轻松访问样本。</p><p>PyTorch 域库提供了许多预加载的数据集（例如 FashionMNIST），它们是<code>torch.utils.data.Dataset</code>的子类，并实现特定数据的特定功能。它们可用于对模型进行原型设计和基准测试。您可以在这里找到它们：<ahref="https://pytorch.org/vision/stable/datasets.html">图像数据集</a>、<a href="https://pytorch.org/text/stable/datasets.html">文本数据集</a>和<ahref="https://pytorch.org/audio/stable/datasets.html">音频数据集</a></p><h2 id="加载数据集">加载数据集</h2><p>下面是一个如何从 <code>TorchVision</code> 加载<ahref="https://research.zalando.com/project/fashion_mnist/fashion_mnist/">Fashion-MNIST</a>数据集的示例。Fashion-MNIST是 Zalando 的文章图像数据集，由 60000 个训练示例和 10000个测试示例组成。每个示例包含一个 28×28 的灰度图像和来自 10个类别之一的关联标签。</p><p>我们使用以下参数加载<ahref="https://pytorch.org/vision/stable/datasets.html#fashion-mnist">FashionMNIST数据集：</a></p><ul><li><code>root</code>是存储训练/测试数据的路径，</li><li><code>train</code>指定训练或测试数据集，</li><li><code>download=True</code>如果在<code>root</code>处不可用，则从Internet 下载数据。</li><li><code>transform</code>并<code>target_transform</code>指定特征和标签转换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> torchvision.transforms <span class="hljs-keyword">import</span> ToTensor<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>training_data = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">True</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor()<br>)<br><br>test_data = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">False</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor()<br>)<br></code></pre></td></tr></table></figure><h2 id="迭代和可视化数据集">迭代和可视化数据集</h2><p>我们可以像列表一样手动索引<code>Datasets</code>：<code>training_data[index]</code>。我们使用<code>matplotlib</code>可视化训练数据中的一些样本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">figure = plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br>cols, rows = <span class="hljs-number">3</span>, <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, cols * rows + <span class="hljs-number">1</span>):<br>    <span class="hljs-comment"># torch.randint()函数中，size参数不可省略，并且生成一维数组时，需要在后面加上逗号，否则会报错。</span><br>    sample_idx = torch.randint(<span class="hljs-built_in">len</span>(training_data), size=(<span class="hljs-number">1</span>,)).item()<br>    img, label = training_data[sample_idx]<br>    figure.add_subplot(rows, cols, i)<br>    plt.title(labels_map[label])<br>    <span class="hljs-comment"># 关闭坐标轴</span><br>    plt.axis(<span class="hljs-string">&quot;off&quot;</span>)<br>    <span class="hljs-comment"># img.squeeze() 去掉维数为 1 的维度</span><br>    plt.imshow(img.squeeze(), cmap=<span class="hljs-string">&quot;gray&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="创建自定义-dataset">创建自定义 Dataset</h2><p>自定义的数据集类必须实现三个函数：<em>__int__</em>,<em>__len__</em>,<em>__getitem__</em>，看看这个实现；FashionMNIST 图像存储在目录 img_dir 中，它们的标签分别存储在 CSV 文件annotations_file 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> torchvision.io <span class="hljs-keyword">import</span> read_image<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomImageDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-comment"># __init__ 函数在实例化 Dataset 对象时运行一次。 我们初始化包含图像、注释文件和两个转换的目录（下一节将详细介绍）。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, annotations_file, img_dir, transform=<span class="hljs-literal">None</span>, target_transform=<span class="hljs-literal">None</span></span>):<br>        self.img_labels = pd.read_csv(annotations_file)<br>        self.img_dir = img_dir<br>        self.transform = transform<br>        self.target_transform = target_transform<br><span class="hljs-comment"># __len__ 函数返回数据集中的样本数。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.img_labels)<br><span class="hljs-comment"># __getitem__ 函数从给定索引 idx 的数据集中加载并返回样本。 根据索引，它识别图像在磁盘上的位置，使用 read_image 将其转换为张量，从 self.img_labels 中的 csv 数据中检索相应的标签，调用它们的转换函数（如果适用），并返回张量图像和元组中的相应标签。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, <span class="hljs-number">0</span>])<br>        image = read_image(img_path)<br>        label = self.img_labels.iloc[idx, <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> self.transform:<br>            image = self.transform(image)<br>        <span class="hljs-keyword">if</span> self.target_transform:<br>            label = self.target_transform(label)<br>        <span class="hljs-keyword">return</span> image, label<br></code></pre></td></tr></table></figure><h2 id="准备数据以使用-dataloaders-进行训练">准备数据以使用 DataLoaders进行训练</h2><p>数据集检索我们数据集的特征并一次标记一个样本。在训练模型时，我们通常希望以“小批量”传递样本，在每个时期重新调整数据以减少模型过度拟合，并使用Python 的多处理来加速数据检索。</p><p>DataLoader 是一个可迭代对象，它通过一个简单的 API为我们抽象了这种复杂性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br>train_dataloader = DataLoader(training_data, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)<br>test_dataloader = DataLoader(test_data, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="遍历-dataloader">遍历 DataLoader</h2><p>我们已经将该数据集加载到 DataLoader 中，并且可以根据需要迭代数据集。下面的每次迭代都会返回一批 train_features 和 train_labels（分别包含batch_size=64 个特征和标签）。 因为我们指定了shuffle=True，所以在我们遍历所有批次之后，数据将被打乱（为了更细粒度地控制数据加载顺序，请查看采样器）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 展示 image 和 label.</span><br><span class="hljs-comment"># 将 train_dataloader 转换成迭代器，然后取第一个值</span><br>train_features, train_labels = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(train_dataloader))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Feature batch shape: <span class="hljs-subst">&#123;train_features.size()&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Labels batch shape: <span class="hljs-subst">&#123;train_labels.size()&#125;</span>&quot;</span>)<br>img = train_features[<span class="hljs-number">0</span>].squeeze()<br>label = train_labels[<span class="hljs-number">0</span>]<br>plt.imshow(img, cmap=<span class="hljs-string">&quot;gray&quot;</span>)<br>plt.show()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Label: <span class="hljs-subst">&#123;label&#125;</span>&quot;</span>)<br><span class="hljs-comment"># output：</span><br><span class="hljs-comment"># Feature batch shape: torch.Size([64, 1, 28, 28])</span><br><span class="hljs-comment"># Labels batch shape: torch.Size([64])</span><br><span class="hljs-comment"># Label: 7</span><br></code></pre></td></tr></table></figure><h1 id="转换-transform">转换 TRANSFORM</h1><p>数据并不总是以训练机器学习算法所需的最终处理形式出现。 我们使用转换transforms 对数据进行一些操作，使其适合训练。</p><p>所有 TorchVision 数据集都有两个参数 -transform 修改特征和target_transform 修改标签 - 接受包含转换逻辑的可调用文件。torchvision.transforms 模块提供了几种开箱即用的常用转换。</p><p>FashionMNIST 特征是 PIL 图像格式，标签是整数。对于训练，我们需要将特征作为归一化张量，并将标签作为 One-Hot 编码张量。为了进行这些转换，我们使用了 ToTensor 和 Lambda。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> torchvision.transforms <span class="hljs-keyword">import</span> ToTensor, Lambda<br><br>ds = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">True</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor(),<br>    target_transform=Lambda(<span class="hljs-keyword">lambda</span> y: torch.zeros(<span class="hljs-number">10</span>, dtype=torch.<span class="hljs-built_in">float</span>).scatter_(<span class="hljs-number">0</span>, torch.tensor(y), <span class="hljs-number">1</span>))<br>)<br></code></pre></td></tr></table></figure><h2 id="totensor">ToTensor()</h2><p>ToTensor 将 PIL 图像或 NumPy ndarray 转换为 FloatTensor。 并在 [0.,1.] 范围内缩放图像的像素强度值</p><h2 id="lambda-transforms">Lambda Transforms</h2><p>Lambda 转换应用任何用户定义的 lambda 函数。在这里，我们定义了一个函数来将整数转换为单热编码张量。它首先创建一个大小为 10 的零张量（我们数据集中标签的数量）并调用scatter_，它在标签 y 给定的索引上分配一个 value=1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target_transform=Lambda(<span class="hljs-keyword">lambda</span> y: torch.zeros(<span class="hljs-number">10</span>, dtype=torch.<span class="hljs-built_in">float</span>).scatter_(<span class="hljs-number">0</span>, torch.tensor(y), <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h1 id="构建神经网络">构建神经网络</h1><p>神经网络由对数据执行操作的 <code>层/模块</code> 组成。 torch.nn命名空间提供了构建自己的神经网络所需的所有构建块。 PyTorch中的每个模块都是 nn.Module 的子类。神经网络本身就是一个由其他模块（层）组成的模块。这种嵌套结构允许轻松构建和管理复杂的体系结构。</p><p>在接下来的部分中，我们将构建一个神经网络来对 FashionMNIST数据集中的图像进行分类。</p><p>首先我们导入如下库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets, transforms<br></code></pre></td></tr></table></figure><h2 id="获取训练设备">获取训练设备</h2><p>如果可用，我们希望能够在 GPU 或 MPS 等硬件加速器上训练我们的模型。让我们检查一下 torch.cuda 或 torch.backends.mps 是否可用，否则我们使用CPU。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">device = (<br>    <span class="hljs-string">&quot;cuda&quot;</span><br>    <span class="hljs-keyword">if</span> torch.cuda.is_available()<br>    <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;mps&quot;</span><br>    <span class="hljs-keyword">if</span> torch.backends.mps.is_available()<br>    <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span><br>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Using <span class="hljs-subst">&#123;device&#125;</span> device&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="定义类">定义类</h2><p>我们通过子类化 <code>nn.Module</code> 来定义我们的神经网络，并在<code>__init__</code> 中初始化神经网络层。 每个 nn.Module 子类都在forward 方法中实现对输入数据的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NeuralNetwork</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 将数据连续的维度范围展成张量，torch.nn.Flatten(start_dim=1, end_dim=-1)，注意维度从0开始，0维度是各样本值</span><br>        self.flatten = nn.Flatten()<br>        <br>        self.linear_relu_stack = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">28</span>*<span class="hljs-number">28</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">10</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.flatten(x)<br>        logits = self.linear_relu_stack(x)<br>        <span class="hljs-keyword">return</span> logits<br></code></pre></td></tr></table></figure><p>我们创建一个 <code>NeuralNetwork</code>的实例，并将其移动到<code>device</code>上，并打印其结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">model = NeuralNetwork().to(device)<br><span class="hljs-built_in">print</span>(model)<br><br><span class="hljs-comment"># output：</span><br><span class="hljs-comment"># NeuralNetwork(</span><br><span class="hljs-comment">#   (flatten): Flatten(start_dim=1, end_dim=-1)</span><br><span class="hljs-comment">#   (linear_relu_stack): Sequential(</span><br><span class="hljs-comment">#     (0): Linear(in_features=784, out_features=512, bias=True)</span><br><span class="hljs-comment">#     (1): ReLU()</span><br><span class="hljs-comment">#     (2): Linear(in_features=512, out_features=512, bias=True)</span><br><span class="hljs-comment">#     (3): ReLU()</span><br><span class="hljs-comment">#     (4): Linear(in_features=512, out_features=10, bias=True)</span><br><span class="hljs-comment">#   )</span><br><span class="hljs-comment"># )</span><br></code></pre></td></tr></table></figure><blockquote><p>要使用该模型，我们将输入数据传递给它。这将执行模型的<code>forward</code>以及一些后台操作。 不要直接调用<code>model.forward()</code> ！</p></blockquote><p>在输入上调用模型会返回一个二维张量，其中 dim=0 对应于每个类别的 10个原始预测值的每个输出，dim=1 对应于每个输出的各个值。 我们通过nn.Softmax 模块的实例传递它来获得预测概率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X = torch.rand(<span class="hljs-number">1</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, device=device)<br>logits = model(X)<br>pred_probab = nn.Softmax(dim=<span class="hljs-number">1</span>)(logits)<br>y_pred = pred_probab.argmax(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Predicted class: <span class="hljs-subst">&#123;y_pred&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="model-layers">Model Layers</h2><p>让我们分解 FashionMNIST 模型中的层。 为了说明这一点，我们将取一个包含3 张大小为 28x28的图像的小批量样本，看看当我们将它传递给网络时会发生什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">input_image = torch.rand(<span class="hljs-number">3</span>,<span class="hljs-number">28</span>,<span class="hljs-number">28</span>)<br><span class="hljs-built_in">print</span>(input_image.size())<br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># torch.Size([3, 28, 28])</span><br></code></pre></td></tr></table></figure><h3 id="nn.flatten">nn.Flatten</h3><p>我们初始化 <code>nn.Flatten</code> 层以将每个 2D 28x28 图像转换为 784个像素值的连续数组（保持小批量维度（dim=0））。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">flatten = nn.Flatten()<br>flat_image = flatten(input_image)<br><span class="hljs-built_in">print</span>(flat_image.size())<br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># torch.Size([3, 784])</span><br></code></pre></td></tr></table></figure><h3 id="nn.linear">nn.Linear</h3><p>线性层是一个模块，它使用其存储的权重和偏差对输入应用线性变换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">layer1 = nn.Linear(in_features=<span class="hljs-number">28</span>*<span class="hljs-number">28</span>, out_features=<span class="hljs-number">20</span>)<br>hidden1 = layer1(flat_image)<br><span class="hljs-built_in">print</span>(hidden1.size())<br><span class="hljs-comment"># output：</span><br><span class="hljs-comment"># torch.Size([3, 20])</span><br></code></pre></td></tr></table></figure><h3 id="nn.relu">nn.ReLU</h3><p>非线性激活是在模型的输入和输出之间创建复杂映射的原因。它们在线性变换之后应用以引入非线性，帮助神经网络学习各种各样的现象。</p><p>在此模型中，我们在线性层之间使用nn.ReLU，但还有其他激活在您的模型中引入非线性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Before ReLU: <span class="hljs-subst">&#123;hidden1&#125;</span>\n\n&quot;</span>)<br>hidden1 = nn.ReLU()(hidden1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;After ReLU: <span class="hljs-subst">&#123;hidden1&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="nn.sequential">nn.Sequential</h3><p>nn.Sequential 是一个有序的模块容器。数据按照定义的相同顺序通过所有模块。 你可以使用顺序容器来组合一个像<code>seq_modules</code> 这样的快速网络。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">seq_modules = nn.Sequential(<br>    flatten,<br>    layer1,<br>    nn.ReLU(),<br>    nn.Linear(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>)<br>)<br>input_image = torch.rand(<span class="hljs-number">3</span>,<span class="hljs-number">28</span>,<span class="hljs-number">28</span>)<br>logits = seq_modules(input_image)<br></code></pre></td></tr></table></figure><h3 id="nn.softmax">nn.Softmax</h3><p>神经网络的最后一个线性层返回 logits - [-infty, infty] 中的原始值 -传递给 nn.Softmax 模块。 logits 被缩放为值 [0,1]，表示模型对每个类别的预测概率。 dim 参数表示值必须总和为 1的维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">softmax = nn.Softmax(dim=<span class="hljs-number">1</span>)<br>pred_probab = softmax(logits)<br></code></pre></td></tr></table></figure><h2 id="模型参数">模型参数</h2><p>神经网络中的许多层都是参数化的，即具有在训练期间优化的相关权重和偏差。子类化 nn.Module 会自动跟踪模型对象中定义的所有字段，并使用模型的parameters() 或 named_parameters() 方法使所有参数可访问。</p><p>在此示例中，我们遍历每个参数，并打印其大小和值的预览。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Model structure: <span class="hljs-subst">&#123;model&#125;</span>\n\n&quot;</span>)<br><br><span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> model.named_parameters():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Layer: <span class="hljs-subst">&#123;name&#125;</span> | Size: <span class="hljs-subst">&#123;param.size()&#125;</span> | Values : <span class="hljs-subst">&#123;param[:<span class="hljs-number">2</span>]&#125;</span> \n&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="使用torch.autograd自动微分">使用TORCH.AUTOGRAD自动微分</h1><p>在训练神经网络时，最常用的算法是反向传播。在该算法中，参数（模型权重）根据损失函数相对于给定参数的梯度进行调整。</p><p>为了计算这些梯度，PyTorch 有一个名为 torch.autograd 的内置微分引擎。它支持自动计算任何计算图的梯度。</p><p>考虑最简单的一层神经网络，具有输入 x、参数 w 和 b，以及一些损失函数。它可以通过以下方式在 PyTorch 中定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br>x = torch.ones(<span class="hljs-number">5</span>)  <span class="hljs-comment"># input tensor</span><br>y = torch.zeros(<span class="hljs-number">3</span>)  <span class="hljs-comment"># expected output</span><br>w = torch.randn(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.randn(<span class="hljs-number">3</span>, requires_grad=<span class="hljs-literal">True</span>)<br>z = torch.matmul(x, w) + b<br>loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)<br></code></pre></td></tr></table></figure><h2 id="张量函数计算图">张量、函数、计算图</h2><p>以上代码定义了如下计算图：</p><figure><img src="https://pytorch.org/tutorials/_images/comp-graph.png"alt="计算图" /><figcaption aria-hidden="true">计算图</figcaption></figure><p>在这个网络中，w 和 b 是我们需要优化的参数。因此，我们需要能够计算关于这些变量的损失函数的梯度。为此，我们设置了这些张量的requires_grad 属性。</p><blockquote><p>NOTE：</p><p>您可以在创建张量时设置 requires_grad 的值，或者稍后使用x.requires_grad_(True) 方法。</p></blockquote><p>我们应用于张量以构造计算图的函数实际上是 Function 类的对象。该对象知道如何在正向计算函数，以及如何在反向传播步骤中计算其导数。对反向传播函数的引用存储在张量的 grad_fn 属性中。您可以在文档中找到有关功能的更多信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Gradient function for z = <span class="hljs-subst">&#123;z.grad_fn&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Gradient function for loss = <span class="hljs-subst">&#123;loss.grad_fn&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="计算导数">计算导数</h2><p>为了优化神经网络中参数的权重，我们需要计算损失函数关于参数的导数，即，我们需要在一些固定值x和y下计算<spanclass="math inline">\(\frac{\partial{loss}}{\partial{w}}\)</span>和<spanclass="math inline">\(\frac{\partial loss}{\partialb}\)</span>。为了计算这些导数，我们调用 loss.backward()，然后从 w.grad和 b.grad 中检索值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">loss.backward()<br><span class="hljs-built_in">print</span>(w.grad)<br><span class="hljs-built_in">print</span>(b.grad)<br></code></pre></td></tr></table></figure><blockquote><p>NOTE：</p><ul><li><p>我们只能获取计算图的叶节点的 grad 属性，这些节点的 requires_grad属性设置为 True。 对于我们图表中的所有其他节点，梯度将不可用。</p></li><li><p>出于性能原因，我们只能在给定的图上使用一次反向执行梯度计算。如果我们需要对同一个图进行多次反向调用，我们需要将 retain_graph=True传递给反向调用。</p></li></ul></blockquote><h2 id="禁用梯度跟踪">禁用梯度跟踪</h2><p>默认情况下，所有具有 requires_grad=True的张量都在跟踪它们的计算历史并支持梯度计算。然而，有些情况下我们不需要这样做，例如，当我们已经训练了模型并且只想将其应用于一些输入数据时，即我们只想通过网络进行前向计算。我们可以通过用 torch.no_grad() 块包围我们的计算代码来停止跟踪计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">z = torch.matmul(x, w)+b<br><span class="hljs-built_in">print</span>(z.requires_grad)<br><span class="hljs-comment"># True</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    z = torch.matmul(x, w)+b<br><span class="hljs-built_in">print</span>(z.requires_grad)<br><span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><p>实现相同结果的另一种方法是在张量上使用 detach() 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">z = torch.matmul(x, w)+b<br>z_det = z.detach()<br><span class="hljs-built_in">print</span>(z_det.requires_grad)<br><span class="hljs-comment"># Fasle</span><br></code></pre></td></tr></table></figure><p>您可能想要禁用梯度跟踪的原因有：</p><ul><li>将神经网络中的某些参数标记为冻结参数。</li><li>在只进行前向传递时加快计算速度，因为对不跟踪梯度的张量进行计算会更有效率。</li></ul><h2 id="有关计算图的更多信息">有关计算图的更多信息</h2><p>从概念上讲，autograd 在由 Function 对象组成的有向无环图 (DAG)中记录数据（张量）和所有执行的操作（以及生成的新张量）。 在这个 DAG中，叶子是输入张量，根是输出张量。通过从根到叶跟踪此图，您可以使用链式法则自动计算梯度。</p><p>在一个正向传递中，autograd 同时做了两件事情</p><ul><li>运行请求的操作来计算结果张量</li><li>在 DAG 中维护操作的梯度函数。</li></ul><p>当在 DAG 根上调用<code>.backward()</code>时，后向传递开始。</p><ul><li>计算每个<code>.grad_fn</code>的梯度</li><li>将它们积累在各自张量的<code>.grad</code>属性中</li><li>使用链式法则，一直传播至叶张量</li></ul><blockquote><p>NOTE：</p><p>PyTorch 中的 DAG 是动态的 在每次 .backward() 调用之后，autograd开始填充一个新图。 这正是允许您在模型中使用控制流语句的原因；如果需要，您可以在每次迭代时更改形状、大小和操作。</p></blockquote><h2 id="选读张量梯度和雅克比积">选读：张量梯度和雅克比积</h2><p>在许多情况下，我们有一个标量损失函数，我们需要计算关于某些参数的梯度。但是，有些情况下输出函数是任意张量。 在这种情况下，PyTorch允许您计算所谓的雅可比积，而不是实际的梯度。</p><p>对于一个向量函数<spanclass="math inline">\(\vec{y}=f(\vec{x})\)</span>，其中<spanclass="math inline">\(\vec{x}=&lt;x_1,\cdots,x_n&gt;\)</span>并且<spanclass="math inline">\(\vec{y}=&lt;y_1,\cdots,y_m&gt;\)</span>，<spanclass="math inline">\(\vec{y}\)</span>关于<spanclass="math inline">\(\vec{x}\)</span>的梯度为以下雅克比矩阵： <spanclass="math display">\[J=\left \{\begin{matrix}\frac{\partial y_1}{\partial x_1}&amp;\cdots&amp;\frac{\partialy_1}{\partial x_n}\\\vdots&amp;\ddots&amp;\vdots\\\frac{\partial y_m}{\partial x_1}&amp;\cdots&amp;\frac{\partialy_m}{\partial x_n}\end{matrix}\right \}\]</span> PyTorch 允许计算<spanclass="math inline">\(Jacobian\_Product\_v^T\)</span>，而不是其本身。</p><p><span class="math inline">\(J\)</span>对于给定输入向量<spanclass="math inline">\(v=(v_1,\dots,v_m)\)</span>，这是通过以<spanclass="math inline">\(v\)</span>作为参数调用<code>backward</code>来实现的。<spanclass="math inline">\(v\)</span>的大小应该与我们要计算乘积的原始张量的大小相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">inp = torch.eye(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, requires_grad=<span class="hljs-literal">True</span>)<br>out = (inp+<span class="hljs-number">1</span>).<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).t()<br>out.backward(torch.ones_like(out), retain_graph=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;First call\n<span class="hljs-subst">&#123;inp.grad&#125;</span>&quot;</span>)<br>out.backward(torch.ones_like(out), retain_graph=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nSecond call\n<span class="hljs-subst">&#123;inp.grad&#125;</span>&quot;</span>)<br>inp.grad.zero_()<br>out.backward(torch.ones_like(out), retain_graph=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nCall after zeroing gradients\n<span class="hljs-subst">&#123;inp.grad&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">First call<br>tensor([[<span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>]])<br><br>Second call<br>tensor([[<span class="hljs-number">8.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>],<br>        [<span class="hljs-number">4.</span>, <span class="hljs-number">8.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>],<br>        [<span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">8.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>],<br>        [<span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">8.</span>, <span class="hljs-number">4.</span>]])<br><br>Call after zeroing gradients<br>tensor([[<span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>]])<br></code></pre></td></tr></table></figure><p>请注意，当我们使用相同的参数第二次调用<code>backward</code>时，梯度的值是不同的。发生这种情况是因为在进行反向传播时，PyTorch会累积梯度，即将计算出的梯度值添加到计算图所有叶节点的 grad 属性中。如果你想计算合适的梯度，你需要先将 grad 属性清零。在现实生活中的训练中，优化器可以帮助我们做到这一点。</p><blockquote><p>NOTE:</p><p>以前我们调用不带参数的 <code>backward()</code> 函数。这本质上等同于调用<code>backward(torch.tensor(1.0))</code>，这是在标量值函数的情况下计算梯度的有用方法，例如神经网络训练期间的损失。</p></blockquote><h1 id="优化模型参数">优化模型参数</h1><p>现在我们有了模型和数据，是时候通过优化我们的数据参数来训练、验证和测试我们的模型了。训练模型是一个迭代过程；在每次迭代中，模型对输出进行猜测，计算其猜测中的误差（损失），收集关于其参数的误差的导数（如我们在上一节中看到的），并使用梯度下降优化这些参数. 有关此过程的更详细演练，请观看 3Blue1Brown 的有关反向传播的视频。</p><h2 id="先决条件代码">先决条件代码</h2><p>我们从前面关于数据集和数据加载器和构建模型的部分加载代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> torchvision.transforms <span class="hljs-keyword">import</span> ToTensor<br><br>training_data = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">True</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor()<br>)<br><br>test_data = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">False</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor()<br>)<br><br>train_dataloader = DataLoader(training_data, batch_size=<span class="hljs-number">64</span>)<br>test_dataloader = DataLoader(test_data, batch_size=<span class="hljs-number">64</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NeuralNetwork</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(NeuralNetwork, self).__init__()<br>        self.flatten = nn.Flatten()<br>        self.linear_relu_stack = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">28</span> * <span class="hljs-number">28</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">10</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.flatten(x)<br>        logits = self.linear_relu_stack(x)<br>        <span class="hljs-keyword">return</span> logits<br><br>    <br>model = NeuralNetwork()<br></code></pre></td></tr></table></figure><h2 id="超参数">超参数</h2><p>超参数是可调整的参数，可让您控制模型优化过程。不同的超参数值会影响模型训练和收敛速度（阅读有关超参数调整的更多信息）</p><p>我们定义了以下用于训练的超参数：</p><ul><li>Number of Epochs：迭代数据集的次数</li><li>Batch Size：参数更新前通过网络传播的数据样本数量</li><li>Learning Rate：每个批次/时期更新模型参数的量。较小的值会产生较慢的学习速度，而较大的值可能会导致训练期间出现不可预测的行为。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">learning_rate = <span class="hljs-number">1e-3</span><br>batch_size = <span class="hljs-number">64</span><br>epochs = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="优化循环">优化循环</h2><p>一旦我们设置了超参数，我们就可以使用优化循环来训练和优化我们的模型。优化循环的每次迭代称为一个<strong>epoch</strong>。</p><p>每个<code>epoch</code>由两个主要部分组成：</p><ul><li>Train Loop：迭代训练数据集并尝试收敛到最佳参数。</li><li>Validation/TestLoop：遍历测试数据集以检查模型性能是否正在提高。</li></ul><p>让我们简要地熟悉一下训练循环中使用的一些概念。向前跳转以查看优化循环的完整实现。</p><h3 id="loss-function">Loss Function</h3><p>当提供一些训练数据时，我们未经训练的网络可能不会给出正确的答案。损失函数衡量的是得到的结果与目标值的相异程度，是我们在训练时想要最小化的损失函数。为了计算损失，我们使用给定数据样本的输入进行预测，并将其与真实数据标签值进行比较。</p><p>常见的损失函数包括用于回归任务的<code>nn.MSELoss</code>（均方误差）和用于分类的<code>nn.NLLLoss</code>（负对数似然）。 <code>nn.CrossEntropyLoss</code>结合了 nn.LogSoftmax 和 nn.NLLLoss。</p><p>我们将模型的输出 logits 传递给<code>nn.CrossEntropyLoss</code>，它将规范化 logits 并计算预测误差。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Initialize the loss function</span><br><span class="hljs-attr">loss_fn</span> = nn.CrossEntropyLoss()<br></code></pre></td></tr></table></figure><h3 id="优化器">优化器</h3><p>优化是在每个训练步骤中调整模型参数以减少模型误差的过程。优化算法定义了这个过程是如何执行的（在这个例子中我们使用随机梯度下降）。所有优化逻辑都封装在优化器对象中。 在这里，我们使用 SGD 优化器；此外，PyTorch 中有许多不同的优化器可用，例如 ADAM 和RMSProp，它们可以更好地处理不同类型的模型和数据。</p><p>我们通过注册需要训练的模型参数并传入学习率超参数来初始化优化器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)<br></code></pre></td></tr></table></figure><p>在训练循环中，优化分三步进行：</p><ul><li>调用 <code>optimizer.zero_grad()</code> 重置模型参数的梯度。默认情况下渐变相加；为了防止重复计算，我们在每次迭代时明确地将它们归零。</li><li>通过调用 <code>loss.backward()</code> 反向传播预测损失。 PyTorch存储每个参数的损失梯度。</li><li>一旦我们有了梯度，我们就会调用 <code>optimizer.step()</code>来通过在反向传递中收集的梯度来调整参数。</li></ul><h2 id="完整实现">完整实现</h2><p>我们定义了循环优化代码的train_loop，以及根据我们的测试数据评估模型性能的 test_loop。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_loop</span>(<span class="hljs-params">dataloader, model, loss_fn, optimizer</span>):<br>    size = <span class="hljs-built_in">len</span>(dataloader.dataset)<br>    <span class="hljs-keyword">for</span> batch, (X, y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dataloader):<br>        <span class="hljs-comment"># Compute prediction and loss</span><br>        pred = model(X)<br>        loss = loss_fn(pred, y)<br><br>        <span class="hljs-comment"># Backpropagation</span><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br><br>        <span class="hljs-keyword">if</span> batch % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            loss, current = loss.item(), (batch + <span class="hljs-number">1</span>) * <span class="hljs-built_in">len</span>(X)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;loss: <span class="hljs-subst">&#123;loss:&gt;7f&#125;</span>  [<span class="hljs-subst">&#123;current:&gt;5d&#125;</span>/<span class="hljs-subst">&#123;size:&gt;5d&#125;</span>]&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_loop</span>(<span class="hljs-params">dataloader, model, loss_fn</span>):<br>    size = <span class="hljs-built_in">len</span>(dataloader.dataset)<br>    num_batches = <span class="hljs-built_in">len</span>(dataloader)<br>    test_loss, correct = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> dataloader:<br>            pred = model(X)<br>            test_loss += loss_fn(pred, y).item()<br>            correct += (pred.argmax(<span class="hljs-number">1</span>) == y).<span class="hljs-built_in">type</span>(torch.<span class="hljs-built_in">float</span>).<span class="hljs-built_in">sum</span>().item()<br><br>    test_loss /= num_batches<br>    correct /= size<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test Error: \n Accuracy: <span class="hljs-subst">&#123;(<span class="hljs-number">100</span> * correct):&gt;<span class="hljs-number">0.1</span>f&#125;</span>%, Avg loss: <span class="hljs-subst">&#123;test_loss:&gt;8f&#125;</span> \n&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们初始化损失函数和优化器，并将其传递给 train_loop 和 test_loop。随意增加 epoch 的数量来跟踪模型的改进性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">loss_fn = nn.CrossEntropyLoss()<br>optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)<br><br>epochs = <span class="hljs-number">10</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;t+<span class="hljs-number">1</span>&#125;</span>\n-------------------------------&quot;</span>)<br>    train_loop(train_dataloader, model, loss_fn, optimizer)<br>    test_loop(test_dataloader, model, loss_fn)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done!&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="保存并加载模型">保存并加载模型</h1><p>在本节中，我们将了解如何通过保存、加载和运行模型预测来保持模型状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision.models <span class="hljs-keyword">as</span> models<br></code></pre></td></tr></table></figure><h2 id="保存和加载模型权重">保存和加载模型权重</h2><p>PyTorch 模型将学习到的参数存储在一个名为 state_dict的内部状态字典中。 这些可以通过 <code>torch.save</code> 方法保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model = models.vgg16(weights=<span class="hljs-string">&#x27;IMAGENET1K_V1&#x27;</span>)<br>torch.save(model.state_dict(), <span class="hljs-string">&#x27;model_weights.pth&#x27;</span>)<br></code></pre></td></tr></table></figure><p>要加载模型权重，您需要先创建相同模型的实例，然后使用load_state_dict() 方法加载参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = models.vgg16() <span class="hljs-comment"># we do not specify ``weights``, i.e. create untrained model</span><br>model.load_state_dict(torch.load(<span class="hljs-string">&#x27;model_weights.pth&#x27;</span>))<br>model.<span class="hljs-built_in">eval</span>()<br></code></pre></td></tr></table></figure><blockquote><p>NOTE：</p><p>一定要在推理之前调用 model.eval() 方法，将 dropout 和 batchnormalization 层设置为评估模式。如果不这样做，将产生不一致的推理结果。</p></blockquote><h2 id="使用形状保存和加载模型">使用形状保存和加载模型</h2><p>在加载模型权重时，我们需要先实例化模型类，因为该类定义了网络的结构。我们可能希望将此类的结构与模型一起保存，在这种情况下，我们可以将模型（而不是model.state_dict()）传递给保存函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.save(model, <span class="hljs-string">&#x27;model.pth&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后我们可以像这样加载模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model = torch.load(<span class="hljs-string">&#x27;model.pth&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>NOTE：</p><p>这种方法在序列化模型时使用 Python pickle模块，因此它依赖于加载模型时可用的实际类定义。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神经网络参数更新</title>
    <link href="/2023/05/10/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/05/10/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p>此处以双层神经网络的参数更新作为推导，向量均为列向量，样本数为1。（样本数为m时，只需要对偏置b进行相关处理即可，即对样本的b进行求均值？）</p><p>神经网络运算公式： <span class="math display">\[z_1=W_1^TX+b_1\\a_1=f_1(z_1)\\z_2=W^T_2a_1+b_2\\a_2=f_2(z_2)\]</span> 损失函数： <span class="math display">\[loss=\frac{1}{2}\sum_{i=1}^n(y_i-a_{2i})^2\]</span> <span class="math inline">\(W_2^T\)</span>： <spanclass="math display">\[\frac{\partial loss}{\partial a_2}=y-a_2\\\frac{\partial a_2}{\partial W_2^T}=\frac{\partial a_2}{\partialz_2}\cdot a_1^T\\\frac{\partial a_2}{\partial a_1}=(W_2^T)^T\cdot \frac{\partiala_2}{\partial z_2}\]</span></p><blockquote><p>规律：对哪个位置求导就将上一步的导数放在该位置然后与剩余部分的转置做向量积运算</p></blockquote><p><span class="math inline">\(W_1^T\)</span>： <spanclass="math display">\[\frac{\partial a_2}{W_1^T}=\frac{\partial a_2}{\partial a_1}\times\frac{\partial a_1}{W_1^T}\\\frac{\partial a_1}{\partial W_1^T}=\frac{\partial a_1}{\partialz_1}\cdot X^T\]</span></p><blockquote><p>在开始计算每一层之前，先算出到该层激活前的输出的偏导数值，记为一个标识符，然后就不用管之前的运算变量了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MNIST</title>
    <link href="/2023/04/23/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B-MNIST/"/>
    <url>/2023/04/23/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B-MNIST/</url>
    
    <content type="html"><![CDATA[<h1 id="手工实现">手工实现</h1><p>现如今，已经有很多成熟的框架用于神经网络的训练，但是对于其中的基本原理，并不能很好的体会。本节采用<code>Numpy</code>手动搭建一个两层神经网络，希望对神经网络的搭建和学习过程有更加深刻的体会，有助于今后的学习。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-string">&quot;&quot;&quot; 在本次实验中，矩阵运算的关系式为：XW+b &quot;&quot;&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">onehot</span>(<span class="hljs-params">targets, num</span>):<br>    result = np.zeros((num, <span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>        result[i][targets[i]] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> result<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;激活函数 sigmoid &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Dsigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> sigmoid(x) * (<span class="hljs-number">1</span> - sigmoid(x))<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NeuralNetwork</span>():<br>    <span class="hljs-comment"># 初始化神经网络</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_nodes, hidden_nodes, output_nodes, learning_rate, batch_size</span>):<br>        self.a2 = <span class="hljs-literal">None</span><br>        self.z2 = <span class="hljs-literal">None</span><br>        self.y = <span class="hljs-literal">None</span><br>        self.g = <span class="hljs-literal">None</span><br>        self.a1 = <span class="hljs-literal">None</span><br>        self.z1 = <span class="hljs-literal">None</span><br>        self.X = <span class="hljs-literal">None</span><br>        self.hidden_output = <span class="hljs-literal">None</span><br>        self.i_nodes = input_nodes<br>        self.h_nodes = hidden_nodes<br>        self.o_nodes = output_nodes<br>        self.lr = learning_rate<br>        self.batch_size = batch_size<br>        self.W1 = np.random.randn(self.i_nodes, self.h_nodes) * <span class="hljs-number">0.01</span><br>        self.W2 = np.random.randn(self.h_nodes, self.o_nodes) * <span class="hljs-number">0.01</span><br>        self.b1 = np.random.randn(self.h_nodes) * <span class="hljs-number">0.01</span><br>        self.b2 = np.random.randn(self.o_nodes) * <span class="hljs-number">0.01</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, y</span>):<br>        <span class="hljs-comment"># todo 使用自实现的 sigmoid 激活函数有溢出的情况，所以换成以下 sigmoid 函数，就解决了问题，未来查找研究一下</span><br><br>        <span class="hljs-comment"># hidden layer</span><br>        self.X = X<br>        self.y = y<br><br>        self.z1 = np.dot(X, self.W1) + self.b1<br>        self.a1 = sigmoid(self.z1)<br><br>        <span class="hljs-comment"># output layer</span><br>        self.z2 = np.dot(self.a1, self.W2) + self.b2<br>        self.a2 = sigmoid(self.z2)<br><br>        loss = np.<span class="hljs-built_in">sum</span>((self.a2 - y) * (self.a2 - y)) / self.batch_size<br><br>        <span class="hljs-comment"># 用于反向传播参数，就是书中的 g</span><br>        self.g = (self.a2 - y) * Dsigmoid(self.z2)<br><br>        <span class="hljs-keyword">return</span> loss<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self</span>):<br>        dW2 = np.dot(self.a1.T, self.g) / self.batch_size<br>        db2 = np.<span class="hljs-built_in">sum</span>(self.g, axis=<span class="hljs-number">0</span>) / self.batch_size<br><br>        <span class="hljs-comment"># 就是书中的 e</span><br>        e = np.dot(self.g, self.W2.T) * Dsigmoid(self.z1)<br>        dW1 = np.dot(self.X.T, e) / self.batch_size<br><br>        db1 = np.<span class="hljs-built_in">sum</span>(e, axis=<span class="hljs-number">0</span>) / self.batch_size<br><br>        self.W2 = self.W2 - self.lr * dW2<br>        self.b2 = self.b2 - self.lr * db2<br>        self.W1 = self.W1 - self.lr * dW1<br>        self.b1 = self.b1 - self.lr * db1<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy</span>(<span class="hljs-params">y, predict_y</span>):<br>    hit = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(y.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">if</span> np.argmax(y[i]) == np.argmax(predict_y[i]):<br>            hit = hit + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;accuracy&#x27;</span>, hit / y.shape[<span class="hljs-number">0</span>])<br><br><br>loss_list = []<br>precision_list = []<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">X, y, batch_size, epochs, test_X, test_y</span>):<br>    nn = NeuralNetwork(<span class="hljs-number">784</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0.1</span>, batch_size)<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----------------------epoch: %d--------------------&quot;</span> % epoch)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">60000</span>, batch_size):<br>            X = train_images[i: i + batch_size]<br>            Y = train_labels[i: i + batch_size]<br>            loss = nn.forward(X, Y)<br>            loss_list.append(loss)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;epoch:&#x27;</span>, epoch, <span class="hljs-string">&#x27;-&#x27;</span>, i, <span class="hljs-string">&#x27;:&#x27;</span>, loss)<br>            nn.backward()<br>        np.savez(<span class="hljs-string">&quot;main.npz&quot;</span>, w1=nn.W1, b1=nn.b1, w2=nn.W2, b2=nn.b2)<br>        test(test_X, test_y, batch_size)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">test_X, test_Y, batch_size</span>):<br>    nn = NeuralNetwork(<span class="hljs-number">784</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0.1</span>, batch_size)<br>    r = np.load(<span class="hljs-string">&quot;main.npz&quot;</span>)<br>    nn.W1 = r[<span class="hljs-string">&quot;w1&quot;</span>]<br>    nn.b1 = r[<span class="hljs-string">&quot;b1&quot;</span>]<br>    nn.W2 = r[<span class="hljs-string">&quot;w2&quot;</span>]<br>    nn.b2 = r[<span class="hljs-string">&quot;b2&quot;</span>]<br>    nn.forward(test_X, test_Y)<br>    result = nn.a2<br>    result = np.argmax(result, axis=<span class="hljs-number">1</span>)<br>    y = np.argmax(test_Y, axis=<span class="hljs-number">1</span>)<br>    precision = np.<span class="hljs-built_in">sum</span>(result == y) / y.shape[<span class="hljs-number">0</span>]<br>    precision_list.append(precision)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Precision:&quot;</span>, precision)<br><br>    <span class="hljs-comment"># for i in range(10):</span><br>    <span class="hljs-comment">#     plt.figure(figsize=(28, 28))</span><br>    <span class="hljs-comment">#     plt.imshow(np.reshape(test_X[i], (28, 28)))</span><br>    <span class="hljs-comment">#     print(result[i])</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;为了方便，我们使用 tensorflow 来进行数据的获取&#x27;&#x27;&#x27;</span><br>    (train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.mnist.load_data()<br>    <span class="hljs-comment"># print(train_images.shape)</span><br>    <span class="hljs-comment"># print(train_labels.shape)</span><br>    <span class="hljs-comment"># print(test_images.shape)</span><br>    <span class="hljs-comment"># print(test_labels.shape)</span><br>    <span class="hljs-comment"># (60000, 28, 28)</span><br>    <span class="hljs-comment"># (60000,)</span><br>    <span class="hljs-comment"># (10000, 28, 28)</span><br>    <span class="hljs-comment"># (10000,)</span><br><br>    <span class="hljs-string">&#x27;&#x27;&#x27;对数据进行处理，图像进行降维，数字进行 one-hot 编码&#x27;&#x27;&#x27;</span><br>    train_images = train_images.reshape(train_images.shape[<span class="hljs-number">0</span>], train_images.shape[<span class="hljs-number">1</span>] * train_images.shape[<span class="hljs-number">1</span>])<br>    test_images = test_images.reshape(test_images.shape[<span class="hljs-number">0</span>], test_images.shape[<span class="hljs-number">1</span>] * test_images.shape[<span class="hljs-number">1</span>])<br>    train_labels = onehot(train_labels, <span class="hljs-number">60000</span>)<br>    test_labels = onehot(test_labels, <span class="hljs-number">10000</span>)<br><br>    batch_size = <span class="hljs-number">100</span><br>    epochs = <span class="hljs-number">10000</span><br><br>    <span class="hljs-comment"># train(train_images, train_labels, batch_size, epochs, test_images, test_labels)</span><br>    test(test_images, test_labels, batch_size)<br><br>    <span class="hljs-comment"># 绘制 loss 变化曲线</span><br>    <span class="hljs-comment"># x_ = list(range(1, len(loss_list) + 1))</span><br>    <span class="hljs-comment"># plt.plot(x_, loss_list)</span><br>    <span class="hljs-comment"># plt.show()</span><br><br>    <span class="hljs-comment"># 绘制 precision 变化曲线</span><br>    <span class="hljs-comment"># x_ = list(range(1, len(precision_list) + 1))</span><br>    <span class="hljs-comment"># plt.plot(x_, precision_list)</span><br>    <span class="hljs-comment"># plt.show()</span><br></code></pre></td></tr></table></figure><h1 id="pytorch实现">Pytorch实现</h1><p>采用10层CNN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">import</span> torchvision.datasets <span class="hljs-keyword">as</span> datasets<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br><br>input_size = <span class="hljs-number">28</span> * <span class="hljs-number">28</span><br>num_classes = <span class="hljs-number">10</span><br>num_epochs = <span class="hljs-number">10</span><br>batch_size = <span class="hljs-number">100</span><br>learning_rate = <span class="hljs-number">1e-3</span><br><br>train_data = datasets.MNIST(root=<span class="hljs-string">&#x27;./dataset&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br>test_data = datasets.MNIST(root=<span class="hljs-string">&#x27;./dataset&#x27;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br>num_train_samples = <span class="hljs-built_in">len</span>(train_data)<br><br>train_loader = DataLoader(dataset=train_data, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br>test_loader = DataLoader(dataset=test_data, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CNN</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_outputs</span>):<br>        <span class="hljs-built_in">super</span>(CNN, self).__init__()<br><br>        <span class="hljs-comment"># 1*28*28</span><br>        self.conv1 = nn.Conv2d(in_channels=<span class="hljs-number">1</span>, out_channels=<span class="hljs-number">32</span>, kernel_size=(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), padding=<span class="hljs-number">2</span>)<br>        self.relu1 = nn.ReLU()<br>        self.pool1 = nn.MaxPool2d(kernel_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), stride=<span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># 32*14*14</span><br>        self.conv2 = nn.Conv2d(in_channels=<span class="hljs-number">32</span>, out_channels=<span class="hljs-number">64</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), padding=<span class="hljs-number">1</span>)<br>        self.relu2 = nn.ReLU()<br>        self.pool2 = nn.MaxPool2d(kernel_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), stride=<span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># 64*7*7</span><br>        self.conv3 = nn.Conv2d(in_channels=<span class="hljs-number">64</span>, out_channels=<span class="hljs-number">128</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), padding=<span class="hljs-number">1</span>)<br>        self.relu3 = nn.ReLU()<br><br>        <span class="hljs-comment"># 128*7*7 =&gt; 6272</span><br>        self.flatten = nn.Flatten()<br>        self.linear4 = nn.Linear(<span class="hljs-number">6272</span>, <span class="hljs-number">128</span>)<br>        self.relu4 = nn.ReLU()<br><br>        self.linear5 = nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">64</span>)<br>        self.relu5 = nn.ReLU()<br><br>        self.linear6 = nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">32</span>)<br>        self.relu6 = nn.ReLU()<br><br>        self.linear7 = nn.Linear(<span class="hljs-number">32</span>, <span class="hljs-number">16</span>)<br>        self.relu7 = nn.ReLU()<br><br>        self.linear8 = nn.Linear(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>)<br>        self.relu8 = nn.ReLU()<br><br>        self.linear9 = nn.Linear(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>)<br>        self.relu9 = nn.ReLU()<br><br>        self.linear10 = nn.Linear(<span class="hljs-number">16</span>, num_outputs)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, inputs</span>):<br>        outputs = self.conv1(inputs)<br>        outputs = self.relu1(outputs)<br>        outputs = self.pool1(outputs)<br><br>        outputs = self.conv2(outputs)<br>        outputs = self.relu2(outputs)<br>        outputs = self.pool2(outputs)<br><br>        outputs = self.conv3(outputs)<br>        outputs = self.relu3(outputs)<br><br>        outputs = self.flatten(outputs)<br>        outputs = self.linear4(outputs)<br>        outputs = self.relu4(outputs)<br><br>        outputs = self.linear5(outputs)<br>        outputs = self.relu5(outputs)<br><br>        outputs = self.linear6(outputs)<br>        outputs = self.relu6(outputs)<br><br>        outputs = self.linear7(outputs)<br>        outputs = self.relu7(outputs)<br><br>        outputs = self.linear8(outputs)<br>        outputs = self.relu8(outputs)<br><br>        outputs = self.linear9(outputs)<br>        outputs = self.relu9(outputs)<br><br>        outputs = self.linear10(outputs)<br>        <span class="hljs-keyword">return</span> outputs<br><br><br>model = CNN(num_classes)<br>loss_fn = nn.CrossEntropyLoss()<br>optimizer = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">0.01</span>)<br><br><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;e + <span class="hljs-number">1</span>&#125;</span>/<span class="hljs-subst">&#123;num_epochs&#125;</span>\n-------------------------------&quot;</span>)<br>    size = <span class="hljs-built_in">len</span>(train_loader.dataset)<br>    <span class="hljs-keyword">for</span> batch, (x, labels) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        one_hot = torch.nn.functional.one_hot(labels, num_classes).<span class="hljs-built_in">type</span>(torch.float32)<br><br>        <span class="hljs-comment"># 计算预测和损失</span><br>        pred = model(x)<br>        loss = loss_fn(pred, one_hot)<br><br>        <span class="hljs-comment"># 反向传递</span><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br><br>        <span class="hljs-keyword">if</span> batch % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            loss, current = loss.item(), (batch + <span class="hljs-number">1</span>) * <span class="hljs-built_in">len</span>(x)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;loss: <span class="hljs-subst">&#123;loss:&gt;7f&#125;</span>  [<span class="hljs-subst">&#123;current:&gt;5d&#125;</span>/<span class="hljs-subst">&#123;size:&gt;5d&#125;</span>]&quot;</span>)<br><br>size = <span class="hljs-built_in">len</span>(test_loader.dataset)<br>num_batches = <span class="hljs-built_in">len</span>(test_loader)<br>test_loss, correct = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> test_loader:<br>        pred = model(x)<br>        labels = labels.<span class="hljs-built_in">float</span>()<br>        one_hot = torch.nn.functional.one_hot(y, num_classes).<span class="hljs-built_in">type</span>(torch.float32)<br>        test_loss += loss_fn(pred, one_hot).item()<br>        correct += (pred.argmax(<span class="hljs-number">1</span>) == y).<span class="hljs-built_in">type</span>(torch.<span class="hljs-built_in">float</span>).<span class="hljs-built_in">sum</span>().item()<br><br>test_loss /= num_batches<br>correct /= size<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test Error: \n Accuracy: <span class="hljs-subst">&#123;(<span class="hljs-number">100</span> * correct):&gt;<span class="hljs-number">0.1</span>f&#125;</span>%, Avg loss: <span class="hljs-subst">&#123;test_loss:&gt;8f&#125;</span> \n&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>机器学习</tag>
      
      <tag>神经网络</tag>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch-GPU机器学习配置</title>
    <link href="/2023/04/16/Pytorch-GPU%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/04/16/Pytorch-GPU%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一更新显卡驱动">一、更新显卡驱动</h1><p><ahref="https://blog.csdn.net/qq_41764621/article/details/126465278?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126465278%22%2C%22source%22%3A%22qq_41764621%22%7D">(169条消息)如何在windows上 安装&amp;更新显卡的驱动_windows安装显卡驱动_chuanauc的博客-CSDN博客</a></p><p><a href="https://www.nvidia.cn/Download/index.aspx?lang=cn">官方驱动| NVIDIA</a></p><p>更新完成后，在命令行中输入：<code>nvidia-smi</code>，即可查看支持最新的<code>CUDA Version</code>版本</p><h1 id="二安装-cuda-运行版本">二、安装 CUDA 运行版本</h1><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDAToolkit Archive | NVIDIA Developer</a></p><p>在该网页下载对应版本，自定义安装，选择cuda即可</p><p>下载完成后，在命令行中输入：<code>nvcc --version</code>，有相关信息输出，即代表完成</p><h1 id="三安装-cudnn">三、安装 cuDNN</h1><p><a href="https://developer.nvidia.com/rdp/cudnn-download">cuDNNDownload | NVIDIA Developer</a></p><p>解压后，将对应文件夹的文件复制进CUDA对应文件夹中。【注意不是替换文件夹，而是复制文件夹中的文件】</p><h1 id="四安装-pytorch">四、安装 Pytorch</h1><p><a href="https://pytorch.org/get-started/locally/">Start Locally |PyTorch</a></p><p>选择相关配置，执行命令</p><h1 id="五验证是否安装成功">五、验证是否安装成功</h1><p>在命令行进入 Python 代码执行，输入代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>torch.cuda.is_available()<br></code></pre></td></tr></table></figure><p>输出结果为 True，则配置完成。</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
      <tag>Pytorch</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第6章-支持向量机</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC6%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC6%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第-6-章-支持向量机">第 6 章 支持向量机</h1><h2 id="间隔与支持向量">6.1 间隔与支持向量</h2><ul><li><p>分类学习最基本的想法就是基于训练集<spanclass="math inline">\(D\)</span>在样本空间中找到一个<strong>划分超平面</strong>，将不同类别的样本分开。</p></li><li><p>划分超平面可以通过如下线性方程来描述：</p><ul><li><p><span class="math display">\[w^Tx+b=0\]</span></p></li><li><p><spanclass="math inline">\(w=(w_1;w_2;\cdots;w_d)\)</span>为法向量，决定了超平面的方向</p></li><li><p><spanclass="math inline">\(b\)</span>为位移项，决定了超平面与原点之间的距离</p></li></ul></li><li><p>样本空间中任意点<spanclass="math inline">\(x\)</span>到超平面<spanclass="math inline">\((w,b)\)</span>的距离可以写作：</p><ul><li><span class="math display">\[r=\frac{|w^Tx+b|}{||w||}(点到平面距离公式)\]</span></li></ul></li><li><p>若超平面能够将训练样本正确分类，对于<spanclass="math inline">\(y_i=+1\)</span>，带入超平面方程大于等于+1；对于<spanclass="math inline">\(y_i=-1\)</span>，带入超平面方程小于等于-1；</p></li><li><p>距离超平面最近的几个训练样本使得以上等号成立，被称为“支持向量”support vector，两个异类支持向量到超平面的距离之和为：<spanclass="math inline">\(\gamma=\frac{2}{||w||}\)</span>，被称为间隔margin。</p></li><li><p>要找到具有最大间隔的划分超平面，即找到能够上式，使得<spanclass="math inline">\(\gamma\)</span>最大。显然仅需<spanclass="math inline">\(||w||^{-1}\)</span>最大，等价于最小化<spanclass="math inline">\(||w||^2\)</span></p></li><li><p>我们可以写出如下式子：</p><ul><li><p><span class="math display">\[min_{w,b}\ \frac{1}{2}||w||^2\\s.t.\ y_i(w^Tx_i+b)\geq 1, i=1,2,\cdots,m\]</span></p></li><li><p>以上就是支持向量机的基本型 Support Vector Machine，SVM</p></li></ul></li></ul><h2 id="对偶问题">6.2 对偶问题</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第5章-神经网络</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC5%E7%AB%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC5%E7%AB%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="第-5-章-神经网络">第 5 章 神经网络</h1><h2 id="神经元模型">5.1 神经元模型</h2><p>神经网络中最基本的成分是神经元 neuron / unit模型，当神经元的电位超过一个阈值，就会被激活，向其他神经元发送化学物质</p><p>M-P 神经元模型：</p><p><img src="第5章 神经网络.assets/image-20230403195540918.png" alt="image-20230403195540918" style="zoom: 50%;" /></p><p>理想的激活函数：</p><p><img src="第5章 神经网络.assets/image-20230403195835152.png" alt="image-20230403195835152" style="zoom: 50%;" /></p><p>但是，阶跃函数具有不连续，不光滑的性质。因此，常使用 Sigmoid函数：</p><p><img src="第5章 神经网络.assets/image-20230403200123887.png" alt="image-20230403200123887" style="zoom:50%;" /></p><p>把许多这样的神经元按一定的层次结构连接起来，就得到了神经网络</p><blockquote><p>引入激活函数的作用：</p><ol type="1"><li>给模型引入非线性关系</li><li>表示该神经元是否被激活，即该神经元接收到的信息是否有用，该留下或者抛弃</li></ol></blockquote><h2 id="感知机与多层网络">5.2 感知机与多层网络</h2><ul><li>感知机 Perceptron 由两层神经元组成：</li></ul><p><img src="第5章 神经网络.assets/image-20230403201104867.png" alt="image-20230403201104867" style="zoom:67%;" /></p><ul><li><p>神经网络就是为了学习出权重和阈值，而阈值可以看作一个固定输入为-1.0的哑结点dummy node 所对应的连接权重<spanclass="math inline">\(w_{n+1}\)</span>，这样权重和阈值的学习可以统一为权重的学习。</p></li><li><p>感知机的学习规则：</p><ul><li><p>对于训练样例<spanclass="math inline">\((x,y)\)</span>，若当前感知机的输出为<spanclass="math inline">\(\hat{y}\)</span>，则感知机权重进行如下调整：</p></li><li><p><span class="math inline">\(w_i\leftarrow w_i+\Deltaw_i\)</span></p></li><li><p><span class="math inline">\(\Deltaw_i=\eta(y-\hat{y})x_i\)</span></p></li><li><p>其中<span class="math inline">\(\eta\in(0,1)\)</span>称为学习率(learning rate)</p></li><li><p><ahref="https://zhuanlan.zhihu.com/p/46762820">算法——感知机详解（推导+证明）- 知乎 (zhihu.com)</a></p></li></ul></li><li><p>感知机只有输出层神经元进行激活函数处理，只拥有一层功能神经元functional neuron，学习能力有限</p></li><li><p>两层感知机</p><ul><li><img src="第5章 神经网络.assets/image-20230403202259504.png" alt="image-20230403202259504" style="zoom:50%;" /></li><li>其中有隐层 / 隐含层 hiddenlayer，隐含层和输出层神经元都是拥有激活函数的功能神经元</li></ul></li><li><p>多层前馈神经网络 multi-layer feedforward neural networks：</p><ul><li><img src="第5章 神经网络.assets/image-20230403202459424.png" alt="image-20230403202459424" style="zoom:67%;" /></li><li>前馈指的是网络拓扑结构上不存在环或回路</li></ul></li><li><p>神经网络的学习过程，就是根据训练数据来调整神经元之间的“连接权”（connectionweight）以及每个功能神经元之间的阈值</p></li></ul><h2 id="误差逆传播算法">5.3 误差逆传播算法</h2><ul><li>为了训练多层网络，就需要更加强大的学习算法。误差逆传播 errorBackPropagation，简称 BP 算法，是其中的代表。</li><li></li></ul><h2 id="全局最小与局部极小">5.4 全局最小与局部极小</h2><ul><li>神经网络的训练过程可看作一个参数寻优过程，即在参数空间中，寻找一组最优参数使得<spanclass="math inline">\(E\)</span>最小</li><li>最优：<ul><li>局部极小 local minimum</li><li>全局最小 global minimum</li></ul></li><li>基于梯度下降的搜索是使用最为广泛的参数寻优方法</li><li>为了防止陷入局部极小，而不能保证找到全局最小，我们可以采用以下操作：<ul><li>以多组不同参数值初始化多个网络，取其中误差最小解作为最终参数</li><li>使用“模拟退火”技术（simulatedannealing）：在每一步都以一定的概率接受比当前解更差的结果，从而有助于“跳出”局部极小。在每步迭代过程中，接受“次优解”的概率要随着时间的推移而逐渐降低，从而保证算法稳定。</li><li>使用随机梯度下降：与标准梯度下降法精确计算梯度不同，随机梯度下降法在计算梯度时加入了随机因素。于是，即便陷入局部极小点，它计算出的梯度仍可能不为零，这样就有机会跳出局部极小继续搜索。</li><li>遗传算法 genetic algorithm也常用来训练神经网络以更好地逼近全局最小。</li><li>上述用于跳出局部极小的的技术大多是启发式，理论缺乏保障。</li></ul></li></ul><h2 id="其他常见神经网络">5.5 其他常见神经网络</h2><ul><li>RBF 网络</li><li>ART 网络</li><li>SOM 网络</li><li>级联相关网络</li><li>Elman 网络</li><li>Boltzmann 机</li></ul><h2 id="深度学习">5.6 深度学习</h2><ul><li>增加隐层数目比增加隐层神经元更能提高模型的复杂度</li><li>多隐层神经网络往往难以直接用经典算法进行训练，由于误差在多隐层内逆传播时，往往会发散diverge，而不能收敛到稳定状态</li><li>无监督逐层训练 unsupervised layer-wise training是多隐层网络训练的有效手段，基本思想：<ul><li>每次训练一层隐结点，训练时将上一层隐结点的输出作为输入，本层隐结点的输出作为下一层隐结点的输入。预训练pre-training</li><li>预训练全部完成后，对整个网络进行微调 fine-tuning 训练</li></ul></li><li>另一种节省训练开销的策略是“权共享” weightsharing，让一组神经元使用相同的连接权。<ul><li>该策略在卷积神经网络中发挥了重要作用</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第4章-决策树</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC4%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC4%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="第-4-章-决策树">第 4 章 决策树</h1><h2 id="基本流程">4.1 基本流程</h2><ul><li><p><strong>决策树 decision tree</strong>是一类常见的机器学习方法，有时也叫<strong>判定树</strong>。决策树是基于树结构来进行决策的</p></li><li><p>一棵决策树包含一个根结点、若干个内部结点和若干个叶结点。叶结点对应于决策结果，其他每个结点则对应于一个<strong>属性测试</strong>；根据属性测试的结果将其包含的样本集合划分到子结点中；根结点包含样本全集；<strong>从根节点到叶结点的路径对应了一个判定测试序列</strong>；决策树学习的目的是产生一棵<strong>泛化能力强</strong>的决策树，其基本流程遵循简单直观的<strong>“分而治之”</strong>策略。</p><ul><li><img src="第4章 决策树.assets/image-20230310164532787.png" alt="image-20230310164532787" style="zoom: 50%;" /></li><li>2-4：无需划分</li><li>5-6：无法划分</li><li>11-12：不能划分</li></ul></li><li><p>决策树的生成是一个<strong>递归过程</strong>。</p></li><li><p>在决策树基本算法中，有三种情形会导致递归返回：</p><ol type="1"><li>当前结点包含的样本全属于同一类别，无需划分；</li><li>当前属性集为空，或是所有样本在所有属性上取值相同，无法划分；</li><li>当前结点包含的样本集合为空，不能划分；</li></ol><ul><li>在第 2种情形下，我们把当前结点标记为叶结点，并将其类别设定为该结点所含样本最多的类别；</li><li>在第 3种情形下，同样把当前结点标记为叶结点，但将其类别设定为其父结点所含样本最多的类别；</li><li>注意这两种情形的处理实质不同：情形 2是在利用当前结点的后验分布，而情形 3则是把父结点的样本分布作为当前结点的先验分布.</li></ul></li></ul><h2 id="划分选择">4.2 划分选择</h2><ul><li>如何选择最优划分属性，是决策树学习算法的关键</li></ul><h3 id="信息增益">4.2.1 信息增益</h3><ul><li>信息熵 informationentropy：度量样本集合纯度的一种之指标。若当前样本集合<spanclass="math inline">\(D\)</span>中第<spanclass="math inline">\(k\)</span>类样本所占的比例为<spanclass="math inline">\(p_k(k=1,2,\dots,|y|)\)</span>，则<spanclass="math inline">\(D\)</span>的信息熵定义为： <spanclass="math display">\[Ent(D)=-\sum_{k=1}^{|y|}p_klog_2p_k\]</span> <span class="math inline">\(Ent(D)\)</span>的值越小，<spanclass="math inline">\(D\)</span>的纯度越高</li></ul><blockquote><p>公式理解：</p><p>信息的信息量与发生概率成反比，<spanclass="math inline">\(p_klog_2\frac{1}{p_k}\)</span>，取对数是为了缩小数量级，再乘以<spanclass="math inline">\(p_k\)</span>求和意味着取期望</p><p>纯度越高，可能获取的信息值越小，信息熵越小</p></blockquote><ul><li>信息增益 information gain</li></ul><p><span class="math display">\[Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{|D^v|}{D}Ent(D^v)\]</span></p><blockquote><p>公式理解：</p><p>信息增益 = 划分前的信息熵 - 划分后的信息熵</p><p>划分后的信息熵 = 划分的各分支的信息熵乘以权重再求和</p><p>权重 = 某一属性的样本总数 / 未划分的总样本数</p></blockquote><h3 id="增益率">4.2.2 增益率</h3><ul><li><p>信息增益准则对可取值数目较多的属性有所偏好，为了减少这种不利影响。<spanclass="math inline">\(C4.5\)</span>决策树算法采用增益率，而不是信息增益，来作为选择最优划分属性的准则。</p></li><li><p>增益率 gain ratio <span class="math display">\[Gain\_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}\\\]</span> 其中 <span class="math display">\[IV(a)=-\sum_{v=1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}\]</span> 称为属性<span class="math inline">\(a\)</span>的固有值</p><ul><li>增益率准则对可取值数目较少的属性有所偏好，所以<spanclass="math inline">\(C4.5\)</span>算法先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的。</li></ul></li></ul><blockquote><p>公式理解：</p><p>由于信息增益偏向于属性值多的属性，那么我们对属性值多的属性进行惩罚，越多惩罚力度越大</p><p><spanclass="math inline">\(IV(a)\)</span>公式类似于信息熵公式，属性值越多，则该值越大，则整体分数变小</p></blockquote><h3 id="基尼指数">4.2.3 基尼指数</h3><ul><li><p><spanclass="math inline">\(CART\)</span>决策树使用基尼指数来选择划分属性</p></li><li><p>基尼值： <span class="math display">\[Gini(D)=\sum_{k=1}^{|y|}\sum_{k\prime\neq k}p_kp_k\prime=1-\sum_{k=1}^{|y|}p_k^2\]</span></p></li><li><p><spanclass="math inline">\(Gini(D)\)</span>反映了从数据集中随机抽取两个样本，其类别标记不一致的概率。该值越小，数据集纯度越高</p></li><li><p>属性<span class="math inline">\(a\)</span>的基尼指数： <spanclass="math display">\[Gini\_index(D,a)=\sum_{v=1}^V\frac{D^v}{D}Gini(D^v)\]</span></p></li></ul><blockquote><p>公式理解：</p><p>属性<span class="math inline">\(a\)</span>的基尼指数 =划分后各分支的基尼值 * 权重 再求和</p></blockquote><ul><li>选择划分后基尼指数最小的属性作为最优划分属性，即<spanclass="math inline">\(a_*=arg_{a\in A}\ min\Gini\_index(D,a)\)</span></li></ul><h2 id="剪枝处理">4.3 剪枝处理</h2><ul><li>剪枝 pruning 是决策树学习算法对付“过拟合”的主要手段。</li><li>决策树剪枝的基本策略有“预剪枝”（prepruning）和“后剪枝”（postpruning）<ul><li>prepruning：在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。</li><li>postpruning：从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。</li></ul></li><li>判断决策树泛化性能，可以使用 2.2节中提到的留出法，即预留一部分数据用作“验证集”以进行评估。</li></ul><h2 id="连续与缺失值">4.4 连续与缺失值</h2><ul><li>以上讨论的都是基于离散属性生成决策树，现在我们讨论如何对连续属性进行处理，使用连续属性离散化技术。</li><li>最简单的连续属性离散化策略是“二分法”，即<spanclass="math inline">\(C4.5\)</span>中使用的方法。</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第3章-线性模型</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第-3-章-线性模型">第 3 章 线性模型</h1><h2 id="基本形式">3.1 基本形式</h2><p>对于由<span class="math inline">\(d\)</span>个属性描述的示例<spanclass="math inline">\(x=(x_1;x_2;\dots;x_d)\)</span>，线性模型 linearmodel 试图学得一个通过属性的线性组合来进行预测的函数，即<spanclass="math inline">\(f(x)=w^Tx+b\)</span>，<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>学得之后，模型就得以确定。</p><p>线性模型是许多非线性模型 nonlinear model的基础，且线性模型具有很好的可解释性 comprehensibility。</p><h2 id="线性回归">3.2 线性回归</h2><blockquote><p>分类问题：预测值为分类型变量，即离散的</p><p>回归问题：预测值为连续性变量</p><p>逻辑回归问题：</p></blockquote><p>线性回归：使用线性模型，来学习预测</p><p><strong>对于离散的属性，若属性值间存在序 order关系，通过连续化转化为连续值。若属性值间不存在序关系，假定有<spanclass="math inline">\(k\)</span>个属性值，通常转化为<spanclass="math inline">\(k\)</span>维向量。</strong>例如属性“瓜类”取值有“西瓜”，“南瓜”，“黄瓜”，可转化为<spanclass="math inline">\((0,0,1),(0,1,0),(1,0,0)\)</span></p><p>均方误差是回归任务中最常用的性能度量</p><p><strong>基于均方误差最小化来进行模型求解的方法称为“最小二乘法” leastsquaremethod</strong>。就是试图抓到一条直线，使所有样本到直线上的欧式距离之和最小。<span class="math display">\[\begin{split}E_{(w,b)}=\sum_{i=1}^m(y_i-wx_i-b)^2\ 均方误差\\\frac{\partial E_{(w,b)}}{\partialw}=2(w\sum_{i=1}^mx^2_i-\sum_{i=1}^m(y_i-b)x_i)\\\frac{\partial E_{(w,b)}}{\partial b}=2(mb-\sum_{i=1}^m(y_i-wx_i))\end{split}\]</span> 令上式分别为0，可得到<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>最优解的闭式 closed-form 解</p><blockquote><p>闭式解：解析解，不同于数值解，是通过公式计算推导而来</p></blockquote><p>求解<span class="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>使均方误差最小化的过程，称为线性回归模型的最小二乘“参数估计”parameter estimation</p><p>当<spanclass="math inline">\(x\)</span>为一属性向量时，则称为多元线性回归</p><hr /><p>对于矩阵形式来说，我们把<span class="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>吸收入向量形式<spanclass="math inline">\(\hat{w}=(w;b)\)</span>。同样，把数据集 <spanclass="math inline">\(D\)</span> 表示为一个<spanclass="math inline">\(m\times(d+1)\)</span>大小的矩阵<spanclass="math inline">\(X，\)</span>矩阵的每一行对应一个示例，前<spanclass="math inline">\(d\)</span>个元素对应示例中的<spanclass="math inline">\(d\)</span>​个属性值，最后一个元素恒置为1，即：<span class="math display">\[X=\begin{pmatrix}x_{11}&amp;x_{12}&amp;\cdots&amp;x_{1d}&amp;1\\x_{21}&amp;x_{22}&amp;\cdots&amp;x_{2d}&amp;1\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\x_{m1}&amp;x_{m2}&amp;\cdots&amp;x_{md}&amp;1\end{pmatrix}=\begin{pmatrix}x_1^T &amp; 1 \\x_2^T &amp; 1 \\\vdots &amp; \vdots \\x_m^T &amp; 1 \\\end{pmatrix}\]</span> 要求的参数<spanclass="math inline">\(\hat{w}^*=arg_\hat{w}min(y-X\hat{w})(y-X\hat{w})\)</span>，就是将各样本的误差求均方和</p><p>其中，<span class="math inline">\(E_{\hatw}=(y-X\hat{w})^T(y-X\hat{w})\)</span>，对<spanclass="math inline">\(\hat{w}\)</span>求导，得： <spanclass="math display">\[\frac{\partial E_{\hat{w}}}{\partial{\hat{w}}}=2X^T(X\hat{w}-y)\]</span> 令上式为零，即可求出<spanclass="math inline">\(\hat{w}\)</span>最优的闭式解</p><p>若能解出多个解时，选择哪一个解作为输出，将由学习算法的归纳偏好决定，常见的做法是引入正则化regularization 项</p><h2 id="对数几率回归">3.3 对数几率回归</h2><ul><li><p>线性模型的预测值为连续值，如果想要将线性模型应用到分类问题中，就需要找到一个映射函数，将预测值转化为分类值。并且该函数还需要具有单调可微性</p></li><li><p>考虑二分类问题，输出<spanclass="math inline">\(y\in\{0,1\}\)</span>，我们需要将线性回归的预测值<spanclass="math inline">\(y\in R\)</span>转换为<spanclass="math inline">\(\{0,1\}\)</span>，最理想的即为“单位阶跃函数”：</p><ul><li><p><span class="math display">\[y=\begin{cases}0, &amp; z&lt;0;\\0.5, &amp; z=0;\\1, &amp; z&gt;0,\end{cases}\]</span></p></li><li><p>但是由于我们还需要在运算过程中涉及，求导等操作，需要保证映射函数单调可微，所以我们转而寻求可以近似单位阶跃函数的替代函数，对数几率函数就是一种常用的替代函数</p></li><li><p><span class="math display">\[y=\frac{1}{1+e^{-z}}\]</span></p></li></ul></li><li><p>从而，分类问题的式子变为<spanclass="math inline">\(y=\frac{1}{1+e^{-(w^Tx+b)}}\)</span>。可以看出，该式子使用线性回归模型的预测值结果去逼近真实标记的对数几率，因此，该模型称为“对数几率回归”（有时也称为，逻辑回归）</p><ul><li>可以看出，虽然名字叫回归，其实解决的是一个分类问题</li></ul></li></ul><h2 id="线性判别分析">3.4 线性判别分析</h2><ul><li>线性判别分析（Linear DiscriminantAnalysis，LDA）是一种经典的线性学习方法，在二分类问题上最早提出，也称为“Fisher判别分析”</li><li>LDA的思想：给定训练集，将样例投影到直线上，使同类样例的投影点尽可能接近，异类样例的投影点尽可能远离。在对新样例进行分类时，将其投影到同样的直线上，根据投影点的位置来确定新样本的类别。</li></ul><h2 id="多分类学习">3.5 多分类学习</h2><ul><li>在多分类任务中，有些二分类方法可以直接推广到多分类中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第2章-模型评估与选择</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC2%E7%AB%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC2%E7%AB%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="第-2-章-模型评估与选择">第 2 章 模型评估与选择</h1><h2 id="经验误差与过拟合">2.1 经验误差与过拟合</h2><p>错误率 error rate：分类错误的样本数占样本总数的比例</p><p>精度 accuracy：<span class="math inline">\(精度=1-错误率\)</span></p><p>误差 error：学习器的实际预测输出与样本的真实输出之间的差异</p><p>训练误差 training error / 经验误差 empiricalerror：学习器在训练集上的误差</p><p>泛化误差 generalization error：学习器在新样本上的误差</p><p><strong>我们的目的是获得一个泛化误差小的学习器</strong></p><p>过拟合overfitting：将训练集中样本自身的特点当做所有潜在样本都会具有的一般性质，导致泛化性能下降。学习器的学习能力过于强大</p><p>欠拟合underfitting：对训练样本的一般性质尚未学好。学习器的学习能力低下</p><p>欠拟合可以通过在决策树学习中扩展分支、在神经网络学习中增加训练轮数等方法解决</p><p>过拟合是机器学习面临的关键障碍，过拟合问题是无法避免的，只能缓解或是减小风险</p><h2 id="评估方法">2.2 评估方法</h2><p>我们通常使用测试集 testing set来测试学习器对新样本的辨别能力，用测试集中的测试误差 testing error作为泛化误差的近似。</p><p>我们假设测试样本是从样本真实分布中独立同分布采样而得，并且测试集应该尽可能与训练集互斥。</p><hr /><p><strong>训练集和测试集划分的方法：</strong></p><h3 id="留出法">2.2.1 留出法</h3><p>留出法 hold-out：将数据集 D 划分为两个互斥的集合。</p><p>训练 /测试集的划分要尽可能保持数据分布的一致性，避免数据划分过程引入额外的偏差而对最终结果产生影响。</p><p>分层采样</p><p>单次使用留出法不够稳定可靠，一般要采用若干次随机划分，重复进行实验评估后取平均值作为留出法的评估结果。即多次进行实验，然后将各实验的平均值作为最终实验结果。</p><p>常见做法是将<spanclass="math inline">\(2/3\sim4/5\)</span>的样本用于训练，剩余样本用于测试</p><h3 id="交叉验证法">2.2.2 交叉验证法</h3><p>交叉验证法 cross validation：将数据集划分为<spanclass="math inline">\(k\)</span>个互斥子集，每个子集尽可能保持数据分布的一致性，即从D中分层采样得到。</p><p>每次使用<spanclass="math inline">\(k-1\)</span>个子集的并集作为训练集，剩下的子集作为测试集。得到<spanclass="math inline">\(k\)</span>个测试结果，其均值最为最终结果。</p><p>交叉验证法评估结果的稳定性和保真行在很大程度上取决于<spanclass="math inline">\(k\)</span>的取值，因此，通常称为<spanclass="math inline">\(k\)</span>折交叉验证</p><p><span class="math inline">\(k\)</span>的最常取值为<spanclass="math inline">\(10\)</span>，其他常用数字为<spanclass="math inline">\(5,20\)</span>等</p><p>为了减小因样本划分不同而引入的差别，通常要随机使用不同的划分重复<spanclass="math inline">\(p\)</span>次，最终结果是这<spanclass="math inline">\(p\)</span>次<spanclass="math inline">\(k\)</span>折交叉验证结果的均值。例如：<spanclass="math inline">\(10\)</span>次<spanclass="math inline">\(10\)</span>折交叉验证</p><h3 id="自助法">2.2.3 自助法</h3><p>自助法 bootstrapping：以自主采样法 bootstrap sampling为基础，即放回抽样。</p><p>样本在<spanclass="math inline">\(m\)</span>次采样中始终不被猜到的概率是<spanclass="math inline">\((1-\frac{1}{m})^m\)</span>，取极限得<spanclass="math inline">\(\displaystyle\lim_{m\rightarrow\infty}(1-\frac{1}{m})\rightarrow\frac{1}{e}\approx0.368\)</span></p><h3 id="调参与最终模型">2.2.4 调参与最终模型</h3><p>学习算法都有些参数 parameter 需要设定</p><p>有时，我们把学得模型在实际使用中遇到的数据称为<strong>测试数据</strong>，为了加以区分，模型评估与选择中用于评估测试的数据集常称为<strong>验证集validation set</strong></p><p>用测试集上的判别效果来估计模型在实际使用时的泛化能力，而把训练数据另外划分为<strong>训练集</strong>和<strong>验证集</strong>，基于验证上的性能来进行模型选择和调参</p><h2 id="性能度量">2.3 性能度量</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第1章-绪论</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-绪论">第1章 绪论</h1><ul><li><p>learning algorithm：从数据中产生模型的算法</p></li><li><p>机器学习算法被认为是一种从数据中学习的算法。所谓“学习”有一个定义：‘‘对于某类任务T 和性能度量 P，一个计算机程序被认为可以从经验 E 中学习是指，通过经验 E改进后，它在任务 T 上由性能度量 P 衡量的性能有所提升。”</p></li><li><p>数据集</p></li><li><p>属性 / 特征</p></li><li><p>属性值</p></li><li><p>属性空间 / 样本空间 / 输入空间</p></li><li><p>特征向量 feature vector</p></li><li><p>假设 hypothesis</p></li><li><p>真相 / 真实 ground-truth</p></li><li><p>学习器 learner</p></li><li><p>学习的过程是为了找出或逼近真相</p></li><li><p>标记空间 / 输出空间</p></li><li><p>分类 classification：预测的是离散值</p></li><li><p>回归 regression：预测的是连续值</p></li><li><p>二分类：正类 positive class 反类 negative class</p></li><li><p>多分类问题</p></li><li><p>学习任务：</p><ul><li><p>监督 supervised learning 分类/回归</p></li><li><p>无监督 unsupervised learning 聚类</p></li></ul></li><li><p>泛化能力 generalization</p></li><li><p>样本服从 D分布，独立同分布采样，通过学习获得强泛化能力的模型</p></li><li><p>归纳偏好 inductivebias（偏好）：机器学习算法在学习过程中对某种类型假设的偏好</p></li><li><p>任何一个有效的机器学习算法必定有其归纳偏好，否则无法产生确定的学习结果</p></li><li><p>归纳偏好可看做学习算法自身在庞大的假设空间中对假设进行选择的启发式或价值观</p></li><li><p>奥卡姆剃刀原则 Occam’srazor：若有多个建设与观察一致，则选最简单的那个</p></li><li><p>没有免费的午餐定理 No Free Lunch Theorem NFL表明具体问题具体分析</p></li><li><p>BP back propagation 算法</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUPT成绩查询脚本</title>
    <link href="/2023/02/16/BUTP%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/02/16/BUTP%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<ul><li>采用微信接口进行成绩查询</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> schedule<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> tabulate <span class="hljs-keyword">import</span> tabulate<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fractionMap</span>(<span class="hljs-params">fraction</span>):<br>    <span class="hljs-keyword">if</span> fraction == <span class="hljs-string">&quot;优&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">90</span><br>    <span class="hljs-keyword">elif</span> fraction == <span class="hljs-string">&#x27;良&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">80</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(fraction)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getCourse</span>(<span class="hljs-params">token, term</span>):<br>    headers = &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>, <span class="hljs-string">&#x27;token&#x27;</span>: token&#125;<br>    r = requests.post(<span class="hljs-string">&quot;http://jwglweixin.bupt.edu.cn/bjyddx/student/termGPA?semester=&#123;&#125;&amp;type=1&quot;</span>.<span class="hljs-built_in">format</span>(term),<br>                      headers=headers)<br>    r = r.json()<br>    credit_sum = <span class="hljs-number">0</span><br>    avg_grade = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># print(r[&quot;data&quot;][0][&quot;achievement&quot;])</span><br>    <span class="hljs-built_in">list</span> = [[<span class="hljs-string">&quot;课程名&quot;</span>, <span class="hljs-string">&quot;成绩&quot;</span>, <span class="hljs-string">&quot;学分&quot;</span>]]<br>    <span class="hljs-keyword">for</span> course <span class="hljs-keyword">in</span> r[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;achievement&quot;</span>]:<br>        <span class="hljs-built_in">print</span>(course[<span class="hljs-string">&quot;courseName&quot;</span>] + <span class="hljs-string">&#x27; &#x27;</span> + course[<span class="hljs-string">&quot;fraction&quot;</span>] + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">str</span>(course[<span class="hljs-string">&quot;credit&quot;</span>]))<br>        <span class="hljs-built_in">list</span>.append([course[<span class="hljs-string">&quot;courseName&quot;</span>], course[<span class="hljs-string">&quot;fraction&quot;</span>], <span class="hljs-built_in">str</span>(course[<span class="hljs-string">&quot;credit&quot;</span>])])<br>        avg_grade = (avg_grade * credit_sum + fractionMap(course[<span class="hljs-string">&quot;fraction&quot;</span>]) * course[<span class="hljs-string">&quot;credit&quot;</span>]) / (credit_sum + course[<span class="hljs-string">&quot;credit&quot;</span>])<br>        credit_sum += course[<span class="hljs-string">&quot;credit&quot;</span>]<br>    <span class="hljs-comment"># print(tabulate(list, headers=&#x27;firstrow&#x27;, tablefmt=&#x27;grid&#x27;))</span><br>    <span class="hljs-built_in">print</span>(term + <span class="hljs-string">&#x27;加权平均分: &#x27;</span> + <span class="hljs-built_in">str</span>(avg_grade))<br>    <span class="hljs-keyword">return</span> [avg_grade, credit_sum]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPwdMd5</span>(<span class="hljs-params">mypwd</span>):<br>    pwd = mypwd.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    pwd = base64.b64encode(pwd)<br>    pwd = <span class="hljs-built_in">str</span>(pwd)<br>    pwd = pwd[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> pwd<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getToken</span>(<span class="hljs-params">account, pwdmd5</span>):<br>    headers = &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;<br>    url = <span class="hljs-string">&quot;http://jwglweixin.bupt.edu.cn/bjyddx/login?userNo=&#123;&#125;&amp;pwd=&#123;&#125;&amp;encode=1&quot;</span>.<span class="hljs-built_in">format</span>(account, pwdmd5)<br>    <span class="hljs-built_in">print</span>(url)<br>    r = requests.post(url, headers=headers)<br>    <span class="hljs-built_in">print</span>(r.text)<br>    r = r.json()<br>    token = r[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;token&quot;</span>]<br>    <span class="hljs-keyword">return</span> token<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">job</span>():<br>    account = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;账号：&quot;</span>)<br>    mypwd = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;密码：&quot;</span>)<br><br>    pwdmd5 = getPwdMd5(mypwd)<br>    token = getToken(account, pwdmd5)<br>    terms = [<span class="hljs-string">&quot;2020-2021-1&quot;</span>, <span class="hljs-string">&quot;2020-2021-2&quot;</span>, <span class="hljs-string">&quot;2021-2022-1&quot;</span>, <span class="hljs-string">&quot;2021-2022-2&quot;</span>, <span class="hljs-string">&quot;2022-2023-1&quot;</span>]<br>    creditSum = <span class="hljs-number">0</span><br>    avgCourse = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> term <span class="hljs-keyword">in</span> terms:<br>        temp = getCourse(token, term)<br>        avgCourse = (avgCourse * creditSum + temp[<span class="hljs-number">0</span>] * temp[<span class="hljs-number">1</span>]) / (creditSum + temp[<span class="hljs-number">1</span>])<br>        creditSum += temp[<span class="hljs-number">1</span>]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;截止当前加权平均分为：&quot;</span> + <span class="hljs-built_in">str</span>(avgCourse))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最终加权平均分为：&quot;</span> + <span class="hljs-built_in">str</span>(avgCourse))<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./成绩.txt&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime()) + <span class="hljs-string">&quot;加权平均分：&quot;</span> + <span class="hljs-built_in">str</span>(avgCourse) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>job()<br><span class="hljs-comment"># schedule.every(10).minutes.do(job)</span><br><span class="hljs-comment"># while True:</span><br><span class="hljs-comment">#     schedule.run_pending()</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>BUPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
