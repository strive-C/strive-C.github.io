<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动手学深度学习</title>
    <link href="/2024/10/27/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/10/27/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="cnn">CNN</h1><h2 id="卷积层">卷积层</h2><ul><li><p>卷积神经网络（convolutional neural network，CNN）</p></li><li><p>从向量过度到矩阵的权重下标问题</p><p><img src="/从向量过度到矩阵的权重下标问题.jpg" /></p></li><li><p>传统卷积</p><ul><li><p>连续域卷积 <span class="math display">\[f(x)*g(x)=\int_{-\infin}^{+\infin}f(\tau)g(x-\tau)d\tau\]</span> 结果被称之为f(x)与g(x)的卷积。</p></li><li><p>离散域卷积 <span class="math display">\[x(n)*y(n)=\sum_{i=-\infin}^{+\infin}x(i)y(n-i)\]</span> 离散域中n的取值为整数，其他则同理</p></li></ul></li><li><p>图像处理中的卷积核</p><p>卷积还是滤波(filter)都无所谓了，反正都是一个东西。说到这个就得提一下图像了，毕竟是与图像相关的。大家都是知道图像都是由像素点组成的，而每个像素点都有一个对应的像素值，根据值的不同，表现出不同的颜色。比如我们这里可以虚拟一个图像。</p><figure><imgsrc="/e0f61decc008ee26ef52f7aa9ed17e3db37da03f.png@690w_!web-note.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>进行卷积操作，我们还需要另外的一个变量，这里我们虚拟另外一个卷积核</p><figure><imgsrc="/ac2b774d899d2df9dc5fc3ab1183de3e3d306dc4.png@440w_!web-note.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>从数据科学的角度而言，这两个都是矩阵。前者是一个5×6的矩阵，而后者是一个3×3的矩阵。我们是很难去直接计算的。所以这里有些小tips！我们只需要依次从大的图像中采样一个和我们的核一样大的图形，就可以进行卷积操作了。也即，</p><figure><imgsrc="/979a9241744ea26165bb0fcc103ac9ba43c11061.png@690w_!web-note.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>然后也就可以将这个红框中的数据与我们最初的卷积核进行计算。也即。</p><figure><imgsrc="/7bd6183497fdef7eaec9f05e9f2919ef80a825b7.png@690w_!web-note.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>相同颜色的圈圈数据相加，也即：24-23+5-1+10-2=13，</p><p>这就是我们口中的离散卷积(求0位置处的值罢了，刚好就是对称的)。这样就求到了第一个值，那么我们再滑动卷积核，继续以这样的方式去计算第二个滑块。</p><figure><imgsrc="/e6138d0a90435f7a06ff787ce9d7206906247eee.png@690w_!web-note.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li></ul><p>​ 那么不再赘述。</p><p>但是这样计算是很奇怪的，不够美观。事实上，<strong>数学以及数据科学一定是在追求美观的！</strong>而且也不符合我们数据科学的运算（毕竟我们可以直接使用按位乘，然后再求和就行了）。</p><p>然后考虑到在运算过程中，<strong>卷积核是始终不变的！</strong>然后就给他翻转，或者不再进行反向运算了。不管怎么理解，总之是不再以那种奇怪的运算方式进行了。就变得正常了。再然后就是，这种称呼就被流传下来了...也就是称为<strong>卷积核</strong>(kernel)，当然也可以称之为滤波(filter)。</p><ul><li><p>平移不变性（translationinvariance）：不管检测对象出现在图像中的哪个位置，神经网络的前面几层应该对相同的图像区域具有相似的反应，即为“平移不变性”。</p></li><li><p>局部性（locality）：神经网络的前面几层应该只探索输入图像中的局部区域，而不过度在意图像中相隔较远区域的关系，这就是“局部性”原则。最终，可以聚合这些局部特征，以在整个图像级别进行预测。</p></li><li><p>输入图片大小是<spanclass="math inline">\(m,n\)</span>，卷积核大小是<spanclass="math inline">\(k,l\)</span>，输出大小为<spanclass="math inline">\((m-k+1, n-l+1)\)</span></p></li><li><p>padding 填充</p><ul><li><p>填充<span class="math inline">\(p_h\)</span>行和<spanclass="math inline">\(p_w\)</span>​列，输出形状为： <spanclass="math display">\[(n_h-k_h+p_h+1)\times(n_w-k_w+p_w+1)\]</span></p></li><li><p>通常取<span class="math inline">\(p_h=k_h-1\)</span>，<spanclass="math inline">\(p_w=k_w-1\)</span></p><ul><li>当<spanclass="math inline">\(k_h\)</span>为奇数：在上下两侧填充<spanclass="math inline">\(p_h/2\)</span></li><li>当<span class="math inline">\(k_h\)</span>为偶数：在上侧填充<spanclass="math inline">\(\lceil p_h/2\rceil\)</span>，在下侧填充<spanclass="math inline">\(\lfloor p_h/2\rfloor\)</span></li></ul></li></ul></li><li><p>stride 步幅 <span class="math display">\[\lfloor(n_h-k_h+p_h+s_h)/s_h\rfloor \times\lfloor(n_w-k_w+p_w+s_w)/s_w\rfloor\]</span></p><ul><li>如果<span class="math inline">\(p_h=k_h-1\)</span>，<spanclass="math inline">\(p_w=k_w-1\)</span>，输出形状为：<spanclass="math inline">\(\lfloor(n_h+s_h-1)/s_h\rfloor \times\lfloor(n_w+s_w-1)/s_w\rfloor\)</span></li><li>如果输入高度和宽度可以被步幅整除，输出形状为：<spanclass="math inline">\((n_h/s_h)\times(n_w/s_w)\)</span></li></ul></li><li><p>多个输入通道</p><ul><li>每个通道都有一个卷积核，结果是所有通道卷积结果的和</li></ul></li><li><p>多个输出通道</p><ul><li>使用多个三维卷积核，每个核生成一个输出通道</li><li>输入<span class="math inline">\(X:c_i\times n_h\timesn_w\)</span></li><li>核<span class="math inline">\(W:c_o\times c_i\times k_h\timesk_w\)</span></li><li>输出<span class="math inline">\(Y:c_o\times m_h\timesm_w\)</span></li></ul></li><li><p>每个输出通道可以识别特点模式</p></li><li><p>输入通道核识别并组合输入中的模式</p></li></ul><h2 id="池化层">池化层</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 使用指南</title>
    <link href="/2024/08/31/GitHub%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2024/08/31/GitHub%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="github-使用指南">GitHub 使用指南</h1><h2 id="介绍">介绍</h2><p><del>GitHub 是全世界最大的同性交友平台</del></p><p>GitHub是一个基于web的版本控制和代码管理平台，以及一个面向开源及私有软件项目的托管平台。它使用Git这一分布式版本控制系统，允许用户跟踪源代码历史记录，合作进行软件开发。</p><p>学会了GitHub的使用，提升程序员自我修养</p><h2 id="git概念">Git概念</h2><p>Git有如下结构</p><p><img src="repo.png" /></p><h2 id="命令介绍">命令介绍</h2><ul><li>git init：把当前目录变成Git可以管理的仓库</li><li>git add xxx.txt xxx.c：告诉Git，把文件添加到仓库</li><li>git commit -m"xxx"：告诉Git，把文件提交到仓库，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</li><li>git status：掌握仓库当前的状态</li><li>git diff xxx.txt：查看修改了什么</li><li>gitlog：显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数</li><li>git reset：回退之前的版本<ul><li>git reset --hard HEAD^</li><li>在Git中，用HEAD表示当前版本，上一个版本就是HEAD，上上一个版本就是HEAD^^，往上100个版本HEAD~100</li><li>--hard会回退到上个版本的已提交状态，而--soft会回退到上个版本的未提交状态，--mixed会回退到上个版本已添加但未提交的状态</li><li>还可以指定提交的id，git reflog可以查看提交的id</li></ul></li><li></li></ul><h2 id="工作流">工作流</h2><p>无论是开发个人项目，还是参与开源项目，一个良好的版本管理都是必不可少的，下面将分步介绍参与开发的工作流程。</p><ol type="1"><li>将远程仓库拉取到本地</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/example/example.git<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>不管是增加新功能还是修复bug，推荐建立一个新的分支。这样不会影响主分支，并且有利于多人合作。下面命令将新建命名为<strong>my-feature</strong>的分支，并切换到该分支上</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b my-feature<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>开始增加新代码、修复bug等工作，在完成后保存文件</li><li>查看修改的代码，明确知道增加修改了哪些部分</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>将修改的文件告知git，存放于暂存区中</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;changed_file&gt;<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>将修改放到git中</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>把修改推送到github中</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin my-feature<br></code></pre></td></tr></table></figure><ol start="8" type="1"><li>比较常见的情况是，在本地修改代码的过程中，main分支发生了更新，此时需要额外进行操作。首先切换到main分支</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br></code></pre></td></tr></table></figure><ol start="9" type="1"><li>将远端仓库的main分支和本地的main分支进行同步</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bahs">git pull origin main<br></code></pre></td></tr></table></figure><ol start="10" type="1"><li>再切换到my-feature分支上</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout my-feature<br></code></pre></td></tr></table></figure><ol start="11" type="1"><li>把main的修改拿过来，先不管my-feature分支的修改，然后再同步自己的commit，有可能会产生冲突，需要手动选择</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase main<br></code></pre></td></tr></table></figure><ol start="12" type="1"><li>推送到远端的my-feature分支，加-f参数是因为上一步用了rebase，需要强制push上去</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -f origin my-feature<br></code></pre></td></tr></table></figure><ol start="13" type="1"><li><p>将my-feature分支请求同步到main分支上，在项目管理中认为main分支是属于项目，各种feature分支属于个人</p></li><li><p>项目的管理者在审查代码后，在GitHub上点击squash andmerge按钮，将会把my-feature分支上的所有commit合并变成一个commit，然后同步到main分支上</p></li><li><p>在完成后，一般情况下会把远端的my-feature分支删掉，在GitHub上有个按钮deletebranch</p></li><li><p>删除掉本地的my-feature分支</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D my-feature<br></code></pre></td></tr></table></figure><ol start="17" type="1"><li>拉取最新的main分支更新</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin main<br></code></pre></td></tr></table></figure><h2 id="参考学习">参考学习</h2><ol type="1"><li><ahref="https://liaoxuefeng.com/books/git/introduction/index.html">简介 -Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></li><li>【十分钟学会正确的github工作流，和开源作者们使用同一套流程】https://www.bilibili.com/video/BV19e4y1q7JJ/?share_source=copy_web&amp;vd_source=847c0a3f4f4308f33186fa5871a0761b</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python-可变值做默认参数</title>
    <link href="/2024/08/31/Python-%E5%8F%AF%E5%8F%98%E5%80%BC%E5%81%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    <url>/2024/08/31/Python-%E5%8F%AF%E5%8F%98%E5%80%BC%E5%81%9A%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="python-可变值做默认参数">Python 可变值做默认参数</h1><h2 id="示例">示例</h2><p>在Python语法中，可以为函数设置默认参数，可以更好的方便方法的扩展</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, skill = []</span>):<br>        self.name = name<br>        self.skill = skill<br><br>p1 = Person(<span class="hljs-string">&quot;A&quot;</span>)<br>p2 = Person(<span class="hljs-string">&quot;B&quot;</span>)<br>p3 = Person(<span class="hljs-string">&quot;C&quot;</span>, [<span class="hljs-string">&quot;basketball&quot;</span>])<br><br>p1.skill.append(<span class="hljs-string">&quot;swim&quot;</span>)<br><br><span class="hljs-built_in">print</span>(p1.skill)<br><span class="hljs-built_in">print</span>(p2.skill)<br><span class="hljs-built_in">print</span>(p3.skill)<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-string">&#x27;swim&#x27;</span>]<br>[<span class="hljs-string">&#x27;swim&#x27;</span>]<br>[<span class="hljs-string">&#x27;basketball&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="解释">解释</h2><p>在Python中，默认参数只计算一次，当函数定义被解析时。这意味着，如果使用一个可变对象（如列表）作为默认参数，并且随后修改了这个对象，那么这个修改将会影响到所有后续的函数调用，这些调用使用了默认值。</p><h2 id="改进">改进</h2><p>使用None作为默认参数，然后在内部进行判断，即可解决这个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, skill=<span class="hljs-literal">None</span></span>):<br>        self.name = name<br>        <span class="hljs-keyword">if</span> skill <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            skill = []<br>        self.skill = skill<br><br>p1 = Person(<span class="hljs-string">&quot;A&quot;</span>)<br>p2 = Person(<span class="hljs-string">&quot;B&quot;</span>)<br>p3 = Person(<span class="hljs-string">&quot;C&quot;</span>, [<span class="hljs-string">&quot;basketball&quot;</span>])<br><br>p1.skill.append(<span class="hljs-string">&quot;swim&quot;</span>)<br><br><span class="hljs-built_in">print</span>(p1.skill)<br><span class="hljs-built_in">print</span>(p2.skill)<br><span class="hljs-built_in">print</span>(p3.skill)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-string">&#x27;swim&#x27;</span>]<br>[]<br>[<span class="hljs-string">&#x27;basketball&#x27;</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>坑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-测试</title>
    <link href="/2024/08/07/Python-%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/08/07/Python-%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="python-测试">Python-测试</h1><p>在写代码中，测试是确认程序的运行结果是否是期待的结果，在写测试的时候必须要知道正确的值，下面介绍Python中简单的测试如何实现，使用标准库unittest进行测试</p><h2 id="流程">流程</h2><ol type="1"><li>创建一个测试包命名为<code>tests</code>，每一个测试文件必须是<code>test_</code>开头</li><li>在测试文件中要导入<code>unittest</code>包，导入要测试代码对应的包</li><li>写测试类，必须继承<code>unittest.TestCase</code>类，类名通常以<code>Test</code>开头或结尾</li><li>写测试方法，每个测试类中可以有若干个测试方法，测试方法必须以<code>test_</code>开头</li><li>在unittest库中，有一组以<code>self.assert</code>开头的方法，用于判断计算值是否等于预期值，详见文档：<ahref="https://docs.python.org/zh-cn/3/library/unittest.html#assert-methods">unittest--- 单元测试框架 — Python 3.12.4 文档</a></li><li>对于每个测试方法，只要其中有一个地方的测试出现失败，就不会继续向下运行</li></ol><blockquote><p>以上流程即对应的文件结构是推荐的文件组织方式，也可以不遵循</p></blockquote><h2 id="示例">示例</h2><ul><li>文件结构：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── example.py<br>├── tests<br>│   ├── __init__.py<br>│   └── test_vector.py<br>└── vector<br>    ├── __init__.py<br>    └── vector.py<br></code></pre></td></tr></table></figure><ul><li>vector/vector.py:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(x, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>)) <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(y, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>)):<br>            self.x = x<br>            self.y = y<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;not a number&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> Vector(self.x + other.x, self.y + other.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mul</span>(<span class="hljs-params">self, factor</span>):<br>        <span class="hljs-keyword">return</span> Vector(self.x * factor, self.y * factor)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dot</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.x * other.x + self.y * other.y<br></code></pre></td></tr></table></figure><ul><li>vector/__init__.py:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .vector <span class="hljs-keyword">import</span> Vector<br></code></pre></td></tr></table></figure><ul><li>tests/test_vector.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">from</span> vector <span class="hljs-keyword">import</span> Vector<br><span class="hljs-keyword">import</span> sys<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestVector</span>(unittest.TestCase):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_init</span>(<span class="hljs-params">self</span>):<br>        v = Vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        self.assertEqual(v.x, <span class="hljs-number">1</span>)<br>        self.assertEqual(v.y, <span class="hljs-number">2</span>)<br><br>        <span class="hljs-keyword">with</span> self.assertRaises(ValueError):<br>            v = Vector(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br><br>    <span class="hljs-comment"># 测试跳过条件</span><br><span class="hljs-meta">    @unittest.skipIf(<span class="hljs-params">sys.platform == <span class="hljs-string">&quot;win32&quot;</span>, <span class="hljs-string">&quot;Do not support Windows.&quot;</span></span>)</span><br><span class="hljs-meta">    @unittest.skipIf(<span class="hljs-params">sys.version_info &lt; (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">7</span></span>), <span class="hljs-string">&quot;only support 3.7+&quot;</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add</span>(<span class="hljs-params">self</span>):<br>        v1 = Vector(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        v2 = Vector(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>        result = v1.add(v2)<br>        self.assertEqual(result.x, <span class="hljs-number">4</span>)<br>        self.assertEqual(result.y, <span class="hljs-number">6</span>)<br><br>    <span class="hljs-comment"># 每个方法执行前</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUp</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start&quot;</span>)<br><br>    <span class="hljs-comment"># 每个方法执行后</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tearDown</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br><br>    <span class="hljs-comment"># 每个类执行前</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;TestVector start&quot;</span>)<br><br>    <span class="hljs-comment"># 每个类执行后</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tearDownClass</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;TestVector end&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="运行">运行</h2><ul><li>在项目根目录下运行以下命令，将会执行所有测试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m unittest<br></code></pre></td></tr></table></figure><ul><li>运行以下指令，将会执行指定的测试文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m unittest tests.test_vector<br></code></pre></td></tr></table></figure><ul><li>运行以下指令，将会执行指定的测试方法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m unittest tests.test_vector.TestVector.test_add<br></code></pre></td></tr></table></figure><h2 id="测试评价">测试评价</h2><ul><li><p>衡量一个单元测试写的好不好，最简单的方法是计算单元测试的覆盖率，即测试运行了多少待测试代码。</p></li><li><p>覆盖率中最基础的是行覆盖率，即运行的行占待测试代码行的比率</p></li><li><p>使用<code>coverage</code>库可以进行代码的行覆盖率，在执行代码时将<code>python</code>换成<code>coverage run</code>，在此路径下将会得到一个<code>.coverage</code>二进制文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">coverage run -m unittest tests.test_vector.TestVector.test_add<br></code></pre></td></tr></table></figure><ul><li>运行以下命令即可导出覆盖率数据，-m参数显示哪行没有被覆盖到<ul><li>-m参数输出没有被覆盖到的行</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">coverage report -m<br></code></pre></td></tr></table></figure><ul><li>运行以下命令会创建一个htmlcov文件夹，运行http服务器即可在网页端查看测试结果，点击对应文件可以查看代码对照</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">coverage html<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m http.server --directory htmlcov/<br></code></pre></td></tr></table></figure><ul><li>如果要测试的是一个安装的库，用上面的coveragerun得到的覆盖率数据是不包含库的，因为在默认情况下是不计算安装库的源代码覆盖率，增加--source库名 即可专门测试这个库的覆盖率</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">coverage run --<span class="hljs-built_in">source</span> unittest -m unittest<br></code></pre></td></tr></table></figure><p>--omit=路径</p><p>参数可以忽略一些文件</p><p>要是觉得每次输出的命令太长了，可以创建一个.coveragerc文件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">[run]<br><span class="hljs-attribute">omit</span> <span class="hljs-operator">=</span> 路径<br>文件<br></code></pre></td></tr></table></figure><ul><li><p>可以利用Github actions来帮助进行测试，在Githubactions上跑这些单元测试，产生一个XML report，最后使用codecovaction，把report上传到codecov上，该网站即可生成美观的报告</p></li><li><p>如果某行代码不需要测试，在后面加上 # pragma: no cover</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PCL1.14.1-Windows配置</title>
    <link href="/2024/07/30/PCL1-14-1-Windows%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/07/30/PCL1-14-1-Windows%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>配置参考链接：<ahref="https://blog.csdn.net/m0_50910915/article/details/128651063">Windows11+VS2022+PCL1.13.0安装配置记录_ubuntu安装pcl1.13-CSDN博客</a></p><h1 id="公用设置">公用设置</h1><ol type="1"><li>SDL检查设置为否</li><li>VC++包含目录添加如下路径</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\include\pcl-<span class="hljs-number">1</span>.<span class="hljs-number">14</span><br><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\<span class="hljs-number">3</span>rdParty\Boost\include\boost-<span class="hljs-number">1</span>_84<br><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\<span class="hljs-number">3</span>rdParty\Eigen3\include\eigen3<br><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\<span class="hljs-number">3</span>rdParty\FLANN\include<br><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\<span class="hljs-number">3</span>rdParty\OpenNI2\Include<br><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\<span class="hljs-number">3</span>rdParty\Qhull\include<br><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\<span class="hljs-number">3</span>rdParty\VTK\include\vtk-<span class="hljs-number">9</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>VC++库目录添加如下路径</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\lib<br><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\<span class="hljs-number">3</span>rdParty\Boost\lib<br><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\<span class="hljs-number">3</span>rdParty\FLANN\lib<br><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\<span class="hljs-number">3</span>rdParty\OpenNI2\Lib<br><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\<span class="hljs-number">3</span>rdParty\Qhull\lib<br><span class="hljs-attribute">D</span>:\Projects\cpp_lib\PCL <span class="hljs-number">1</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span>\<span class="hljs-number">3</span>rdParty\VTK\lib<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>添加预处理器定义</li></ol><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">BOOST<span class="hljs-emphasis">_USE_WINDOWS_H</span><br><span class="hljs-emphasis">NOMINMAX</span><br><span class="hljs-emphasis">_CRT_SECURE_NO_</span>DEPRECATE<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>附加依赖项：PCL和VTK的Release的Lib和Debug的Lib不一样，以下是自动提取对应Lib的脚本，在此电脑上添加的路径具体查看<code>Release设置</code>和<code>Debug设置</code>中。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># File      :Extract_lib_to_txt.py</span><br><span class="hljs-comment"># Auther    :WooChi</span><br><span class="hljs-comment"># Time      :2022/06/08</span><br><span class="hljs-comment"># Version   :1.0</span><br><span class="hljs-comment"># Function  :自动提取lib文件夹下的.lib文件，根据文件名分别导出到release_lib.txt和debug_lib.txt中</span><br><br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Extract_lib</span>(<span class="hljs-params">path</span>):<br>    release = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;release_lib.txt&quot;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>    debug = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;debug_lib.txt&quot;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> os.listdir(path):<br>        <span class="hljs-keyword">if</span> file[-<span class="hljs-number">5</span>:] == <span class="hljs-string">&#x27;d.lib&#x27;</span>:<br>            debug.write(file)<br>            debug.write(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> file[-<span class="hljs-number">4</span>:] == <span class="hljs-string">&#x27;.lib&#x27;</span>:<br>            release.write(file)<br>            release.write(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    debug.close()<br>    release.close()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    path = <span class="hljs-string">r&quot;D:\Program Files (x86)\OPenCV\x64\vc16\lib&quot;</span><br>    Extract_lib(path)<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>C/C++ – 代码生成 – 启用增强指令集 – 选择高级矢量扩展</li></ol><blockquote><p>以上结束对属性表的设置，下面是对本项目的设置。</p><p>属性表配置好后可以进行备份，此后创建项目时可以直接使用此属性表避免了重复配置的问题。</p></blockquote><ol start="7" type="1"><li>项目-属性-调试-环境-编辑-添加环境</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">PATH=<span class="hljs-variable">$(PCL_ROOT)\b</span>in;<span class="hljs-variable">$(PCL_ROOT)\3</span>rdParty\FLANN\bin;<span class="hljs-variable">$(PCL_ROOT)\3</span>rdParty\VTK\bin;<span class="hljs-variable">$(PCL_ROOT)\3</span>rdParty\Qhull\bin;<span class="hljs-variable">$(PCL_ROOT)\3</span>rdParty\OpenNI2\Tools;<span class="hljs-variable">$(PATH)</span><br></code></pre></td></tr></table></figure><h1 id="release设置">Release设置</h1><p>附加依赖项</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vtkcgns</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkChartsCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkCommonColor</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkCommonComputationalGeometry</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkCommonCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkCommonDataModel</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkCommonExecutionModel</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkCommonMath</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkCommonMisc</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkCommonSystem</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkCommonTransforms</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkDICOMParser</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkDomainsChemistry</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkDomainsChemistryOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkdoubleconversion</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkexodusII</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkexpat</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersAMR</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersCellGrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersExtraction</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersFlowPaths</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersGeneral</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersGeneric</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersGeometry</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersGeometryPreview</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersHybrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersHyperTree</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersImaging</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersModeling</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersParallel</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersParallelImaging</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersPoints</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersProgrammable</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersReduction</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersSelection</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersSMP</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersSources</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersStatistics</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersTensor</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersTexture</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersTopology</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkFiltersVerdict</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkfmt</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkfreetype</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkGeovisCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkgl2ps</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkglew</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkhdf5</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkhdf5_hl</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkImagingColor</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkImagingCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkImagingFourier</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkImagingGeneral</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkImagingHybrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkImagingMath</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkImagingMorphological</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkImagingSources</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkImagingStatistics</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkImagingStencil</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkInfovisCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkInfovisLayout</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkInteractionImage</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkInteractionStyle</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkInteractionWidgets</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOAMR</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOAsynchronous</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOCellGrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOCesium3DTiles</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOCGNSReader</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOChemistry</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOCityGML</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOCONVERGECFD</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOEnSight</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOExodus</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOExport</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOExportGL2PS</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOExportPDF</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOFLUENTCFF</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOGeometry</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOHDF</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOImage</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOImport</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOInfovis</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOIOSS</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOLegacy</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOLSDyna</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOMINC</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOMotionFX</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOMovie</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIONetCDF</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOOggTheora</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOParallel</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOParallelXML</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOPLY</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOSegY</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOSQL</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkioss</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOTecplotTable</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOVeraOut</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOVideo</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOXML</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkIOXMLParser</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkjpeg</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkjsoncpp</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkkissfft</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtklibharu</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtklibproj</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtklibxml2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkloguru</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtklz4</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtklzma</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkmetaio</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtknetcdf</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkogg</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkParallelCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkParallelDIY</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkpng</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkpugixml</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingAnnotation</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingCellGrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingContext2D</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingContextOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingFreeType</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingGL2PSOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingHyperTreeGrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingImage</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingLabel</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingLICOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingLOD</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingSceneGraph</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingUI</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingVolume</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingVolumeOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkRenderingVtkJS</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtksqlite</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtksys</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkTestingRendering</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtktheora</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtktiff</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkverdict</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkViewsContext2D</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkViewsCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkViewsInfovis</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkWrappingTools</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">vtkzlib</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>.lib<br><span class="hljs-attribute">pcl_common</span>.lib<br><span class="hljs-attribute">pcl_features</span>.lib<br><span class="hljs-attribute">pcl_filters</span>.lib<br><span class="hljs-attribute">pcl_io</span>.lib<br><span class="hljs-attribute">pcl_io_ply</span>.lib<br><span class="hljs-attribute">pcl_kdtree</span>.lib<br><span class="hljs-attribute">pcl_keypoints</span>.lib<br><span class="hljs-attribute">pcl_ml</span>.lib<br><span class="hljs-attribute">pcl_octree</span>.lib<br><span class="hljs-attribute">pcl_outofcore</span>.lib<br><span class="hljs-attribute">pcl_people</span>.lib<br><span class="hljs-attribute">pcl_recognition</span>.lib<br><span class="hljs-attribute">pcl_registration</span>.lib<br><span class="hljs-attribute">pcl_sample_consensus</span>.lib<br><span class="hljs-attribute">pcl_search</span>.lib<br><span class="hljs-attribute">pcl_segmentation</span>.lib<br><span class="hljs-attribute">pcl_stereo</span>.lib<br><span class="hljs-attribute">pcl_surface</span>.lib<br><span class="hljs-attribute">pcl_tracking</span>.lib<br><span class="hljs-attribute">pcl_visualization</span>.lib<br></code></pre></td></tr></table></figure><h1 id="debug设置">Debug设置</h1><p>附加依赖项</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vtkcgns</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkChartsCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkCommonColor</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkCommonComputationalGeometry</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkCommonCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkCommonDataModel</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkCommonExecutionModel</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkCommonMath</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkCommonMisc</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkCommonSystem</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkCommonTransforms</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkDICOMParser</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkDomainsChemistry</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkDomainsChemistryOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkdoubleconversion</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkexodusII</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkexpat</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersAMR</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersCellGrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersExtraction</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersFlowPaths</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersGeneral</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersGeneric</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersGeometry</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersGeometryPreview</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersHybrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersHyperTree</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersImaging</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersModeling</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersParallel</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersParallelImaging</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersPoints</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersProgrammable</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersReduction</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersSelection</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersSMP</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersSources</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersStatistics</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersTensor</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersTexture</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersTopology</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkFiltersVerdict</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkfmt</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkfreetype</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkGeovisCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkgl2ps</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkglew</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkhdf5</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkhdf5_hl</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkImagingColor</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkImagingCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkImagingFourier</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkImagingGeneral</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkImagingHybrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkImagingMath</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkImagingMorphological</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkImagingSources</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkImagingStatistics</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkImagingStencil</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkInfovisCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkInfovisLayout</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkInteractionImage</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkInteractionStyle</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkInteractionWidgets</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOAMR</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOAsynchronous</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOCellGrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOCesium3DTiles</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOCGNSReader</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOChemistry</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOCityGML</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOCONVERGECFD</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOEnSight</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOExodus</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOExport</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOExportGL2PS</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOExportPDF</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOFLUENTCFF</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOGeometry</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOHDF</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOImage</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOImport</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOInfovis</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOIOSS</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOLegacy</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOLSDyna</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOMINC</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOMotionFX</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOMovie</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIONetCDF</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOOggTheora</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOParallel</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOParallelXML</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOPLY</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOSegY</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOSQL</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkioss</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOTecplotTable</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOVeraOut</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOVideo</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOXML</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkIOXMLParser</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkjpeg</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkjsoncpp</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkkissfft</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtklibharu</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtklibproj</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtklibxml2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkloguru</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtklz4</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtklzma</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkmetaio</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtknetcdf</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkogg</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkParallelCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkParallelDIY</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkpng</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkpugixml</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingAnnotation</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingCellGrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingContext2D</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingContextOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingFreeType</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingGL2PSOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingHyperTreeGrid</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingImage</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingLabel</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingLICOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingLOD</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingSceneGraph</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingUI</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingVolume</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingVolumeOpenGL2</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkRenderingVtkJS</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtksqlite</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtksys</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkTestingRendering</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtktheora</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtktiff</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkverdict</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkViewsContext2D</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkViewsCore</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkViewsInfovis</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkWrappingTools</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">vtkzlib</span>-<span class="hljs-number">9</span>.<span class="hljs-number">3</span>-gd.lib<br><span class="hljs-attribute">pcl_commond</span>.lib<br><span class="hljs-attribute">pcl_featuresd</span>.lib<br><span class="hljs-attribute">pcl_filtersd</span>.lib<br><span class="hljs-attribute">pcl_iod</span>.lib<br><span class="hljs-attribute">pcl_io_plyd</span>.lib<br><span class="hljs-attribute">pcl_kdtreed</span>.lib<br><span class="hljs-attribute">pcl_keypointsd</span>.lib<br><span class="hljs-attribute">pcl_mld</span>.lib<br><span class="hljs-attribute">pcl_octreed</span>.lib<br><span class="hljs-attribute">pcl_outofcored</span>.lib<br><span class="hljs-attribute">pcl_peopled</span>.lib<br><span class="hljs-attribute">pcl_recognitiond</span>.lib<br><span class="hljs-attribute">pcl_registrationd</span>.lib<br><span class="hljs-attribute">pcl_sample_consensusd</span>.lib<br><span class="hljs-attribute">pcl_searchd</span>.lib<br><span class="hljs-attribute">pcl_segmentationd</span>.lib<br><span class="hljs-attribute">pcl_stereod</span>.lib<br><span class="hljs-attribute">pcl_surfaced</span>.lib<br><span class="hljs-attribute">pcl_trackingd</span>.lib<br><span class="hljs-attribute">pcl_visualizationd</span>.lib<br></code></pre></td></tr></table></figure><h1 id="pcl测试">PCL测试</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/common/common_headers.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/io/pcd_io.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/visualization/pcl_visualizer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/visualization/cloud_viewer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pcl/console/parse.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Test PCL !!!&quot;</span> &lt;&lt; std::endl;<br><br>pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::<span class="hljs-function">Ptr <span class="hljs-title">point_cloud_ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZRGB&gt;)</span></span>;<br><span class="hljs-function"><span class="hljs-type">uint8_t</span> <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-number">15</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">15</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">float</span> <span class="hljs-built_in">z</span>(<span class="hljs-number">-1.0</span>); z &lt;= <span class="hljs-number">1.0</span>; z += <span class="hljs-number">0.05</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">float</span> <span class="hljs-built_in">angle</span>(<span class="hljs-number">0.0</span>); angle &lt;= <span class="hljs-number">360.0</span>; angle += <span class="hljs-number">5.0</span>)<br>&#123;<br>pcl::PointXYZRGB point;<br>point.x = <span class="hljs-number">0.5</span> * <span class="hljs-built_in">cosf</span>(pcl::<span class="hljs-built_in">deg2rad</span>(angle));<br>point.y = <span class="hljs-built_in">sinf</span>(pcl::<span class="hljs-built_in">deg2rad</span>(angle));<br>point.z = z;<br><span class="hljs-type">uint32_t</span> rgb = (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(r) &lt;&lt; <span class="hljs-number">16</span> |<br><span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(g) &lt;&lt; <span class="hljs-number">8</span> | <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(b));<br>point.rgb = *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">float</span>*&gt;(&amp;rgb);<br>point_cloud_ptr-&gt;points.<span class="hljs-built_in">push_back</span>(point);<br>&#125;<br><span class="hljs-keyword">if</span> (z &lt; <span class="hljs-number">0.0</span>)<br>&#123;<br>r -= <span class="hljs-number">12</span>;<br>g += <span class="hljs-number">12</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>g -= <span class="hljs-number">12</span>;<br>b += <span class="hljs-number">12</span>;<br>&#125;<br>&#125;<br><br>point_cloud_ptr-&gt;width = (<span class="hljs-type">int</span>)point_cloud_ptr-&gt;points.<span class="hljs-built_in">size</span>();<br>point_cloud_ptr-&gt;height = <span class="hljs-number">1</span>;<br><br>pcl::<span class="hljs-function">visualization::CloudViewer <span class="hljs-title">viewer</span><span class="hljs-params">(<span class="hljs-string">&quot;test&quot;</span>)</span></span>;<br>viewer.<span class="hljs-built_in">showCloud</span>(point_cloud_ptr);<br><span class="hljs-keyword">while</span> (!viewer.<span class="hljs-built_in">wasStopped</span>()) &#123;&#125;;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="问题及其解决方案">问题及其解决方案</h1><blockquote><p>【问题】pop_t未定义</p><p>【解决方案】</p><ol type="1"><li><p><ahref="https://blog.csdn.net/springslx/article/details/104639803/">“错误C3861 “pop_t”: 找不到标识符 ”_error: c3861: “qrand”:找不到标识符-CSDN博客</a></p></li><li><p><ahref="https://blog.csdn.net/qq_59241153/article/details/137168396">无法解析的外部符号LZ4_resetStreamHC_vs2022无法解析外部符号-CSDN博客</a></p></li></ol><p>修改1后会出现2的问题，然后再进行修改即可</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>推荐算法</title>
    <link href="/2024/07/23/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/23/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍">1 介绍</h1><ul><li>推荐系统就是根据用户和物品的历史交互数据，学习出用户对物品的偏好模式，进而从大量的用户尚未交互过的物品中自动识别出用户可能感兴趣的物品，形成个性化物品推荐。</li><li>常见的推荐系统分类<ul><li>基于用户反馈的推荐：协同过滤<ul><li>用户反馈可以分为显式反馈和隐式反馈两类，显示反馈是指用户主动且明确地表达了对物品的偏好程序，最常见的就是评分ratings。隐式反馈是指用户与物品有一些交互行为，但未明确或主动地表示具体的喜好程度，常见的形式有购买、浏览、播放等。</li><li>协同过滤的基本假设是：过往偏好相似的用户在未知物品上的喜好也是相近的</li><li>优点：不依赖于物品的内容和应用领域</li><li>缺点：用户反馈的数据非常稀疏有限，或者没有反馈数据。<strong>数据稀疏和冷启动</strong></li></ul></li><li>基于物品内容的推荐</li><li>基于用户反馈和物品内容的混合推荐</li><li>基于上下文信息的情景感知推荐</li><li>其他推荐模型</li></ul></li><li>推荐模型主要解决两类任务：评分预测和物品推荐</li><li>评分预测主要适用于基于显式反馈的推荐模型</li><li>物品推荐主要适用于基于隐式反馈的推荐模型</li><li>数据稀疏</li><li>冷启动</li></ul><h1 id="推荐算法介绍">2 推荐算法介绍</h1><h2 id="基于用户反馈的推荐-协同过滤">2.1基于用户反馈的推荐-协同过滤</h2><p>协同过滤算法主要分为两类：基于内存的推荐算法和基于模型的推荐算法</p><h3 id="基于内存的推荐算法">2.1.1 基于内存的推荐算法</h3><p>基于内存的推荐算法通过采用一些启发式假设来搜寻相似用户或物品，并利用统计方法生成个性化推荐。</p><p>基于内存的推荐算法又可以分为基于用户的协同过滤和基于物品的协同过滤</p><h4 id="基于用户的协同过滤">2.1.1.1 基于用户的协同过滤</h4><p>算法常见步骤：</p><ol type="1"><li>计算用户相似度</li><li>搜索相似用户群</li><li>生成个性化推荐</li></ol><p>计算用户间相似度常用公式是PCC和COS，基于用户的协同过滤使用PCC要比COS多，是因为PCC考虑了用户偏好的波动性。</p><p>在计算用户间相似度后，需要选出与用户最相似的用户群体，即相似用户群。选择的方法主要有<strong>阈值法</strong>和<strong>Top-K</strong>法。</p><p>阈值法是相似度大于某个阈值被选择为相似用户，阈值法对于阈值的选取是关键，阈值设置太小会将带有噪声的用户选择为相似用户，降低推荐性能。阈值设置太大，相似用户数过少，可能导致生成的推荐不够准确。</p><p>Top-K法是选择相似度排名前K位的用户作为相似用户，K的选择依赖大量的实际经验，且可能前K的用户相似度都不高，甚至是负值，无法确保所选用户的相似度一定会较高</p><p>因此，在实际中，通常将两种方法相结合。先指定一个必须满足的阈值，再确定一个合适的K值。</p><p>得到相似用户群后，就可以进行个性化推荐。可以使用相似用户对物品的评分均值、以相似度作为权重的评分、</p><h4 id="基于物品的协同过滤">2.1.1.2 基于物品的协同过滤</h4><p>步骤：</p><ol type="1"><li>计算物品相似度</li><li>搜索相似物品群</li><li>生成个性化推荐</li></ol><h3 id="基于模型的推荐算法">2.1.2 基于模型的推荐算法</h3><p>基于内存的推荐算法具有逻辑简单、易于实现、可解释性高等优点，但是基于模型的推荐算法才是现代推荐系统的主要发展方向。</p><p>基于模型的推荐算法在推荐准确定、可扩展性等方面有着较为明显的优势。</p><h4 id="基于矩阵分解的模型">2.1.2.1 基于矩阵分解的模型</h4><h1 id="测试评估">3 测试评估</h1><h2 id="评分预测任务的评估指标">3.1 评分预测任务的评估指标</h2><h2 id="物品推荐任务的评估指标">3.2 物品推荐任务的评估指标</h2><p>Top-N物品推荐的评估主要是针对预测的物品列表是否与用户偏好的一致性检测，常见的评估指标包括Precision、Recall、AUC、MAP、MRR、NDCG等</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CMake</title>
    <link href="/2024/05/11/CMake/"/>
    <url>/2024/05/11/CMake/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识">1 基础知识</h1><ul><li>要想将编写的C/C++源文件变成可执行二进制程序，需要经过<code>编译器/Toolchain</code>的处理，总共会经过以下几个步骤：<ol type="1"><li>预处理阶段：把头文件导入、替换宏、去掉注释等；最终得到的是处理过后的源文件</li><li>编译阶段：gcc、g++；最终得到汇编文件</li><li>汇编阶段：将汇编文件进行处理；最终得到二进制文件，.obj(Windows).o(.o)</li><li>链接阶段：将多个二进制文件进行链接；最终得到一个可执行二进制程序</li></ol></li><li>对于少量的源代码，我们可以通过手敲命令将其变成可执行程序。但是如果项目中文件较多，那么需要输入的命令就会特别多且繁琐，不容易维护。</li><li>对于以上问题，要么写一个makefile，要么通过CMake<ul><li>makefile需要写一个makefile文件，通过一系列指令告诉编译器如何编译。该文件，还需要批处理命令make进行执行该文件。</li><li>CMake比makefile更高级，不依赖于平台，可以对不同的平台生成对应的makefile；需要创建<code>CMakeLists.txt</code>文件，使用命令cmake生成makefile文件，然后通过make进行执行</li></ul></li></ul><h1 id="初步使用">2 初步使用</h1><ul><li>现在有以下文件代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// add.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// sub.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a-b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mult.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a*b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// div.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)a/b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// head.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _HEAD_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _HEAD_H</span><br><span class="hljs-comment">// 加法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-comment">// 减法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-comment">// 乘法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-comment">// 除法</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">12</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d, b = %d\n&quot;</span>, a, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a + b = %d\n&quot;</span>, <span class="hljs-built_in">add</span>(a, b));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a - b = %d\n&quot;</span>, <span class="hljs-built_in">subtract</span>(a, b));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a * b = %d\n&quot;</span>, <span class="hljs-built_in">multiply</span>(a, b));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a / b = %f\n&quot;</span>, <span class="hljs-built_in">divide</span>(a, b));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="g手动编译运行">g++手动编译运行</h2><p>编译指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ *.cpp -o app<br></code></pre></td></tr></table></figure><p>运行可执行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./app<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">a = 20, b = 12<br>a + b = 32<br>a - b = 8<br>a * b = 240<br>a / b = 1.666667<br></code></pre></td></tr></table></figure><h2 id="cmake编译执行">CMake编译执行</h2><p>在源代码同级目录下创建文件<code>CMakeLists.txt</code>，内容为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">add_executable</span>(app add.c div.c main.c mult.c sub.c)<br></code></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake .<br>make<br>./app<br></code></pre></td></tr></table></figure><p>由于在执行<code>cmake .</code>的时候会生成其他文件，所以我们一般创建一个build目录，然后将编译生成的文件放在该目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake ..<br>make<br>./app<br></code></pre></td></tr></table></figure><h1 id="命令解析">3 命令解析</h1><p>以下对cmake中使用到的命令进行解析说明</p><h2 id="注释">注释</h2><ul><li><p>单行注释：# 单行注释</p></li><li><p>多行注释：#[[多行注释]]</p></li></ul><h2 id="最低版本">最低版本</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>指定使用的 cmake 的最低版本，可选，非必须，如果不加可能会有警告</p><h2 id="定义工程名称">定义工程名称</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># PROJECT 指令的语法是：</span><br><span class="hljs-keyword">project</span>(&lt;<span class="hljs-keyword">PROJECT</span>-NAME&gt; [&lt;language-name&gt;...])<br><span class="hljs-keyword">project</span>(&lt;<span class="hljs-keyword">PROJECT</span>-NAME&gt;<br>       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]<br>       [DESCRIPTION &lt;<span class="hljs-keyword">project</span>-description-<span class="hljs-keyword">string</span>&gt;]<br>       [HOMEPAGE_URL &lt;url-<span class="hljs-keyword">string</span>&gt;]<br>       [LANGUAGES &lt;language-name&gt;...])<br></code></pre></td></tr></table></figure><p>定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。</p><h2 id="生成可执行文件">生成可执行文件</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(可执行程序名 源文件名称)<br></code></pre></td></tr></table></figure><p>这里的可执行程序名和project中的项目名没有任何关系</p><p>源文件名可以是一个也可以是多个，如有多个可用空格或;间隔</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 样式1</span><br><span class="hljs-keyword">add_executable</span>(app add.c div.c main.c mult.c sub.c)<br><span class="hljs-comment"># 样式2</span><br><span class="hljs-keyword">add_executable</span>(app add.c;div.c;main.c;mult.c;sub.c)<br></code></pre></td></tr></table></figure><h2 id="set命令">set命令</h2><ul><li>set命令在cmake中一共有三个功能：<ul><li>设置字符类型变量</li><li>指定C++标准</li><li>指定输出路径</li></ul></li></ul><h3 id="设置变量">设置变量</h3><p>在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用set。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># SET 指令的语法是：</span><br><span class="hljs-comment"># [] 中的参数为可选项, 如不需要可以不写</span><br><span class="hljs-keyword">SET</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])<br></code></pre></td></tr></table></figure><ul><li>VAR：变量名，大小写均可</li><li>VALUE：变量值</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 方式1: 各个源文件之间使用空格间隔</span><br><span class="hljs-comment"># set(SRC_LIST add.cpp div.cpp main.cpp mult.cpp sub.cpp)</span><br><br><span class="hljs-comment"># 方式2: 各个源文件之间使用分号 ; 间隔</span><br><span class="hljs-keyword">set</span>(SRC_LIST add.cpp;div.cpp;main.cpp;mult.cpp;sub.cpp)<br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="指定c标准">指定C++标准</h3><p>在编写C++程序的时候，可能会用到C++11、C++14、C++17、C++20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准：</p><p>在原始g++中命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ *.cpp -std=c++11 -o app<br></code></pre></td></tr></table></figure><p>C++标准对应有一个宏叫做<code>DCMAKE_CXX_STANDARD</code>，在CMake中想要指定C++标准有两种方式</p><p>在 CMakeLists.txt 中通过 set 命令指定</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#增加-std=c++11</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-comment">#增加-std=c++14</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<br><span class="hljs-comment">#增加-std=c++17</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><p>在执行 cmake 命令的时候指定出这个宏的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#增加-std=c++11</span><br>cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11<br><span class="hljs-comment">#增加-std=c++14</span><br>cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14<br><span class="hljs-comment">#增加-std=c++17</span><br>cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17<br></code></pre></td></tr></table></figure><h3 id="指定输出路径">指定输出路径</h3><p>在CMake中指定可执行程序输出的路径，也对应一个宏，叫做<code>EXECUTABLE_OUTPUT_PATH</code>，它的值还是通过set命令进行设置:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(HOME /home/robin/Linux/Sort)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;HOME&#125;</span>/bin)<br></code></pre></td></tr></table></figure><ul><li>第一行：定义一个变量用于存储一个绝对路径</li><li>第二行：将拼接好的路径值设置给<code>EXECUTABLE_OUTPUT_PATH</code>宏<ul><li>如果这个路径中的子目录不存在，会自动生成，无需自己手动创建</li></ul></li></ul><p>由于可执行程序是基于 cmake 命令生成的 makefile 文件然后再执行 make命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径./xxx/xxx，那么这个路径中的 ./ 对应的就是 makefile文件所在的那个目录。使用者应该根据使用的场景进行选择使用绝对路径和相对路径</p><p>此时可以将样例中的CMakeLists.txt修改为如下格式：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(SRC add.cpp div.cpp main.cpp mult.cpp sub.cpp)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH /home/bjx/CMakeTest/output)<br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="搜索文件">搜索文件</h2><p>在set中设置变量的方式可以替换掉多个文件，但是仍然没有减少我们的工作，我们需要程序自动搜索对应路径下的源代码文件，减少我们的手动工作，此时我们需要使用cmake中的搜索文件的功能</p><p>在CMake中为我们提供了搜索文件的命令，可以使用<code>aux_source_directory</code>命令或者<code>file</code>命令</p><h3 id="aux_source_directory">aux_source_directory</h3><p>在 CMake中使用<code>aux_source_directory</code>命令可以查找某个路径下的所有源文件，命令格式为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">aux_source_directory</span>(&lt; dir &gt; &lt; variable &gt;)<br></code></pre></td></tr></table></figure><ul><li>dir：要搜索的目录</li><li>variable：将从dir目录下搜索到的源文件列表存储到该变量中</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">aux_source_directory</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span> SRC)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH /home/bjx/CMakeTest/output)<br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="file">file</h3><p>如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦了。所以，在CMake中为我们提供了搜索文件的命令，他就是file（当然，除了搜索以外通过file 还可以做其他事情）。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)<br></code></pre></td></tr></table></figure><ul><li>GLOB:将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</li><li>GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</li></ul><p>搜索当前目录的src目录下所有的源文件，并存储到变量中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB MAIN_SRC <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-keyword">file</span>(GLOB MAIN_HEAD <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/*.h)<br></code></pre></td></tr></table></figure><p>CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt文件所在的路径。</p><p>关于要搜索的文件路径和类型可加双引号，也可不加:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB MAIN_HEAD <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.h&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH /home/bjx/CMakeTest/output)<br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><blockquote><ul><li><strong><code>cmake_current_source_dir</code></strong>：此变量表示CMake当前正在处理的源目录的完整路径。它的值随着CMakeLists.txt文件的处理进程动态变化。当CMake在处理某个目录下的CMakeLists.txt文件时，<code>cmake_current_source_dir</code>就会被设置为那个目录的路径。因此，这个变量通常用于访问当前处理的CMakeLists.txt文件所在目录中的文件。</li><li><strong><code>project_source_dir</code></strong>：这个变量则代表整个项目的源码目录，也就是项目顶层CMakeLists.txt所在的目录。与<code>cmake_current_source_dir</code>不同，<code>project_source_dir</code>在整个项目构建过程中是固定不变的，它不会随着当前处理的CMakeLists.txt文件的不同而改变。</li></ul></blockquote><h2 id="包含头文件">包含头文件</h2><ul><li>在上面使用的项目中，源文件和头文件都位于一个文件夹下。对于大型项目来说，这种代码结构方式是不够方便直观的，一般我们会将源代码放在src目录下，头文件放在include目录下。但是此时会出现一个问题，对于源文件来说，如何去寻找对应的头文件。</li><li>解决这个问题的方法有两种：<ol type="1"><li>直接修改源文件的include中的路径，使用相对路径找到对应的头文件</li><li>在CMakeLists.txt文件中将头文件的路径加入进来</li></ol></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">include_directories</span>(headpath)<br></code></pre></td></tr></table></figure><p>将上面的CMakeLists.txt中的内容修改成如下格式</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/output)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><p>此时就可以调整代码结构，而不用修改代码</p><h2 id="制作库文件">制作库文件</h2><ul><li>在编写代码时，有时候我们想要输出的不是可执行程序，而是可以使用的库。库又分为静态库和动态库两种，下面将分别进行介绍编写过程。</li><li>首先上面的代码中main.cpp相当于一个测试程序，我们将其从src目录中移动到根目录中，此时src目录下只有四个源文件</li></ul><h3 id="制作静态库">制作静态库</h3><ul><li>在cmake中，如果要制作静态库，需要使用的命令如下：</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(库名称 STATIC 源文件<span class="hljs-number">1</span> [源文件<span class="hljs-number">2</span>] ...)<br></code></pre></td></tr></table></figure><ul><li><p>在Linux中，静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p></li><li><p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">add_library</span>(calc STATIC <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><ul><li>通过cmake，make命令执行后，即可看到当前文件夹中生成了<code>libcalc.a</code>静态库，在命令行中显示为黑色，是因为静态库没有可执行权限</li></ul><h3 id="制作动态库">制作动态库</h3><ul><li>和静态库命令相同，只需要将STATIC换成SHARED即可</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">add_library</span>(calc SHARED <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><ul><li>通过cmake，make命令执行后，即可看到当前文件夹中生成了<code>libcalc.so</code>静态库，在命令行中显示为绿色，动态库是有可执行权限</li></ul><h3 id="指定库文件输出路径">指定库文件输出路径</h3><ul><li>为了让生成的库文件输出到指定的位置，我们可以通过命令指示输出路径。对于静态库和动态库来说有一种共用的方式，对于动态库来说由于其有可执行权限，所以还可以有另一种方式</li><li>方式一：<ul><li>使用<code>LIBRARY_OUTPUT_PATH</code>宏，即可指定静态库和动态库的输出位置</li></ul></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(CALC)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-keyword">add_library</span>(calc SHARED <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><ul><li>方式二：（不推荐，我也没有执行成功）<ul><li>由于动态库有可执行权限，我们还可以通过设置<code>EXECUTABLE_OUTPUT_PATH</code>宏来指定生成路径</li><li><code>set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</code></li></ul></li></ul><h2 id="使用库文件">使用库文件</h2><ul><li>无论是使用静态库还是动态库，发布给用户的都应该包括库文件和对应的头文件，头文件用于指示使用者调用的接口</li><li>我们将之前的项目中生成的动态库放到sharedlib文件夹下，静态库放到staticlib文件夹下，然后删除src目录及其所有文件，删除原lib目录</li></ul><h3 id="使用静态库">使用静态库</h3><ul><li>cmake中链接静态库的命令为：</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])<br></code></pre></td></tr></table></figure><ul><li><p>参数1：指定出要链接的静态库的名字</p><ul><li>可以是全名 libxxx.a</li><li>也可以是掐头（lib）去尾（.a）之后的名字 xxx</li></ul></li><li><p>参数2-N：要链接的其它静态库的名字</p></li><li><p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">link_directories</span>(&lt;lib path&gt;)<br></code></pre></td></tr></table></figure><p>通过以上两个命令将CMakeLists.txt修改为如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(calctest)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)<br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/staticlib)<br><span class="hljs-keyword">link_libraries</span>(libcalc.a)<br><span class="hljs-keyword">add_executable</span>(calctest <span class="hljs-variable">$&#123;SRC&#125;</span>)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/output)<br></code></pre></td></tr></table></figure><h3 id="使用动态库">使用动态库</h3><p>在cmake中链接动态库的命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(<br>    &lt;<span class="hljs-keyword">target</span>&gt; <br>    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... <br>    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)<br></code></pre></td></tr></table></figure><ul><li><p>target：指定要加载动态库的文件的名字</p><ul><li>该文件可能是一个源文件</li><li>该文件可能是一个动态库文件</li><li>该文件可能是一个可执行文件</li></ul></li><li><p>PRIVATE|PUBLIC|INTERFACE：动态库的访问权限，默认为<code>PUBLIC</code></p><ul><li><p>如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，<code>一般无需指定，使用默认的PUBLIC即可</code>。</p></li><li><p><code>动态库的链接具有传递性</code>，如果动态库A链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(A B C)<br><span class="hljs-keyword">target_link_libraries</span>(D A)<br></code></pre></td></tr></table></figure></li><li><p>PUBLIC：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。</p></li><li><p>PRIVATE：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库</p></li><li><p>INTERFACE：在interface后面引入的库不会被链接到前面的target中，只会导出符号。target只知道有函数，但是不知道来自于谁。</p></li></ul></li></ul><p>动态库的链接和静态库是完全不同的：</p><ul><li>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。</li><li>动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存</li></ul><p>因此，在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(calctest)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/output)<br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/sharedlib)<br><span class="hljs-keyword">add_executable</span>(calctestshared <span class="hljs-variable">$&#123;SRC&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(calctestshared libcalc.so)<br></code></pre></td></tr></table></figure><ul><li>此时要保证动态库所在路径和源代码的结构相同</li></ul><h2 id="日志">日志</h2><p>在CMake中可以为用户显示一条消息，该命令的名字为message：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="hljs-string">&quot;message to display&quot;</span> ...)<br></code></pre></td></tr></table></figure><ul><li>(无) ：重要消息</li><li>STATUS ：非重要消息</li><li>WARNING：CMake 警告，会继续执行</li><li>AUTHOR_WARNING：CMake 警告 (dev)，会继续执行</li><li>SEND_ERROR：CMake 错误，继续执行，但是会跳过生成的步骤</li><li>FATAL_ERROR：CMake 错误，终止所有处理过程</li></ul><p>CMake的命令行工具会在stdout上显示STATUS消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。</p><p>CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 输出一般日志信息</span><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br><br><span class="hljs-comment"># 输出警告信息</span><br><span class="hljs-keyword">message</span>(WARNING <span class="hljs-string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br><br><span class="hljs-comment"># 输出错误信息</span><br><span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python多线程and多进程</title>
    <link href="/2024/04/30/Python%E5%A4%9A%E7%BA%BF%E7%A8%8Band%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <url>/2024/04/30/Python%E5%A4%9A%E7%BA%BF%E7%A8%8Band%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="python多线程和多进程">Python多线程和多进程</h1><ul><li>在某些场景下，单线程的执行任务往往不能满足我们的需求，此时我们需要使用多线程甚至多进程技术来解决。</li><li>从Python3.2开始，标准库为我们提供了 concurrent.futures模块，它提供了 ThreadPoolExecutor (线程池)和ProcessPoolExecutor(进程池)两个类，我们可以使用这两个类轻松的使用线程池和进程池进行编程。</li><li>concurrent.futures 模块相比 threading 等模块，该模块通过 submit返回的是一个 future对象，它是一个未来可期的对象，通过它可以获悉线程的状态主线程(或进程)中可以获取某一个线程(进程)执行的状态或者某一个任务执行的状态及返回值：<ol type="1"><li>主线程可以获取某一个线程（或者任务的）的状态，以及返回值。</li><li>当一个线程完成的时候，主线程能够立即知道。</li><li>让多线程和多进程的编码接口一致。</li></ol></li></ul><h2 id="多线程">多线程</h2><h3 id="介绍">介绍</h3><ul><li><p>Python的多线程，只有用于I/O密集型程序时效率才会有明显的提高。</p></li><li><p>原因如下：</p><ul><li>Python代码的执行是由Python虚拟机进行控制。它在主循环中同时只能有一个控制线程在执行，意思就是Python解释器中可以运行多个线程，但是在执行的只有一个线程，其他的处于等待状态。</li><li>这些线程执行是有全局解释器锁（GIL）控制，它来保证同时只有一个线程在运行。在多线程运行环境中，Python虚拟机执行方式如下：<ol type="1"><li>设置GIL</li><li>切换进线程</li><li>执行下面操作之一<ol type="1"><li>运行指定数量的字节码指令</li><li>线程主动让出控制权</li><li>切换出线程（线程处于睡眠状态）</li><li>解锁GIL</li><li>进入1步骤</li></ol></li></ol></li></ul></li><li><p>注意：Python运行计算密集型的多线程程序时，更倾向于让线程在整个时间片内始终占据GIL，而I/O密集型的多线程程序在I/O被调用前会释放GIL，以允许其他线程在I/O执行的时候运行。</p></li></ul><h3 id="使用">使用</h3><h4 id="线程池">线程池</h4><h5 id="基本使用">基本使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dosomething</span>(<span class="hljs-params">index</span>):<br>    <span class="hljs-keyword">return</span> index<br><br><span class="hljs-comment"># 创建一个最大容纳数量为5的线程池，不设置最大数量也可以</span><br><span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> executor:  <br>    <span class="hljs-comment"># 通过submit提交执行的函数到线程池中</span><br>    task1 = executor.submit(dosomething, <span class="hljs-number">1</span>)<br>    task2 = executor.submit(dosomething, <span class="hljs-number">2</span>)  <br><br>    <span class="hljs-comment"># 通过done来判断线程是否完成</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;task1: <span class="hljs-subst">&#123;task1.done()&#125;</span>&quot;</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;task2: <span class="hljs-subst">&#123;task2.done()&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 通过result来获取返回值</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;task1: <span class="hljs-subst">&#123;task1.done()&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;task2: <span class="hljs-subst">&#123;task2.done()&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(task1.result())  <br></code></pre></td></tr></table></figure><ul><li>使用 submit函数来提交线程需要执行的任务到线程池中，并返回该任务的句柄，注意submit() 不是阻塞的，而是立即返回</li><li>通过使用 done() 方法判断该任务是否结束。</li><li>使用 result() 方法可以获取任务的返回值</li></ul><h5 id="其他方法">其他方法</h5><ul><li>wait：阻塞等待<ul><li>fs：要等待的任务的句柄列表</li><li>timeout：最大等待时间</li><li>return_when：返回结果<ul><li>ALL_COMPLETED：全部完成</li><li>FIRST_COMPLETED：第一个完成</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">wait(fs, timeout=<span class="hljs-literal">None</span>, return_when=ALL_COMPLETED)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dosomething</span>(<span class="hljs-params">index</span>):<br>    <span class="hljs-keyword">return</span> index<br><br><span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> executor:  <br>tasks = [executor.submit(dosomething, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br>    concurrent.futures.wait(tasks, return_when=ALL_COMPLETED)<br></code></pre></td></tr></table></figure><ul><li>as_completed：当完成时<ul><li>要等待的任务的句柄列表</li><li>当有一个线程结束任务时，就会执行以下for循环，然后继续阻塞，直到所有线程都执行结束</li><li>先执行完的任务先返回，返回列表和任务提交列表顺序不同</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dosomething</span>(<span class="hljs-params">index</span>):<br>    <span class="hljs-keyword">return</span> index<br><br><span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:<br>    tasks = [executor.submit(dosomething, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]  <br>    <span class="hljs-comment"># 使用as_completed获取结果</span><br>    <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(tasks):<br>        result = future.result()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Received result:&quot;</span>, result)<br></code></pre></td></tr></table></figure><ul><li>map<ul><li>fn：线程执行函数</li><li>iterables：可迭代对象</li><li>timeout：第三个参数 timeout 跟 wait() 的 timeout 一样，但由于 map是返回线程执行的结果，如果 timeout小于线程执行时间会抛异常TimeoutError</li><li>返回列表顺序和任务提交顺序相同</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">map</span>(<span class="hljs-params">self, fn, *iterables, timeout=<span class="hljs-literal">None</span>, chunksize=<span class="hljs-number">1</span></span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dosomething</span>(<span class="hljs-params">index</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    num = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:<br>        executor.<span class="hljs-built_in">map</span>(dosomething, <span class="hljs-built_in">range</span>(num))<br></code></pre></td></tr></table></figure><h2 id="多进程">多进程</h2>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>编程语言</tag>
      
      <tag>多线程</tag>
      
      <tag>多进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Threejs入门</title>
    <link href="/2024/04/19/Threejs%E5%85%A5%E9%97%A8/"/>
    <url>/2024/04/19/Threejs%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍">1 介绍</h1><ul><li><p>WebGL（全写为Web GraphicsLibrary）是一种3D绘图协议和绘图技术标准。它允许将JavaScript和OpenGL ES2.0结合在一起，通过为OpenGL ES2.0增加一个JavaScript绑定，WebGL能够为HTML5Canvas提供硬件3D加速渲染。这使得Web开发人员能够利用系统显卡在浏览器中更流畅地展示3D场景和模型，同时创建复杂的导航和数据视觉化。WebGL通过JavaScript操作OpenGL接口的标准，将三维空间图像显示在二维的屏幕上。对于开发者来说，使用WebGL可以免去开发网页专用渲染插件的麻烦，并且可以用来创建具有复杂3D结构的网站页面，甚至设计3D网页游戏等。</p></li><li><p>three.js则是一个基于WebGL的JavaScript库，它为开发者提供了封装好的WebGLAPI，使得开发者能够更容易地在Web浏览器中创建和展示3D图形。three.js提供了许多组件、方法和工具，用于创建和处理3D图形，使得开发者可以在不深入了解WebGL底层实现的情况下，快速创建3D图形和动画。它支持多种类型的3D对象，包括几何体、材质、灯光和相机等，并提供了许多常用的几何体，如球体、立方体、圆锥体和圆柱体，这些几何体都可以进行旋转、平移和缩放等变换操作。此外，three.js还提供了多种灯光类型，用于为场景中的对象添加阴影和光照效果。</p></li><li><p>WebGL和three.js都是用于在Web浏览器中创建和展示3D图形的强大工具。WebGL提供了底层的绘图技术标准，而three.js则在此基础上提供了更易于使用的API和工具，使得开发者能够更高效地创建出精美的3D图形和动画。</p></li><li><p>官方文档：https://threejs.org/docs/index.html</p></li><li><p>官方在线编辑器：https://threejs.org/editor/</p></li><li><p><strong>JavaScript(JS)</strong>：JavaScript是一种用于构建交互式网页和应用程序的编程语言。它是一种脚本语言，最初设计用于在网页上实现交互式效果。JavaScript是一种高级、解释型的编程语言，广泛用于Web开发。</p></li><li><p><strong>ECMAScript(ES)</strong>：ECMAScript是JavaScript的规范。它定义了JavaScript语言的核心特性和行为。JavaScript是ECMAScript标准的一种实现，而ECMAScript的不同版本（如ES5、ES6、ES7等）则代表了JavaScript的不同发展阶段。其中，ES6（也被称为ECMAScript2015）是ECMAScript的一个特定版本，于2015年发布，它引入了许多新的语法和功能，对语言进行了广泛的增强和改进。</p></li><li><p><strong>TypeScript(TS)</strong>：TypeScript是一种由Microsoft开发的自由和开源的编程语言。它是JavaScript的一个超集，意味着所有合法的JavaScript代码都是合法的TypeScript代码。TypeScript在JavaScript的基础上增加了一些新的特性，如静态类型检查、类、接口、命名空间、泛型等。这些特性使得代码更具预测性、可控性，易于维护和调试。TypeScript编译器可以将TypeScript代码编译成纯净、简洁的JavaScript代码，使得TypeScript代码可以在任何支持JavaScript的平台上运行。</p></li><li><p>JavaScript是实际用于编程的语言，ECMAScript是JavaScript的规范化标准，而TypeScript则是JavaScript的一个扩展版本，提供了更多的功能和工具来增强JavaScript的开发体验。</p></li><li><p>内容分发网络：https://cdnjs.com/</p></li><li><p>npm官方网站：https://www.npmjs.com/</p></li></ul><h1 id="基础概念">2 基础概念</h1><ul><li>要想在Threejs中正确进行动画的渲染，以下部分是不可或缺的<ul><li>场景</li><li>相机</li><li>mesh</li><li>渲染器</li><li>动画</li></ul></li></ul><h1 id="dat.gui">dat.gui</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 以上引入之后会向全局暴露一个dat变量来进行调用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 1. 创建控制对象</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> controlData = &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">rotationSpeed</span>: <span class="hljs-number">0.01</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#66ccff&quot;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">wireframe</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">envMap</span>: <span class="hljs-string">&#x27;无&#x27;</span></span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        <span class="hljs-comment">// 2. 创建dat实例</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> gui = <span class="hljs-keyword">new</span> dat.<span class="hljs-title function_">GUI</span>();</span><br><span class="language-javascript">        <span class="hljs-comment">// 3. 添加折叠栏</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> f = gui.<span class="hljs-title function_">addFolder</span>(<span class="hljs-string">&quot;配置&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 4. 添加配置项：添加输入，添加key，最小值，最大值，步长</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 4.1 数值拖动条</span></span><br><span class="language-javascript">        <span class="hljs-comment">// f.add(controlData, &quot;rotationSpeed&quot;, 0.01, 0.1, 0.01);</span></span><br><span class="language-javascript">        f.<span class="hljs-title function_">add</span>(controlData, <span class="hljs-string">&quot;rotationSpeed&quot;</span>).<span class="hljs-title function_">min</span>(<span class="hljs-number">0.01</span>).<span class="hljs-title function_">max</span>(<span class="hljs-number">0.1</span>).<span class="hljs-title function_">step</span>(<span class="hljs-number">0.01</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 4.2 颜色选择器</span></span><br><span class="language-javascript">        f.<span class="hljs-title function_">addColor</span>(controlData, <span class="hljs-string">&quot;color&quot;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 4.3 下拉列表</span></span><br><span class="language-javascript">        f.<span class="hljs-title function_">add</span>(controlData, <span class="hljs-string">&quot;envMap&quot;</span>, [<span class="hljs-string">&quot;无&quot;</span>, <span class="hljs-string">&quot;全反射&quot;</span>, <span class="hljs-string">&quot;漫反射&quot;</span>]);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 4.4 checkbox</span></span><br><span class="language-javascript">        f.<span class="hljs-title function_">add</span>(controlData, <span class="hljs-string">&quot;wireframe&quot;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 5. 折叠栏打开</span></span><br><span class="language-javascript">        f.<span class="hljs-title function_">open</span>();</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java高级应用</title>
    <link href="/2024/04/09/Java%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    <url>/2024/04/09/Java%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="异常处理">9 异常处理</h1><ul><li>异常：指程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止</li><li>Java中把不同的异常用不同的类表示，一旦发生某种异常，就<code>创建该异常类型的对象</code>，并且抛出throw。然后后续可以捕获catch这个异常对象，并处理。如果没有catch这个异常对象，那这个异常对象将会导致程序终止。</li><li>程序员要编写相应的代码进行<code>异常检测</code>，以及<code>异常处理</code>，保证代码的<code>健壮性</code>。</li></ul><h2 id="java异常体系">Java异常体系</h2><ul><li>Throwable：<code>java.lang.Throwable</code>类是Java程序执行过程中发生的异常事件对应的类的根父类。</li><li>Throwable的常用方法<ul><li><code>public void printStackTrace()</code>：打印异常的详细信息（异常类型、原因、出现的位置）常用此方法</li><li><code>public String getMessage()</code>：获取发生异常的原因</li></ul></li><li>Throwable类有两个子类，Error和Exception<ul><li>Error：JVM无法解决的严重问题，一般不编写针对性的代码进行处理。<ul><li>StackOverflowError：栈内存溢出</li><li>OutOfMemoryError：堆内存溢出</li></ul></li><li>Exception：因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理。<ul><li>ArrayIndexOutOfBoundsException：数组角标越界</li><li>NullPointerException：空指针访问</li><li>ClassCastException：类转换异常</li><li>FileNotFountException：文件找不到异常</li></ul></li></ul></li><li>Java程序执行分为编译时过程和运行时过程，所以根据异常发生的阶段，可以分为<code>编译时异常</code>和<code>运行时异常</code>。</li><li>编译时异常（checked异常、受检异常）</li><li>运行时异常（runtime异常、unchecked异常、非受检异常）</li></ul><h2 id="异常处理-1">异常处理</h2><ul><li><p>Java异常处理：将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。</p></li><li><p>Java异常处理的方式</p><ul><li>try-catch-finally</li><li>throws + 异常类型</li></ul></li><li><p>try-catch-finally</p><ul><li><p>程序在执行过程中，一旦出现异常，就会在出现异常的代码处创建对应异常的对象，并将该对象抛出。一旦抛出，此程序就不执行其后代码。针对抛出的异常对象，后续进行捕获处理，将异常进行处理后，代码就可以继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    ...<span class="hljs-comment">//可能出现异常的代码</span><br>&#125;<br><span class="hljs-keyword">catch</span> (异常类型<span class="hljs-number">1</span> e) &#123;<br>    ... <span class="hljs-comment">//当产生异常类型1时处理措施</span><br>&#125;<br><span class="hljs-keyword">catch</span> (异常类型<span class="hljs-number">2</span> e) &#123;<br>    ... <span class="hljs-comment">//当产生异常类型2时处理措施</span><br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    ... <span class="hljs-comment">//无论是否发生异常，都无条件执行的语句</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果不同异常类型中存在父子类的关系，则父类异常要写在子类异常下面</p></li><li><p>把一定要执行的代码写在finally中。无论try和catch中是否存在未被处理的异常，无论try或catch中是否存在return语句，finally中声明的语句都一定要执行</p></li><li><p>（输入流、输出流、数据库连接、Socket连接）资源回收需要被放在finally中，避免内存泄漏。</p></li></ul></li><li><p>throws</p><ul><li><p>在方法的声明处，使用<code>throws 异常类型1, 异常类型2, ...</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> 异常类型<span class="hljs-number">1</span>, 异常类型<span class="hljs-number">2</span> &#123;<br>    <span class="hljs-comment">// 可能会出现异常的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>throws只是将可能出现的异常抛给此方法的调用者，并不算真正处理了异常</p></li></ul></li></ul><h2 id="手动抛出异常对象">手动抛出异常对象</h2><ul><li>在适当位置加入代码：throw new 异常对象("异常信息")</li></ul><h2 id="自定义异常类">自定义异常类</h2><ul><li>要求：<ol type="1"><li>继承于现有的异常体系，通常继承于RuntimeException  Exception</li><li>通常提供几个重载的构造器</li><li>提供一个全局常量，声明为：static final long serialVersionUID;</li><li>具体查看其他异常类源码，仿照构建</li></ol></li><li>使用<ul><li>在具体代码中，满足指定条件的情况下，需要手动使用throw +自定义异常类的对象，将异常对象抛出</li><li>如果自定义异常类是非运行时异常，则必须考虑如何处理此异常类的对象。（try-catch-finally，throws）</li></ul></li><li>为什么要自定义异常类<ul><li>通过异常名称就能直接判断此异常出现的原因，所以自定义异常类是为了可以见名知义</li></ul></li></ul><h1 id="多线程">10 多线程</h1><h2 id="相关概念">相关概念</h2><ul><li><p>程序program：为完成特定任务，用某种语言编写的一组指令的集合。即指<code>一段静态的代码</code>，静态对象。</p></li><li><p>进程process：程序的一次执行过程，或正在内存中运行的应用程序。</p><ul><li>每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程。（生命周期）</li><li>程序是静态的，进程是动态的</li><li><code>进程是OS调度和分配资源的最小单位</code></li></ul></li><li><p>线程thread：进程可进一步细化为线程，是程序内部的一条执行路径。一个进程中至少有一个线程</p><ul><li><p>一个进程同一时间若<code>并行</code>执行多个线程，就是支持多线程的</p></li><li><p><code>线程是CPU调度和执行的最小单位</code></p></li><li><p>一个进程中的多个线程共享相同的内存单元，可以访问相同的变量和对象，使得线程间通信变得简便，高效。但多个线程共享的系统资源可以会带来<code>安全隐患</code>。</p></li><li><figure><img src="进程内存空间.png" alt="进程内存空间" /><figcaption aria-hidden="true">进程内存空间</figcaption></figure></li><li><blockquote><p>不同进程间是不共享内存的</p><p>进程间的数据交换和通信的成本很高</p></blockquote></li></ul></li><li><p>线程调度：</p><ul><li>分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间</li><li>抢占式调度：让优先级高的线程以较大概览有限使用CPU，若优先级相同，随机选择一个，<code>Java使用的为抢占式调度</code></li></ul></li><li><p>并行：同时进行</p></li><li><p>并发：交替执行</p></li></ul><h2 id="创建和启动线程">创建和启动线程</h2><ul><li><p>JVM允许程序运行多个线程，使用<code>java.lang.Thread</code>类代表线程，所有的线程对象都必须是Thread类或其子类的实例。</p></li><li><p>Thread类的特性</p><ul><li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，把run()方法体称为<code>线程执行体</code></li><li>通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</li><li>要想实现多线程，必须在主线程中创建新的线程对象</li></ul></li><li><p>继承Thread类的方式创建线程</p><ul><li>步骤：<ol type="1"><li>创建Thread的子类</li><li>重写run方法，将要执行的操作放到方法体中</li><li>创建该子类对象</li><li>通过对象调用start()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintNumberTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">EvenNumberPrint</span> <span class="hljs-variable">evenNumberPrint</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EvenNumberPrint</span>();<br>        <span class="hljs-type">OddNumberPrint</span> <span class="hljs-variable">oddNumberPrint</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OddNumberPrint</span>();<br>        evenNumberPrint.start();<br>        oddNumberPrint.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EvenNumberPrint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;偶数：&quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OddNumberPrint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;奇数: &quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>这种方式如果想要同时调用两个线程执行相同的操作，那么需要创建相同子类的两个不同对象，并调用start方法</li></ul></li><li><p>由于Java是单继承方式，通过继承的方式去创建线程会导致不够灵活，所以第二种方式是通过实现接口的方式。</p></li><li><p>实现Runnable接口的方式创建线程</p><ul><li><p>步骤</p><ol type="1"><li>创建一个实现Runnable接口的类</li><li>实现接口的run方法</li><li>创建当前实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的实例</li><li>调用Thread类实例的start方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvenNumberTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">EvenNumberPrint</span> <span class="hljs-variable">evenNumberPrint</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EvenNumberPrint</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(evenNumberPrint);<br>        t1.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EvenNumberPrint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这种方式如果想要同时调用两个线程执行相同的操作，那么不需要创建相同子类的两个不同对象，而需要创建两个Thread类对象，并调用Thread类对象的start方法</p></li></ul></li><li><p>以上两种方式的异同点</p><ul><li>共同点：<ol type="1"><li>启动线程，使用的都是Thread类中定义的start()方法</li><li>创建的线程对象，都是Thread类或其子类的实例</li></ol></li><li>不同点<ul><li>一个是类的继承，一个是接口的实现</li></ul></li><li>建议使用Runnable接口的方式：避免了类的单继承的局限性；更适合处理有共享数据的问题；实现了代码和数据的分离</li><li>Thread类也实现了Runnable接口</li></ul></li></ul><h2 id="thread类常用结构">Thread类常用结构</h2><ul><li>构造器<ul><li>public Thread()：分配一个新的线程对象</li><li>public Thread(String name)：分配一个指定名字的新的线程对象</li><li>public Thread(Runnabletarget)：指定创建线程的目标对象，它实现了Runnable接口中的run方法</li><li>public Thread(Runnable target, Stringname)：分配一个带有指定目标新的线程对象并指定名字</li></ul></li><li>常用方法<ul><li>start()：启动线程，调用线程的run()方法</li><li>run()：将线程要执行的操作，声明在run()中</li><li>currentThread()：获取当前正在执行的线程</li><li>getName()：获取线程名</li><li>setName()：设置线程名</li><li>sleep(long millis)：当前线程睡眠指定的毫秒数</li><li>yield()：主动释放CPU的执行权</li><li>join()：在线程A中通过线程B调用join()，意味着线程A进入阻塞状态，直到线程B执行结束，线程A才结束阻塞状态，继续执行</li><li>isAlive()：判断当前线程是否还存活</li></ul></li><li>过时方法<ul><li>stop()：强行结束线程的执行</li><li>suspend()和resume()：挂起和唤醒，可能造成死锁</li></ul></li><li>线程的优先级<ul><li>Thread类内部声明的三个优先级常量<ul><li>MAX_PRIORITY（10）：最高优先级</li><li>MIN_PRIORITY（1）：最低优先级</li><li>NORM_PRIORITY（5）：普通优先级，默认情况下main线程具有普通优先级</li></ul></li><li>getPriority()：获取线程优先级</li><li>setPriority()：设置线程优先级</li></ul></li></ul><h2 id="多线程的生命周期">多线程的生命周期</h2><ul><li>JDK1.5之前，线程有5种状态<ul><li>新建New、就绪Runnable、运行Running、阻塞Blocked、死亡Dead</li><li><figure><img src="JDK1.5线程状态转换图.png" alt="JDK1.5线程状态转换图" /><figcaption aria-hidden="true">JDK1.5线程状态转换图</figcaption></figure></li></ul></li><li>JDK1.5之后对线程状态进行了更改，将就绪和运行合并，将阻塞细分，有6种状态<ul><li><figure><img src="JDK1.5后线程状态转换图.png" alt="JDK1.5后线程状态转换图" /><figcaption aria-hidden="true">JDK1.5后线程状态转换图</figcaption></figure></li></ul></li></ul><h2 id="线程安全问题及解决">线程安全问题及解决</h2><ul><li><p>当使用多个线程访问同一资源时，若多个线程中对资源有<code>读和写</code>的操作，就容易出现线程安全问题。</p></li><li><p>Java使用同步机制解决线程的安全问题，同步机制有两种：同步代码块和同步方法</p></li><li><p>同步代码块</p><ul><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步监视器) &#123;<br><span class="hljs-comment">// 需要被同步的代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li>需要被同步的代码，即为操作共享数据的代码</li><li>共享数据，即多个线程都需要操作的数据</li><li>需要被同步的代码，在被synchronized包裹以后，就使得一个线程在操作这些代码的过程中，其他线程必须等待</li><li>同步监视器，俗称锁。哪个线程获取了锁，哪个线程就能执行需要被同步的代码</li><li>同步监视器，可以使用任何一个类的对象充当。但是，多个线程必须共用同一个同步监视器</li></ul></li><li><p>注意：</p><ul><li>在实现Runnable接口的方式中，同步监视器可以考虑使用：<code>this</code></li><li>在继承Thread类的方式中，同步监视器慎用this，一般考虑使用当前<code>类.class</code></li></ul></li></ul></li><li><p>同步方法</p><ul><li>说明：<ul><li>如果操作共享数据的代码完整的声明在了一个方法中，那么我们就可以将此方法声明为同步方法即可</li><li>非静态的同步方法，默认同步监视器就是this</li><li>静态的同步方法，默认同步监视器就是当前类本身</li></ul></li></ul></li></ul><h2 id="线程安全的懒汉式单例模式">线程安全的懒汉式单例模式</h2><ul><li>在单例模式中，饿汉式不存在线程安全问题，懒汉式存在线程安全问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + Singleton.getInstance().hashCode());<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为了实现线程安全的懒汉式单例模式，需要做两次校验：<ul><li>第一次校验：也就是第一个if（singleton==null），这个是为了代码提高代码执行效率，由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用getInstance方法就不必要进入同步代码块，不用竞争锁。直接返回前面创建的实例即可</li><li>第二次校验：也就是第二个if（singleton==null），这个校验是防止二次创建实例，假如有一种情况，当singleton还未被创建时，线程t1调用getInstance方法，由于第一次判断singleton==null，此时线程t1准备继续执行，但是由于资源被线程t2抢占了，此时t2页调用getInstance方法。同样的，由于singleton并没有实例化，t2同样可以通过第一个if，然后继续往下执行，同步代码块，第二个if也通过，然后t2线程创建了一个实例singleton。此时t2线程完成任务，资源又回到t1线程，t1此时也进入同步代码块，如果没有这个第二个if，那么，t1就也会创建一个singleton实例，那么，就会出现创建多个实例的情况，但是加上第二个if，就可以完全避免这个多线程导致多次创建实例的问题。</li><li>所以说：两次校验都必不可少。</li></ul></li><li>需要使用volatile的原因：<ul><li>防止jvm指令重排优化<ul><li>因为 singleton = new Singleton() 这句话可以分为三步：<ol type="1"><li>为 singleton 分配内存空间；</li><li>初始化 singleton；</li><li>将 singleton 指向分配的内存空间。</li></ol></li><li>但是由于JVM具有指令重排的特性，执行顺序有可能变成1-3-2。指令重排在单线程下不会出现问题，但是在多线程下会导致一个线程获得一个未初始化的实例。例如：线程T1执行了1和3，此时T2调用getInstance() 后发现 singleton 不为空，因此返回 singleton， 但是此时的singleton 还没有被初始化。</li><li>使用 volatile会禁止JVM指令重排，从而保证在多线程下也能正常执行。</li></ul></li><li>保证变量在多线程运行时的可见性<ul><li>在 JDK1.2之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。</li><li>这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</li><li>要解决这个问题，就需要把变量声明为 volatile，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。</li></ul></li></ul></li></ul><h2 id="死锁">死锁</h2><ul><li><p>死锁deadlock：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</p></li><li><p>死锁的必要条件和解决方案：</p><ul><li>互斥<ul><li>无法被破坏，因为线程需要通过互斥解决安全问题</li></ul></li><li>非抢占<ul><li>占用资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源</li></ul></li><li>占用并等待<ul><li>可以考虑一次性申请所有需要的资源，就不存在等待问题</li></ul></li><li>循环等待<ul><li>将资源改为线性顺序，申请资源时，先申请序号小的</li></ul></li></ul></li><li><p>一段简单的死锁代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (s1) &#123;<br>                    s1.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                    s2.append(<span class="hljs-string">&quot;1&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                    &#125;<br>                    <span class="hljs-keyword">synchronized</span> (s2) &#123;<br>                        s1.append(<span class="hljs-string">&quot;b&quot;</span>);<br>                        s2.append(<span class="hljs-string">&quot;2&quot;</span>);<br>                        System.out.println(s1);<br>                        System.out.println(s2);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (s2) &#123;<br>                    s1.append(<span class="hljs-string">&quot;c&quot;</span>);<br>                    s2.append(<span class="hljs-string">&quot;3&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                    &#125;<br>                    <span class="hljs-keyword">synchronized</span> (s1) &#123;<br>                        s1.append(<span class="hljs-string">&quot;d&quot;</span>);<br>                        s2.append(<span class="hljs-string">&quot;4&quot;</span>);<br>                        System.out.println(s1);<br>                        System.out.println(s2);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="lock锁">Lock锁</h2><ul><li><p>除了使用synchronized同步机制处理线程安全问题之外，还可以使用jdk5.0提供的lock锁的方式</p></li><li><p>这里介绍java中reentrantedlock锁，是一个可重入的互斥锁，又称为独占锁。</p></li><li><p>使用步骤</p><ol type="1"><li>创建lock实例，确保多个线程共用同一个lock实例，需要考虑将此对象声明为staticfinal</li><li>执行lock()方法，锁定对共享资源的调用</li><li>执行unlock()方法，释放对共享资源的锁定</li></ol></li><li><p>使用代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Window</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Window</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;售票，票号：&quot;</span> + ticket);<br>                ticket--;<br>                lock.unlock();<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                lock.unlock();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Window</span> <span class="hljs-variable">w1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Window</span>(<span class="hljs-string">&quot;窗口1&quot;</span>);<br>        <span class="hljs-type">Window</span> <span class="hljs-variable">w2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Window</span>(<span class="hljs-string">&quot;窗口2&quot;</span>);<br>        <span class="hljs-type">Window</span> <span class="hljs-variable">w3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Window</span>(<span class="hljs-string">&quot;窗口3&quot;</span>);<br>        <span class="hljs-type">Window</span> <span class="hljs-variable">w4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Window</span>(<span class="hljs-string">&quot;窗口4&quot;</span>);<br>        w1.start();<br>        w2.start();<br>        w3.start();<br>        w4.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>在结束资源调用后，一定要执行unlock()，如果有多个分支，在多个分支中都要执行。</code></p></li><li><p>synchronized和lock对比</p><ul><li>Lock更灵活；作为接口，提供了多种实现类，适合更多更复杂的场景，效率更高</li></ul></li></ul><h2 id="线程的通信">线程的通信</h2><ul><li><p>当需要多个线程共同完成一件任务，并且希望他们有规律的执行时，就需要一些通信机制，用以协调它们的工作。</p></li><li><p>等待唤醒机制</p><ul><li>这是多线程间的<code>协作机制</code></li><li>在一个线程满足某个条件时，就进入等待状态（<code>wait()/wait(time)</code>），等待其他线程执行完它们的任务后再将其唤醒（<code>notify()</code>）；或可以指定wait的时间，时间到了自动唤醒；在有多个线程等待时，可以使用<code>notifyAll()</code>来唤醒所有等待线程。wait/notify就是线程间的一种协作机制</li></ul></li><li><p>等待唤醒机制示例</p><ul><li><p>两个线程交替打印数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintNumber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                notify();<br>                <span class="hljs-keyword">if</span> (number &lt;= <span class="hljs-number">100</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + number);<br>                    number++;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        wait();     <span class="hljs-comment">// 线程一旦指定此方法，就进入等待状态，同时，会释放对同步监视器的调用</span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintNumberTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">PrintNumber</span> <span class="hljs-variable">printNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintNumber</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(printNumber, <span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(printNumber, <span class="hljs-string">&quot;线程2&quot;</span>);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>wait()：线程一旦执行此方法，就进入等待状态。同时，会释放对同步监视器的调用</p></li><li><p>notify()：唤醒被wait的线程中优先级最高的一个线程</p></li><li><p>notifyAll()：唤醒所有被wait的线程</p></li><li><p>以上三个方法的使用必须使用在同步代码块或同步方法中</p></li><li><p>三个方法的调用者必须是同步代码块或同步方法中的监视器，否则或报异常<code>java.lang.IllegalMonitorStateException</code></p></li><li><p>以上三个方法被声明在object类中</p></li></ul></li><li><p>wait()和sleep()的区别</p><ul><li>相同点：一旦执行，当前线程都会进入阻塞状态</li><li>不同点：<ul><li>声明的位置：wait()声明在Object类；sleep()声明在Thread类中，静态的</li><li>使用的场景：wait()只能使用在同步代码块和同步方法中；sleep()没有限制</li><li>wait()会释放同步监视器，sleep()不会释放</li><li>wait()可以指定时间自动结束阻塞，或通过notify唤醒；sleep()到时间自动结束阻塞</li></ul></li></ul></li></ul><h2 id="生产者消费者案例">生产者消费者案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clerk</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">productNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addProduct</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (productNumber &gt;= MAX_COUNT) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            productNumber++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;生产了第&quot;</span> + productNumber + <span class="hljs-string">&quot;个产品&quot;</span>);<br>            notifyAll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">minusProduct</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (productNumber &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;消费了第&quot;</span> + productNumber + <span class="hljs-string">&quot;个产品&quot;</span>);<br>            productNumber--;<br>            notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> Clerk clerk;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Producer</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Producer</span><span class="hljs-params">(Clerk clerk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clerk = clerk;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            clerk.addProduct();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> Clerk clerk;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(Clerk clerk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clerk = clerk;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            clerk.minusProduct();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerConsumerTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Clerk</span> <span class="hljs-variable">clerk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Clerk</span>();<br>        <span class="hljs-type">Producer</span> <span class="hljs-variable">producer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>(clerk);<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(clerk);<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(clerk);<br>        producer1.setName(<span class="hljs-string">&quot;生产者1&quot;</span>);<br>        consumer1.setName(<span class="hljs-string">&quot;消费者1&quot;</span>);<br>        consumer2.setName(<span class="hljs-string">&quot;消费者2&quot;</span>);<br>        producer1.start();<br>        consumer1.start();<br>        consumer2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建多线程的其他两种方式">创建多线程的其他两种方式</h2><ul><li><p>在jdk5.0中新增了两种创建多线程的方式，一种是实现Callable，一种是使用线程池</p></li><li><p>Callable</p><ul><li><p>与Runnable对比</p><ul><li>优点：<ul><li>call()可以有返回值，更灵活</li><li>call()可以使用throws的方式处理异常，更灵活</li><li>Callable使用了泛型参数，可以指明具体的call()的返回值类型，更灵活</li></ul></li><li>缺点：<ul><li>如果在主线程中需要获取分线程call()的返回值，则此时的主线程是阻塞状态的</li></ul></li></ul></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(i);<br>                sum += i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NumThread</span> <span class="hljs-variable">numThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumThread</span>();<br>        <span class="hljs-type">FutureTask</span> <span class="hljs-variable">futureTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(numThread);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        thread.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;总和为：&quot;</span> + sum);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p></li><li><p>可以提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</p></li><li><p>线程池</p><ul><li>优点：<ul><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>可以设置相关参数，对线程池中的线程的使用进行管理</li></ul></li><li>具体细节要看JUC，java并发编程中查看</li></ul></li></ul><h1 id="常用类和基础api">11 常用类和基础API</h1><h2 id="string">String</h2><ul><li><p>不可变的字符序列</p></li><li><p>类解析</p><ul><li><p>类声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence<br></code></pre></td></tr></table></figure><ul><li>final：String不可被继承</li><li>java.io.Serializable：可序列化接口，可以序列化的类的对象都可以通过网络、IO流传输</li><li>Comparable：实现此接口的类，其对象都可以比较大小</li></ul></li><li><p>属性</p><ul><li>JDK8<ul><li>private final char value[]：存储字符串数据的容器<ul><li>final：一旦初始化，其地址不可更改</li></ul></li></ul></li><li>JDK9：为了节省内存空间，做了优化<ul><li>private final byte[] value：存储字符串数据的容器</li></ul></li></ul></li></ul></li><li><p>字符串常量的存储位置</p><ul><li><p>字符串常量存储在字符串常量池中</p></li><li><p>字符串常量池不允许存放两个相同的字符串常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>以上s1和s2的地址是相同的</p></li><li><p>字符串常量池在不同的jdk版本中，存放位置不同。</p><ul><li>jdk7之前，存放在方法区；</li><li>jdk7及之后，存放在堆空间</li></ul></li></ul></li><li><p>String类型的对象具有不可变性，一旦进行修改，就是重新创建一个对象，地址发生改变。是为了节省空间，当多个变量共用一个字面量时，不会导致重复。</p></li><li><p>实例化方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>字面量实例化：创建字符串时，Java会首先检查字符串常量池（StringPool）中是否存在值为"hello"的字符串对象。如果存在，则不会创建新的对象，而是让s1引用指向已存在的字符串对象；如果不存在，则会在字符串常量池中创建一个新的字符串对象，并将值设为"hello"，然后让s1引用指向这个新创建的对象。这种方式更加高效，因为它避免了不必要的对象创建。</li><li>new关键字实例化：而当你使用new关键字创建字符串时，无论字符串常量池中是否已经存在值为"hello"的字符串对象，都会在堆内存（HeapMemory）中创建一个新的字符串对象。这意味着即使字符串常量池中已有相同的字符串，也会额外创建一个对象。这样做可能会导致更多的内存占用，并且效率较低。</li></ul></li><li><p>连接操作</p><ul><li>常量 + 常量：结果存储在字符串常量池中<ul><li>通过final修饰的也是常量，适用于此规则</li></ul></li><li>常量 + 变量：通过new创建字符串，返回堆空间中的字符串地址</li><li>字符串的intern()方法：返回存储在字符串常量池中的字面量的地址</li><li>concat()方法：不论是常量还是变量调用此方法，均是通过new创建字符串返回地址</li></ul></li><li><p>构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">()</span> <span class="hljs-comment">// 初始化新创建的 String 对象，表示空字符序列</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(String original)</span> <span class="hljs-comment">// 初始化一个新创建的String对象，表示一个与参数相同的字符序列</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">char</span>[] value)</span> <span class="hljs-comment">// 通过当前参数中的字符数组来构造新的String</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">char</span>[] value, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> count)</span> <span class="hljs-comment">// 通过字符数组的一部分来构造新的String</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes)</span> <span class="hljs-comment">// 通过平台的默认字符集解码当前参数中的字节数组来构造新的String</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, String charsetName)</span> <span class="hljs-comment">// 通过指定的字符集解码当前参数中的字节数组来构造新的String</span><br></code></pre></td></tr></table></figure></li><li><p>类型转换：从目标类型中找方法</p><ul><li><p>基本数据类型→String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 方式1</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> num + <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-comment">// 方式2</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> String.valueOf(num);<br></code></pre></td></tr></table></figure></li><li><p>String→基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> Integer.parseInt(s3);<br></code></pre></td></tr></table></figure></li><li><p>char[]→String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>String→char[]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">char</span>[] arr = str.toCharArray();<br></code></pre></td></tr></table></figure></li><li><p>byte[]→String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, String charsetName)</span><br></code></pre></td></tr></table></figure></li><li><p>String→byte[]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc中国&quot;</span>;<br>    <span class="hljs-type">byte</span>[] arr1 = str.getBytes();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : arr1) &#123;<br>        System.out.print(b);<br>        System.out.print(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>    System.out.println();<br>    <span class="hljs-type">byte</span>[] arr2 = str.getBytes(<span class="hljs-string">&quot;gbk&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : arr2) &#123;<br>        System.out.print(b);<br>        System.out.print(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">97</span> <span class="hljs-number">98</span> <span class="hljs-number">99</span> -<span class="hljs-number">28</span> -<span class="hljs-number">72</span> -<span class="hljs-number">83</span> -<span class="hljs-number">27</span> -<span class="hljs-number">101</span> -<span class="hljs-number">67</span> <br><span class="hljs-number">97</span> <span class="hljs-number">98</span> <span class="hljs-number">99</span> -<span class="hljs-number">42</span> -<span class="hljs-number">48</span> -<span class="hljs-number">71</span> -<span class="hljs-number">6</span> <br></code></pre></td></tr></table></figure><ul><li>在utf-8字符集中，一个汉字占用3个字节，一个字母占用1个字节</li><li>在gbk字符集中，一个汉字占用2个字节，一个字母占用1个字节</li><li>utf-8和gbk都向下兼容了ascii码</li></ul></li></ul></li><li><p>常见方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span><span class="hljs-comment">// 字符串是台为空</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span><span class="hljs-comment">// 返回字符串的长度</span><br>String <span class="hljs-title function_">concat</span><span class="hljs-params">(xx)</span><span class="hljs-comment">// 拼接 </span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><span class="hljs-comment">// 比较字符串是否相等，区分大小写 </span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">equalsIgnoreCase</span><span class="hljs-params">(Object obj)</span><span class="hljs-comment">// 比较字符串是否相等，不区分大小写 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(String other)</span><span class="hljs-comment">// 比较字符串大小，区分大小写，按照unicode编码值比较大小</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compareToIgnoreCase</span><span class="hljs-params">(String other)</span><span class="hljs-comment">// 比较字符串大小，不区分大小写</span><br>String <span class="hljs-title function_">toLowerCase</span><span class="hljs-params">()</span><span class="hljs-comment">// 将字符串中大写字母转为小写</span><br>String <span class="hljs-title function_">toUpperCase</span><span class="hljs-params">()</span><span class="hljs-comment">// 将字符串中小写字母转为大写</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">intern</span><span class="hljs-params">()</span><span class="hljs-comment">// 结果在常量池中共享</span><br>    <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(xx)</span> <span class="hljs-comment">// 是否包含xx</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(xxx)</span> <span class="hljs-comment">// 从前往后找当前字符串中xx，如果有返回第一次出现的下标，没有返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> fromIndex)</span> <span class="hljs-comment">// 返回指定子字符串在此字符串中第一次出现处的索引，从fromIndex开始查找</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(xx)</span> <span class="hljs-comment">// 从后往前找当前字符串中xx，如果有返回第一次出现的下标，没有返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> fromIndex)</span> <span class="hljs-comment">// 返回指定子字符串在此字符串中第一次出现处的索引，从fromIndex开始查找</span><br>    <br>String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex)</span> <span class="hljs-comment">// 返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串</span><br>String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)</span> <span class="hljs-comment">// 返回一个新的字符串，它是此字符串的从beginIndex开始截取到endIndex(不含)的一个子字符串</span><br><br><span class="hljs-type">char</span> <span class="hljs-title function_">charAt</span><span class="hljs-params">(index)</span> <span class="hljs-comment">// 返回[index]位置的字符</span><br><span class="hljs-type">char</span>[] toCharArray() <span class="hljs-comment">// 将此字符串转换为一个新的字符数组返回</span><br><span class="hljs-keyword">static</span> String <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">char</span>[] data)</span> <span class="hljs-comment">// 返回指定数组中表示该字符序列的 String</span><br><span class="hljs-keyword">static</span> String <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">char</span>[] data, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> count)</span> <span class="hljs-comment">// 从给定的字符数组 data 中，从索引 offset 开始，提取 count 个字符，并用这些字符构建一个新的字符串</span><br><span class="hljs-keyword">static</span> String <span class="hljs-title function_">copyValueOf</span><span class="hljs-params">(<span class="hljs-type">char</span>[] data)</span> <span class="hljs-comment">//  返回指定数组中表示该字符序列的 String</span><br><span class="hljs-keyword">static</span> String <span class="hljs-title function_">copyValueOf</span><span class="hljs-params">(<span class="hljs-type">char</span>[] data, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> count)</span> <span class="hljs-comment">// 从给定的字符数组 data 中，从索引 offset 开始，提取 count 个字符，并用这些字符构建一个新的字符串</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(xx)</span> <span class="hljs-comment">// 测试此字符串是否以指定的前缀开始</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix, <span class="hljs-type">int</span> toffset)</span> <span class="hljs-comment">// 测试此字符串是否以指定的前缀开始，从offset开始</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">endsWith</span><span class="hljs-params">(xx)</span> <span class="hljs-comment">// 测试此字符串是否以指定的后缀结束</span><br><br>String <span class="hljs-title function_">replace</span><span class="hljs-params">(<span class="hljs-type">char</span> oldChar, <span class="hljs-type">char</span> newChar)</span> <span class="hljs-comment">// 返回一个新字符串，用oldChar替换newChar</span><br>String <span class="hljs-title function_">replace</span><span class="hljs-params">(CharSequence target, CharSequence replacement)</span> <span class="hljs-comment">// 返回一个新字符串，用replacement序列替换target序列</span><br>String <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(String regex, String replacement)</span> <span class="hljs-comment">// 使用正则表达式替换所有匹配的</span><br>String <span class="hljs-title function_">replaceFirst</span><span class="hljs-params">(String regex, String replacement)</span> <span class="hljs-comment">// 使用正则表达式替换第一次匹配的</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="stringbufferstringbuilder">StringBuffer&amp;StringBuilder</h2><table><thead><tr class="header"><th style="text-align: center;">String</th><th style="text-align: center;">StringBuffer</th><th style="text-align: center;">StringBuilder</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">不可变的字符序列</td><td style="text-align: center;">可变的字符序列</td><td style="text-align: center;">可变的字符序列</td></tr><tr class="even"><td style="text-align: center;">相较于后两个效率低</td><tdstyle="text-align: center;">JDK1.0声明，线程安全（方法都用synchronized修饰），效率低</td><td style="text-align: center;">JDK5.0声明，线程不安全，效率高</td></tr><tr class="odd"><tdstyle="text-align: center;">JDK8及之前使用char[]，JDK9及之后byte[]</td><td style="text-align: center;">底层结构和String相同</td><td style="text-align: center;">底层结构和String相同</td></tr><tr class="even"><td style="text-align: center;">父类：Object</td><td style="text-align: center;">父类：AbstractStringBuilder</td><td style="text-align: center;">父类：AbstractStringBuilder</td></tr><tr class="odd"><td style="text-align: center;">private final charvalue[]位于String类中</td><td style="text-align: center;">charvalue[]位于AbstractStringBuilder类中</td><td style="text-align: center;">charvalue[]位于AbstractStringBuilder类中</td></tr><tr class="even"><td style="text-align: center;">通过length()获取长度</td><td style="text-align: center;">通过count属性获取长度</td><td style="text-align: center;">通过count属性获取长度</td></tr><tr class="odd"><td style="text-align: center;">初始化时就是当前容量</td><tdstyle="text-align: center;">初始化时始终保证比当前容量多16个字符的空间</td><tdstyle="text-align: center;">初始化时始终保证比当前容量多16个字符的空间</td></tr><tr class="even"><td style="text-align: center;">一旦发生改变就会创建一个新的String</td><tdstyle="text-align: center;">当长度到达最大时，重新创建空间，长度为max(length*2+2,minlength)</td><tdstyle="text-align: center;">当长度到达最大时，重新创建空间，长度为max(length*2+2,minlength)</td></tr></tbody></table><ul><li><p>开发建议：</p><ul><li>如果开发中需要频繁的针对字符串进行增删改，建议使用StringBuilder或StringBuffer，提高效率。</li><li>如果不涉及到线程安全问题，使用StringBuilder，提高效率。</li><li>如果开发中大体确定要操作的字符的个数，建议使用带intcapacity参数的构造器，可以避免底层多次扩容操作，性能更高</li></ul></li><li><p>StringBuffer和StringBuilder中的常用方法</p><ul><li><p>增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">append(xxx)<br></code></pre></td></tr></table></figure></li><li><p>删</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">delete(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)<br>deleteCharAt(<span class="hljs-type">int</span> index)<br></code></pre></td></tr></table></figure></li><li><p>改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">replace(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, String str)<br>setCharAt(<span class="hljs-type">int</span> index, <span class="hljs-type">char</span> c)<br>reverse() <span class="hljs-comment">// String中没有这个方法</span><br></code></pre></td></tr></table></figure></li><li><p>査</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">charAt(<span class="hljs-type">int</span> index)<br></code></pre></td></tr></table></figure></li><li><p>插</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">insert(<span class="hljs-type">int</span> index, xx)<br></code></pre></td></tr></table></figure></li><li><p>长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">length()<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="jdk8之前的日期时间api">JDK8之前的日期时间API</h2><ul><li><p>System类的currentTimeMillis()</p><ul><li>获取当前时间对应的毫秒数，long类型，时间戳</li><li>以1970年1月1日0时0分0秒开始</li><li>常用来计算时间差</li></ul></li><li><p>两个Date类</p><ul><li><p>java.util.Date</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">data1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>System.out.println(data1);<br><br><span class="hljs-type">long</span> <span class="hljs-variable">milliTimes</span> <span class="hljs-operator">=</span> data1.getTime();<br>System.out.println(<span class="hljs-string">&quot;对应的毫秒数：&quot;</span> + milliTimes);<br><br><span class="hljs-type">Date</span> <span class="hljs-variable">data2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1828185166919L</span>);<br>System.out.println(data2);<br><span class="hljs-comment">// 输出</span><br>Sun Oct <span class="hljs-number">06</span> <span class="hljs-number">11</span>:<span class="hljs-number">14</span>:<span class="hljs-number">24</span> CST <span class="hljs-number">2024</span><br>对应的毫秒数：<span class="hljs-number">1728184464468</span><br>Tue Dec <span class="hljs-number">07</span> <span class="hljs-number">21</span>:<span class="hljs-number">12</span>:<span class="hljs-number">46</span> CST <span class="hljs-number">2027</span><br></code></pre></td></tr></table></figure></li><li><p>java.sql.Date</p><ul><li>是java.util.Date的子类，对应数据库中的date类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">java.sql.<span class="hljs-type">Date</span> <span class="hljs-variable">data1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.sql.Date(System.currentTimeMillis());<br>System.out.println(data1);<br>System.out.println(data1.getTime());<br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">2024</span>-<span class="hljs-number">10</span>-<span class="hljs-number">06</span><br><span class="hljs-number">1728184530394</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>SimpleDateFormat类</p><ul><li><p>java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类</p><ul><li><p>格式化：日期→字符串</p></li><li><p>解析：字符串→日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>();<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">strDate</span> <span class="hljs-operator">=</span> sdf.format(date1);<br>    System.out.println(strDate);<br><br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> sdf.parse(strDate);<br>    System.out.println(date2);<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">24</span>-<span class="hljs-number">10</span>-<span class="hljs-number">6</span> 上午<span class="hljs-number">11</span>:<span class="hljs-number">26</span><br>Sun Oct <span class="hljs-number">06</span> <span class="hljs-number">11</span>:<span class="hljs-number">26</span>:<span class="hljs-number">00</span> CST <span class="hljs-number">2024</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">strDate</span> <span class="hljs-operator">=</span> sdf.format(date1);<br>    System.out.println(strDate);<br><br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> sdf.parse(strDate);<br>    System.out.println(date2);<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">2024</span>-<span class="hljs-number">10</span>-<span class="hljs-number">06</span> <span class="hljs-number">11</span>:<span class="hljs-number">27</span>:<span class="hljs-number">13</span><br>Sun Oct <span class="hljs-number">06</span> <span class="hljs-number">11</span>:<span class="hljs-number">27</span>:<span class="hljs-number">13</span> CST <span class="hljs-number">2024</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>java.utils.Calender(日历)</p><ul><li><p>Date类中大部分API被废弃，替换为Calendar</p></li><li><p>Calendar类是一个抽象类，主要用于完成日期字段之间相互操作的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*Calender: 日历类</span><br><span class="hljs-comment"> * 实例化：由于Calendar是一个抽象类，所以需要创建其子类的实例，通过Calendar的静态方法getInstance()即可获取</span><br><span class="hljs-comment"> * 常用方法：get(int field)</span><br><span class="hljs-comment"> *         set(int field, xx)</span><br><span class="hljs-comment"> *         add(int field, xx)</span><br><span class="hljs-comment"> *         getTime()</span><br><span class="hljs-comment"> *         setTime()</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>    System.out.println(calendar.getClass());<br><br>    <span class="hljs-comment">// get(int field)</span><br>    System.out.println(calendar.get(Calendar.DAY_OF_MONTH));<br>    System.out.println(calendar.get(Calendar.DAY_OF_YEAR));<br><br>    <span class="hljs-comment">// set(int field, xx)</span><br>    calendar.set(Calendar.DAY_OF_MONTH, <span class="hljs-number">23</span>);<br>    System.out.println(calendar.get(Calendar.DAY_OF_MONTH));<br><br>    <span class="hljs-comment">// add(int field, xx)</span><br>    calendar.add(Calendar.DAY_OF_MONTH, -<span class="hljs-number">1</span>);<br>    System.out.println(calendar.get(Calendar.DAY_OF_MONTH));<br><br>    <span class="hljs-comment">// getTime()</span><br>    System.out.println(calendar.getTime());<br><br>    <span class="hljs-comment">// setTime()</span><br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    calendar.setTime(date);<br>    System.out.println(calendar.getTime());<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.util.GregorianCalendar<br><span class="hljs-number">6</span><br><span class="hljs-number">280</span><br><span class="hljs-number">23</span><br><span class="hljs-number">22</span><br>Tue Oct <span class="hljs-number">22</span> <span class="hljs-number">11</span>:<span class="hljs-number">45</span>:<span class="hljs-number">38</span> CST <span class="hljs-number">2024</span><br>Sun Oct <span class="hljs-number">06</span> <span class="hljs-number">11</span>:<span class="hljs-number">45</span>:<span class="hljs-number">38</span> CST <span class="hljs-number">2024</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="jdk8新的日期时间api">JDK8：新的日期时间API</h2><ul><li><p>以前的API存在的问题：</p><ul><li><p>可变性：像日期和时间这样的类应该是不可变的</p></li><li><p>偏移性：Date中的年份是从1900开始，月份从0开始</p></li><li><p>格式化：格式化只对Date有用，Calendar则不行</p></li><li><p>此外，它们也不是线程安全的；不能处理润秒等</p></li><li><blockquote><p>润秒（Leap Second）是为了保持协调世界时（UTC, Coordinated UniversalTime）与地球自转时间（即世界时UT1）之间的一致性而偶尔添加的一个额外秒。地球的自转速度并不是恒定不变的，它会因为潮汐摩擦等因素而逐渐减慢。为了使UTC能够反映这种变化，国际地球自转服务（IERS,International Earth Rotation and Reference SystemsService）会在必要时决定在UTC中插入一个额外的秒，这就是润秒。</p><p>润秒通常被加在每年的6月30日或12月31日的最后一分钟，即UTC时间23:59:60，这样可以确保UTC与地球实际自转时间之间的差异不会超过0.9秒。</p><p>润秒的引入对大多数日常生活没有明显影响，但对于需要高精度时间同步的系统（如电信、导航系统、金融交易等）来说，润秒的加入可能会引起技术上的挑战。因此，一些系统选择忽略润秒，或者通过其他方式（比如逐渐调整时间）来避免突然的时间跳跃带来的问题。</p></blockquote></li><li><p>总结：对日期和时间的操作一直是Java程序员最通过的地方之一</p></li></ul></li><li><p>第三次引入的API是成功的，并且Java 8中引入的java.timeAPI已经纠正了过去的缺陷。</p></li><li><p>Java8以一个新的开始为Java创建优秀的API，新的日期时间API包含：</p><ul><li>java.time：包含值对象的基础包</li><li>java.time.chrono：提供对不同的日历系统的访问</li><li>java.time.format：格式化和解析时间和日期</li><li>java.time.temporal：包括底层框架和扩展特性</li><li>java.time.zone：包含时区支持的类</li></ul></li><li><p>说明：新的 java.time 中包含了所有关于时钟 (clock) ，本地日期(LocalDate) 、本地时间 (LocalTime) 、本地日期时间 (LocalDateTime) 、时区(zonedDateTime) 和持续时间 (Duration) 的类。</p></li><li><p>尽管有68个新的公开类型，但是大多数开发者只会用到基础包和format包，大概占总数的三分之一</p></li><li><p>LocalDate, LocalTime, LocalDateTime:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*LocalDate LocalTime LocalDateTime*/</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// now(): 获取当前日期和时间对应的实例</span><br>    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> LocalDate.now();<br>    <span class="hljs-type">LocalTime</span> <span class="hljs-variable">localTime</span> <span class="hljs-operator">=</span> LocalTime.now();<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><br>    System.out.println(localDate);<br>    System.out.println(localTime);<br>    System.out.println(localDateTime);<br><br>    <span class="hljs-comment">// of(): 获取指定的日期和时间对应的实例</span><br>    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate2</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2024</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>);<br>    <span class="hljs-type">LocalTime</span> <span class="hljs-variable">localTime2</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">15</span>, <span class="hljs-number">34</span>, <span class="hljs-number">40</span>);<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime2</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2024</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">34</span>, <span class="hljs-number">40</span>);<br><br>    System.out.println(localDate2);<br>    System.out.println(localTime2);<br>    System.out.println(localDateTime2);<br><br>    <span class="hljs-comment">// getXXX()</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime3</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    System.out.println(localDateTime3.getDayOfMonth());<br><br>    <span class="hljs-comment">// 体现不可变性 withXxx()</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime4</span> <span class="hljs-operator">=</span> localDateTime3.withDayOfMonth(<span class="hljs-number">15</span>);<br>    System.out.println(localDateTime3.getDayOfMonth());<br>    System.out.println(localDateTime4.getDayOfMonth());<br><br>    <span class="hljs-comment">// plusXxx()</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime5</span> <span class="hljs-operator">=</span> localDateTime3.plusDays(<span class="hljs-number">1</span>);<br>    System.out.println(localDateTime5.getDayOfMonth());<br><br>    <span class="hljs-comment">// minusXxx()</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime6</span> <span class="hljs-operator">=</span> localDateTime5.minusDays(<span class="hljs-number">1</span>);<br>    System.out.println(localDateTime6.getDayOfMonth());<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">2024</span>-<span class="hljs-number">10</span>-<span class="hljs-number">07</span><br><span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">24.802</span><br><span class="hljs-number">2024</span>-<span class="hljs-number">10</span>-07T14:<span class="hljs-number">51</span>:<span class="hljs-number">24.802</span><br><span class="hljs-number">2024</span>-<span class="hljs-number">10</span>-<span class="hljs-number">06</span><br><span class="hljs-number">15</span>:<span class="hljs-number">34</span>:<span class="hljs-number">40</span><br><span class="hljs-number">2024</span>-<span class="hljs-number">10</span>-06T15:<span class="hljs-number">34</span>:<span class="hljs-number">40</span><br><span class="hljs-number">7</span><br><span class="hljs-number">7</span><br><span class="hljs-number">15</span><br><span class="hljs-number">8</span><br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure></li><li><p>瞬时：Instant</p><ul><li><p>java.time.Instant表示时间线上的一点，从1970年1月1日0时0分0秒开始的秒数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// now()</span><br>    <span class="hljs-type">Instant</span> <span class="hljs-variable">instant</span> <span class="hljs-operator">=</span> Instant.now();<br>    System.out.println(instant);<br><br>    <span class="hljs-comment">// 了解</span><br>    <span class="hljs-type">OffsetDateTime</span> <span class="hljs-variable">instant1</span> <span class="hljs-operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="hljs-number">8</span>));<br>    System.out.println(instant1);<br><br>    <span class="hljs-type">Instant</span> <span class="hljs-variable">instant2</span> <span class="hljs-operator">=</span> Instant.ofEpochMilli(<span class="hljs-number">4445613216556L</span>);<br>    System.out.println(instant2);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>DateTimeFormatter</p><ul><li><p>用于格式化和解析LocalDate, LocalTime, LocalDateTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 自定义格式化</span><br>    <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-comment">// 格式化：日期、时间 → 字符串</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> dateTimeFormatter.format(now);<br>    System.out.println(format);<br><br>    <span class="hljs-comment">// 解析化：字符串 → 日期、时间</span><br>    <span class="hljs-type">TemporalAccessor</span> <span class="hljs-variable">temporalAccessor</span> <span class="hljs-operator">=</span> dateTimeFormatter.parse(format);<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.from(temporalAccessor);<br>    System.out.println(localDateTime);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>还有其他的API，新的日期和传统日期还可以进行转换，具体用到了看文档</p></li></ul><h2 id="比较器">比较器</h2><ul><li>需求<ul><li>对于基础数据类型，通过比较运算符是可以比较大小。对于引用数据类型，不能直接通过比较运算符来比较大小。</li><li>在Java中经常会涉及到对象数组的排序问题，就涉及到对象之间的比较问题。</li></ul></li><li>实现Comparable接口的方式<ul><li>实现步骤<ul><li>具体的类实现Comparable接口</li><li>重写接口中的compareTo(Objecto)方法，在此方法中指明比较类A的对象的大小的标准</li><li>相等返回0，大于返回正数，小于返回负数</li></ul></li></ul></li><li>对于实现Comparable接口的方式可能存在的问题：<ul><li>当元素的类型没有实现Comparable接口，又不方便修改代码（一些第三方类，只有.class文件）</li><li>不想使用预定义的方法比较大小</li></ul></li><li>JDK由于以上问题，增加了java.util.Comparator接口，强行对多个对象进行整体排序的比较</li></ul><h1 id="反射机制">17 反射机制</h1><h2 id="概念">概念</h2><ul><li><p>Reflection被视为<code>动态语言</code>的关键，该机制允许程序在<code>运行期间</code>借助相关API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p></li><li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。<code>这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</code></p></li><li><p>对对象的操作（创建对象、调用结构等）</p><ul><li><p>不使用反射：考虑封装性，不能调用private</p></li><li><p>使用反射：可以调用运行时类中任意的构造器、属性、方法等，包括私有的</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Person&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">showNation</span><span class="hljs-params">(String nation)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;国籍是：&quot;</span> + nation;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionTest</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用反射之前可以执行的操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        System.out.println(p1);<br><br>        p1.age = <span class="hljs-number">10</span>;<br>        System.out.println(p1.age);<br><br>        p1.show();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用反射完成上述操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 创建实例</span><br>        Class&lt;Person&gt; clazz = Person.class;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>        System.out.println(p1);<br><br>        <span class="hljs-comment">// 2. 获取属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">ageField</span> <span class="hljs-operator">=</span> clazz.getField(<span class="hljs-string">&quot;age&quot;</span>);<br>        ageField.set(p1, <span class="hljs-number">10</span>);<br>        System.out.println(ageField.get(p1));<br><br>        <span class="hljs-comment">// 3. 调用方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">showMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;show&quot;</span>);<br>        showMethod.invoke(p1);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用反射还可以调用类中private修饰的结构</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 调用私有的构造器，创建Person的实例</span><br>        Class&lt;Person&gt; clazz = Person.class;<br>        Constructor&lt;Person&gt; constructor = clazz.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class);<br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">12</span>);<br>        System.out.println(p1);<br><br>        <span class="hljs-comment">// 2. 调用私有的属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(p1, <span class="hljs-string">&quot;Jerry&quot;</span>);<br>        System.out.println(nameField.get(p1));<br><br>        <span class="hljs-comment">// 3. 调用私有的方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">showNationMethod</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;showNation&quot;</span>, String.class);<br>        showNationMethod.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">nation</span> <span class="hljs-operator">=</span> (String) showNationMethod.invoke(p1, <span class="hljs-string">&quot;China&quot;</span>);<br>        System.out.println(nation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用场景</p><ul><li>在开发中，基本上都是使用非反射方式</li><li>由于反射体现了动态性（可以在运行时动态获取对象所属的类，动态的调用相关的方法），所以在设计框架的时候会大量使用反射</li><li><code>框架 = 注解 + 反射 + 设计模式</code></li></ul></li><li><p>问题：</p><ul><li>单例模式中的饿汉式和懒汉式，私有化类的构造器。是否可以通过反射，创建单例模式中类的多个对象？<ul><li>可以</li></ul></li><li>通过反射，可以调用类中私有的结构，是否与面向对象的封装性有冲突？是不是Java语言设计存在Bug<ul><li>不存在Bug</li><li>封装性体现的是是否建议调用内部api的问题，private是不建议调用</li><li>反射体现的是能否的问题，因为类的完整结构都加载到内存中，所以有能力进行调用。</li></ul></li></ul></li><li><p>Java反射机制提供的功能</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul></li><li><p>反射相关的API</p><ul><li><code>java.lang.Class</code>：代表一个类</li><li>java.lang.reflect.Method：代表类的方法</li><li>java.lang.reflect.Field：代表类的成员变量</li><li>java.lang.reflect.Constructor：代表类的构造器</li><li>...</li></ul></li><li><p>反射的优缺点</p><ul><li>优点<ul><li>提高了Java程序的灵活性和扩展性，降低了耦合性，提高了<code>自适应</code>能力</li><li>运行程序创建和控制任何类的对象，无需提前<code>硬编码</code>目标类</li></ul></li><li>缺点<ul><li>反射的<code>性能较低</code><ul><li>反射机制主要应用在对灵活性和扩展性要求很高的系统框架上</li></ul></li><li>反射会<code>模糊</code>程序内部逻辑，<code>可读性较差</code></li></ul></li></ul></li><li><p>获取Class实例的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-comment">// 1. 调用运行时类的静态属性 .class</span><br>    Class&lt;User&gt; clazz1 = User.class;<br>    System.out.println(clazz1);<br><br>    <span class="hljs-comment">// 2. 调用运行时类的对象的getClass()</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    Class&lt;User&gt; clazz2 = (Class&lt;User&gt;) u1.getClass();<br>    System.out.println(clazz1 == clazz2);<br><br><br>    <span class="hljs-comment">// 3. 调用Class的静态方法forName(String className)</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.atguigu02._class.User&quot;</span>;<br>    Class&lt;User&gt; clazz3 = (Class&lt;User&gt;) Class.forName(className);<br>    System.out.println(clazz1 == clazz3);<br><br>    <span class="hljs-comment">// 4. 使用类的加载器的方式</span><br>    Class&lt;User&gt; clazz4 = (Class&lt;User&gt;) ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;com.atguigu02._class.User&quot;</span>);<br>    System.out.println(clazz1 == clazz4);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其中方式3使用最多，最能体现灵活性</li></ul></li><li><p>Class的实例都可以指向的结构</p><ul><li>所有Java类型</li><li>class</li><li>interface</li><li>[]</li><li>enum</li><li>annotation</li><li>primitive type</li><li>void</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面向对象编程</title>
    <link href="/2024/04/01/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/04/01/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程基础">6 面向对象编程（基础）</h1><ul><li><p>学习面向对象的三条主线</p><ul><li>Java类及类的成员：（重点）属性和方法、构造器；（熟悉）代码块、内部类</li><li>面向对象的特征：封装、继承、多态、（抽象）</li><li>其他关键字的使用：this、super、package、import、static、final、interface、abstract等</li></ul></li><li><p><code>面向对象</code>是软件开发的一类编程风格、开发范式。还有<code>面向过程</code>、指令式编程、函数式编程</p></li><li><p>类 class是具有相同特征的事务的抽象描述，是抽象的，概念上的定义</p></li><li><p>对象 object 是实际存在的该类事务的每个个体，是具体的，也称为实例instance</p></li><li><p>面向对象程序设计的重点是类的设计，类的设计也就是类的成员的设计</p></li><li><p>对象在内存中的分配</p><ul><li>栈：方法内定义的变量</li><li>堆：new 出来的结构（数组实体、对象实体），包括对象的属性</li><li>方法区：存放类的模板</li></ul></li><li><p>变量根据在类中声明的位置的不同，分为成员变量和局部变量</p></li><li><p>方法是类或对象行为特征的抽象，用来完成某个功能操作。</p></li><li><p>将功能封装为方法目的是：实现代码重写、减少冗余、简化代码</p></li><li><p>Java中的方法不能独立存在，所有方法必须定义在类里</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">权限修饰符 [其他修饰符] 返回值类型 方法名(形参列表) [<span class="hljs-keyword">throws</span> 异常类型] &#123; <span class="hljs-comment">// 方法头</span><br>    <span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li>[]中不是必须得</li></ul></li><li><p>权限修饰符：public、protected、缺省、private</p></li><li><p>方法内不能定义方法</p></li><li><p>方法的重载</p><ul><li>方法重载overload：用一个类中，方法名相同，参数列表不同。满足以上特征的多个方法，彼此之间构成方法的重载。</li><li>参数列表不同指的是参数个数，参数类型，参数顺序</li></ul></li><li><p>可变个数形参的方法</p><ul><li><p>jdk5.0引入的特性</p></li><li><p>在调用方法时，方法形参类型确定，个数不确定，此时可以使用可变个数形参的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数列表 ... 参数名)<br></code></pre></td></tr></table></figure></li><li><p>可以为0个、1个或多个</p></li><li><p>可变个数形参只能有一个，且在参数列表最后</p></li><li><p>可变个数形参的方法与同一个类中，同名的多个方法之间可以构成重载，优先执行固定参数，没有匹配的再执行可变参数</p></li><li><p>特例：可变个数形参的方法与同一个类中方法名相同，且与可变个数形参的类型相同的数组参数不构成重载，认为是一个方法。</p></li><li><p>在方法内对可变个数形参的访问就当数组参数访问即可</p></li></ul></li><li><p>方法的值传递机制</p><ul><li>值传递：存什么传什么，存数据值就传数据值，存地址值就传地址值</li></ul></li><li><p>递归方法</p><ul><li>recursion method：方法自己调用自己的现象称为递归方法</li><li>分类<ul><li>直接递归：A调用A</li><li>间接递归：A调用B，B调用A，...</li></ul></li><li>递归一定要向“已知方向”递归，否则这种递归变成无穷递归，类似于死循环。最终发生“栈内存溢出”</li><li>递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢得多，所以在使用递归时要慎重</li><li>在要求高性能的情况下尽量避免使用递归，递归调用即花时间又耗内存。考虑使用循环迭代</li></ul></li></ul><h2 id="packageimport">package&amp;import</h2><ul><li><p>package关键字</p><ul><li><p>package包，用于指明该文件中定义的类、接口等结构所在的包。</p></li><li><p>一个源文件只能有一个声明包的package语句</p></li><li><p>package语句作为Java源文件的第一条语句出现，若缺省该语句，则指定为无名包</p></li><li><p>包名：通常为公司域名的倒置，不要起名java.**</p></li><li><p>包对应于文件系统的目录，package语句中用"."来指明包的层次</p></li><li><p>同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构。不同的包下可以定义同名的结构</p></li><li><p>JDK中主要的包</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang:包含一些Java的核心类，如String、Math、Integer、System和Thread等<br>java.net:与网络相关的操作的类和接口<br>jave.io:包含能够提供多种输入、输出功能的类<br>java.util:工具类，定义系统特性、接口的集合框架类、使用与日期日历相关的函数<br>java.text:java格式化相关类<br>java.sql:java进行JDBC数据库编程的相关类/接口<br>java.swt:构成抽象窗口工具集的多个类<br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>import关键字</p><ul><li><p>import导入，为了使用其他包中的Java类，需要使用import语句来显式引入指定包下所需要的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 导入指定类</span><br><span class="hljs-keyword">import</span> 包名.类名;<br><span class="hljs-comment">// 导入某包下的所有结构</span><br><span class="hljs-keyword">import</span> 包名.*;<br></code></pre></td></tr></table></figure></li><li><p>如果是java.lang包下的，就可以省略import语句</p></li><li><p>如果已经导入某包下的类，但是要使用该包下子包的类的话，仍需要导入</p></li><li><p>如果在代码中使用不同包名下的同名的类，就需要使用类的全类名的方式指明调用的是哪个类</p></li><li><p>了解内容：</p><ul><li><p>import static组合的使用，调用指定类或接口下的静态的属性或方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.out;<br>out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="封装性">封装性</h2><ul><li><p>高内聚、低耦合</p><ul><li>内聚：一个模块内各个元素彼此结合的紧密程度，意味着重用和独立</li><li>耦合：一个软件结构内不同模块之间互连程度的度量，意味着多米诺效应</li><li>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</li><li>低耦合：仅暴露少量的方法给外部使用，尽量方便外部调用</li></ul></li><li><p>encapsulation：把客观事物封装成抽象概念的类，并且类可以把自己的数据和方法只向可信的类或对象开放，向没必要开放的类或者对象隐藏信息。（该暴露的暴露，该隐藏的隐藏）</p></li><li><p>Java中使用权限修饰符实现了数据封装，有4种权限修饰符：public、protected、缺省、private</p></li><li><p>使用4种权限修饰符来修饰类及类的内部成员，当这些成员被调用时，体现可见性的大小</p></li><li><table><thead><tr class="header"><th style="text-align: center;">修饰符</th><th style="text-align: center;">本类内部</th><th style="text-align: center;">本包内</th><th style="text-align: center;">其他包的子类</th><th style="text-align: center;">其他包非子类</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">private</td><td style="text-align: center;">√</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td></tr><tr class="even"><td style="text-align: center;">缺省</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">×</td><td style="text-align: center;">×</td></tr><tr class="odd"><td style="text-align: center;">protected</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">×</td></tr><tr class="even"><td style="text-align: center;">public</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr></tbody></table></li><li><p>外部类：只能使用public、缺省修饰</p><ul><li>不能被private修饰是因为，这个类不能创建实例，属性和方法不能被访问，毫无意义</li><li>不能被protected修饰，其他包想要访问该类就必须是该类的子类，但是非子类无法访问，无法继承</li></ul></li><li><p>类的内部成员：4种修饰权限</p></li><li><p>IDEA右键生成可以自动生成getter和setter方法</p></li></ul><h2 id="构造器">构造器</h2><ul><li><p>constructor</p></li><li><p>构造器作用</p><ul><li>搭配new关键字，创建类的对象</li><li>在创建对象时，可以给对象的相关属性赋值</li></ul></li><li><p>格式</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">权限修饰符 类名(形参列表)&#123;&#125;<br></code></pre></td></tr></table></figure></p><ul><li>4种修饰符都可以修饰</li></ul></li><li><p>如果当前类中没有显式提供任何构造器时，系统会默认提供一个空参的构造器，且构造器权限与类权限相同</p></li><li><p>如果显式的声明了构造器，那么系统就不再提供默认的构造器，如果要使用空参的构造器时需要手动声明。但是如果不用，不声明也可以。</p></li><li><p>类中属性（当前仅考虑实例变量）赋值过程顺序：</p><ol type="1"><li>默认初始化</li><li>显式初始化</li><li>构造器初始化</li><li>通过对象.方法赋值 / 通过对象.属性赋值</li></ol></li></ul><h2 id="javabean">JavaBean</h2><ul><li>是一种Java语言写成的可重用组件</li><li>标准<ul><li>类是公共的</li><li>有一个无参的公共的构造器</li><li>有属性，且有对应的get、set方法</li></ul></li></ul><h2 id="uml">UML</h2><ul><li>统一建模语言，用来描述软件模型和架构的图像化语言</li><li>+表示public，-表示private，#表示protected</li><li>方法的写法<ul><li>方法的类型(+、-) 方法名(参数名: 参数类型): 返回值类型</li><li>若方法有下划线表示为构造器</li></ul></li><li>斜体表示抽象方法或类</li></ul><h1 id="面向对象编程进阶">7 面向对象编程（进阶）</h1><h2 id="this">this</h2><ul><li><p>this可以调用成员变量、方法、构造器</p></li><li><p>this在方法中调用时表示当前对象，在构造器中调用时表示当前正在创建的对象</p></li><li><p>this可以解决的问题</p><ul><li><p>用于解决形参名和属性名同名的问题</p></li><li><p>在构造器中调用其他构造器，但是必须位于当前构造器首行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> age;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>(name);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="inheritance">Inheritance</h2><ul><li><p>继承性的理解</p><ul><li>自上而下：定义了类A，再定义类B时，发现B功能与A相似，则B继承于A</li><li>自下而上：定义了B、C、D，发现都有相似的属性和方法，可以将属性和方法进行抽取，封装到类A中，让B、C、D继承于类A</li></ul></li><li><p>继承的优点</p><ul><li>减少代码冗余，提高代码复用性</li><li>有利于功能的扩展</li><li>让类之间出现了<code>is-a</code>的关系，为多态提供了前提</li></ul></li><li><p>继承的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类A：父类、superClass、超类、基类</li><li>类B：子类、subClass</li></ul></li><li><p>通过继承，子类就获取到了父类中声明的所有的属性和方法；但是由于封装性的影响，可能子类不能直接调用父类中声明的属性或方法；子类在继承父类以后，还可以扩展自己特有的功能（体现：增加特有的属性、方法）</p></li><li><p>Java中声明的类，如果没有显式的声明其父类时，则默认继承于<code>java.lang.Object</code></p></li><li><p>Java是支持多层继承，可能有直接父类和间接父类</p></li><li><p>Java中的父子类概念是相对的</p></li><li><p>Java中一个父类可以声明多个子类，反之，一个子类只能有一个父类（Java的单继承性）</p></li></ul><h2 id="重写">重写</h2><ul><li><p>overwrite /overrride：子类在继承父类后，就获取了父类中声明的所有方法。但是，父类中的方法可能不太适用于子类。换句话说，子类需要对父类中继承过来的方法进行覆盖、覆写的操作</p></li><li><p>重写的具体规则</p><ol type="1"><li>方法名和参数列表：父类被重写的方法与子类重写的方法的方法名和形参列表必须相同</li><li>权限修饰符：子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</li><li>权限修饰符：子类不能重写父类中声明为private的方法</li><li>返回值类型<ul><li>父类方法没有返回值，则子类方法没有返回值</li><li>父类方法返回基本数据类型，则子类方法返回相同的基本数据类型</li><li>父类方法返回引用数据类型，则子类方法返回相同的引用数据类型或该返回值类型的子类</li></ul></li><li>异常：子类重写的方法抛出的异常类型可以与父类中方法抛出的异常类型相同，或者是其子类</li><li>方法体：没有要求</li></ol></li><li><blockquote><p>方法的重载 overload 和重写 override / overwrite的区别：</p><p>overload：两同一不同（同一个类，同一个方法名，不同形参列表）</p><p>overwrite：继承之后，子类覆盖父类中同名同参数的方法</p></blockquote></li><li><p>可以在重写的方法上面加上@Overrride注解，让编译器进行检查是否真的是方法重写</p></li></ul><h2 id="super">super</h2><ul><li>子类使用super关键字调用父类中的属性和方法</li><li>super关键字的使用形式上与this关键字的使用相同</li><li>如果要调用父类的构造器，格式为“super(形参列表)”，且同样在构造器首行。所以构造器首行this和super只能二选一</li><li>子类中的任何一个构造器都会调用父类的构造器或者本类中重载的构造器，默认不写会调用父类的空参的构造器。</li><li>在通过子类的构造器创建对象时，一定在调用子类构造器的过程中，直接或间接的调用父类的构造器。正因为如此，我们才会将父类中声明的属性或方法加载到内存中，供子类对象使用。</li></ul><h2 id="polymorphism">polymorphism</h2><ul><li><p>多态性：一个事物的多种形态</p></li><li><p>Java中多态性的体现：父类的引用指向子类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br></code></pre></td></tr></table></figure></li><li><p>在多态场景下，调用方法时</p><ul><li>编译时：认为方法是左边声明的父类的类型的方法（即被重写的方法）</li><li>运行时：实际执行的是子类重写父类的方法</li></ul></li><li><p>多态性使用前提</p><ol type="1"><li>要有类的继承关系</li><li>要有方法的重写</li></ol></li><li><p>多态性适用于方法，不适用于属性</p></li><li><p>多态性的优点</p><ul><li>极大的减少了代码的冗余，不需要定义多个重载的方法</li></ul></li><li><p>多态性的缺点</p><ul><li>父类引用指向子类对象，内存中仍然有子类中特有的属性和方法，但是无法调用</li></ul></li><li><blockquote><p>使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，提高了扩展性，符合开闭原则</p><p>【开闭原则OCP】</p><ul><li>对扩展开放，对修改关闭</li><li>软件系统中的各种组件，如模块、类、功能等，应该在不修改现有代码的基础上，引入新功能</li></ul></blockquote></li></ul><h2 id="向上向下转型">向上向下转型</h2><ul><li><p>多态是通过父类引用指向子类对象的方式实现的，在编译期间就会出现类型转换的现象。此时就无法调用子类中特有的属性和方法，想要调用就要做类型转换，使得<code>编译通过</code>。</p></li><li><p>向上转型</p><ul><li>与自动类型提升相似</li><li>多态</li></ul></li><li><p>向下转型</p><ul><li><p>与强制类型转换相似</p></li><li><p>建议在向下转型之前，使用instanceof进行判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br><span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> Man) &#123;<br>    <span class="hljs-type">Man</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (Man) p;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="object类">Object类</h2><ul><li>所有类都是<code>java.lang.Object</code>的子类，所以Object类中声明的结构具有通用性。</li><li>Object类中没有属性，只有一个空参的构造器，重点看方法</li><li>方法<ul><li>重点方法：equals()  toString()</li><li>了解方法：clone()  finalize()</li><li>目前不需要关注的方法：getClass()  hashCode()  notify()  notifyAll() wait()  wait(xx)  wait(xx, yy)</li></ul></li></ul><h3 id="clone">clone()</h3><ul><li>创建并返回当前对象的副本</li></ul><h3 id="finalize">finalize()</h3><ul><li>当GC要回收此对象时，调用该方法</li><li>该方法可能导致内部出现循环引用，导致此对象不能被回收</li></ul><h3 id="equals">equals()</h3><ul><li>任何引用数据类型都可以使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<br><span class="hljs-type">User</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;1234&quot;</span>);<br>System.out.println(u1.equals(u2));<span class="hljs-comment">// false</span><br><span class="hljs-comment">// 源码，比较两个对象地址值是否相同</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>String类对该方法进行重写，所以两个不同的String对象，但是字符串值相同，那么该方法执行结果也为true</li><li>String、File、Date和包装类等，都重写了equals()方法，用于比较两个对象的实体内容是否相同</li><li>在自定义类中根据需要也需要对equals方法进行重写，用于比较两个对象的实体内容是否相同</li><li>在IDEA中，右键Generate中可以自动生成该方法</li><li>==和equals()区别<ul><li>使用范围<ul><li>==是个运算符，适用于基本数据类型、引用数据类型；基本数据类型用于判断数据值是否相等；引用数据类型用于比较两个引用变量的地址值是否相等；</li><li>equals()是个方法，只适用于引用数据类型；</li></ul></li></ul></li></ul><h3 id="tostring">toString()</h3><ul><li><p>Object类中toString()的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>String、File、Date和包装类等，都重写了toString()方法，用于输出当前对象的实体内容</p></li><li><p>在IDEA中，右键Generate中可以自动生成该方法</p></li></ul><h1 id="面向对象编程高级">8 面向对象编程（高级）</h1><h2 id="static">static</h2><ul><li>对于实例变量来说，每个实例有自己单独的一份。如果想要一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（或类属性）</li><li>在类中声明的实例方法，在类的外面必须要先创建对象，才能调用。但是类方法不用创建对象即可调用，简化了方法的调用。</li><li>类变量和类方法，只需要使用static关键字修饰即可。也称为静态变量、静态方法。</li><li>static可以用来修饰的结构<ul><li>属性</li><li>方法</li><li>代码块</li><li>内部类</li></ul></li><li>静态变量在内存中的位置<ul><li>jdk6及之前，存放在方法区</li><li>jdk7及之后，存放在堆空间</li></ul></li><li>静态变量可以被类直接调用，也可以使用对象调用</li><li>静态方法只可以调用静态属性和方法，不能使用this和super</li><li>什么属性应该是静态的<ul><li>判断当前类的多个实例是否能共享此成员变量，且此成员变量的值是相同的。</li><li>将一些常量声明为静态的，比如Math中的PI</li></ul></li><li>什么方法应该是静态的<ul><li>方法内操作的变量都是静态变量，则建议将此方法声明为静态方法。（非静态方法也可以调用静态变量，此处只是建议）</li><li>工具类中的方法，声明为静态方法</li></ul></li></ul><h2 id="单例模式">单例模式</h2><ul><li>设计模式：在大量的实践中总结和理论化之后优选的代码结构，编程风格，以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。</li><li>经典的设计模式有<code>23</code>种，每个设计模式均是解决特定环境下特定问题的处理方法</li><li>Singleton设计模式：对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</li><li>思路<ul><li>为了不能通过new创建对象，那么<code>构造器必须是私有的</code></li><li>构造器是私有的，就无法获得对象，就<code>只能调用静态方法获取类的对象</code></li><li>静态方法只能访问静态变量，那么<code>对象变量必须是静态的</code></li></ul></li></ul><h3 id="饿汉式">饿汉式</h3><ul><li>立即加载</li><li>线程安全</li><li>访问更快</li><li>内存占用时间长</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Bank</span> <span class="hljs-variable">isntance</span> <span class="hljs-operator">=</span> Bank.getInstance();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Bank</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bank</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Bank</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式">懒汉式</h3><ul><li>延迟加载</li><li>线程不安全，后面可以解决该问题</li><li>在需要的时候创建，节省内存空间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GirlFriendTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GirlFriend</span> <span class="hljs-variable">girlFriend</span> <span class="hljs-operator">=</span> GirlFriend.getInstance();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GirlFriend</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">GirlFriend</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">GirlFriend</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GirlFriend <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GirlFriend</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码块">代码块</h2><ul><li><p>代码块（初始化块）用来初始化类或对象的成员变量</p></li><li><p>修饰符只能使用static进行修饰</p></li><li><p>分类</p><ul><li>静态代码块<ul><li>类加载时自动执行，只会执行一次，用来初始化类的信息，只能调用静态的属性和方法</li></ul></li><li>非静态代码块<ul><li>对象创建时自动执行，创建几次对象就执行几次，用来初始化对象的信息，属性和方法都可以调用</li></ul></li></ul></li><li><p>静态代码块的执行要先于非静态代码块的执行</p></li><li><p>实例变量赋值的执行顺序</p><ol type="1"><li>默认初始化</li><li>显式初始化 /代码块初始化（两个哪个在前面哪个先执行，显式初始化虽然写在一行但是字节码中是分布执行的，先声明后初始化）</li><li>构造器初始化</li><li>通过对象进行赋值</li></ol></li><li><blockquote><p>java程序编译后生成的字节码文件中，每一个&lt;init&gt;方法都对应一个类的构造器，除了对应的构造器中的代码外，还有显式赋值代码，代码块初始化代码。&lt;init&gt;对应构造器，但是不等同于构造器，该方法就是用来初始化当前创建的对象的信息。</p></blockquote></li><li><p>赋值的选择</p><ul><li>显式赋值：比较适用于每个对象的属性值相同的场景</li><li>构造器赋值：比较适用于每个对象的属性值不相同的场景</li><li>代码块赋值：一般静态代码块会用，非静态代码块一般不常用</li></ul></li></ul><h2 id="final">final</h2><ul><li>final 最终的，可以用来修饰：<ul><li>类：该类不能被继承，如：String、StringBuffer、StringBuilder</li><li>方法：该方法不能被重写，如Object类中getClass()方法</li><li>变量：成员变量和局部变量，常量，一旦赋值不可更改，在形参列表中可以加上关键字final</li></ul></li><li>final和static搭配修饰成员变量时，我们可以称该变量为全局常量</li></ul><h2 id="abstract">abstract</h2><ul><li>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于没有具体的实例，这样的类叫做<code>抽象类</code>。</li><li>在类前面使用abstract关键字修饰，该类称为抽象类，不能实例化，但是抽象类有构造器，用于提供给子类用</li><li>在方法前面使用abstract关键字修饰，该方法称为抽象方法，不能有方法体，包含抽象方法的类称为抽象类。子类必须实现（implement）父类中的抽象方法。</li><li>抽象类的子类要么实现抽象类的所有方法，要么也是一个抽象类</li><li>abstract不能和哪些关键字共用<ul><li>私有方法：如果一个方法是私有的，就无法被重写，也就无法使用abstract</li><li>static：抽象方法没有方法体，但是static修饰的方法可以使用类调用，矛盾</li><li>final：抽象方法需要被重写，final方法不能被重写，矛盾</li></ul></li></ul><h2 id="interface">interface</h2><ul><li>接口和类是并列的结构</li><li>继承是“是不是”的关系“is-a”，接口是能不能得关系“has-a”</li><li>接口的本质是契约、标准、规范</li><li>接口的关键字：interface</li><li>接口内部<ul><li>属性：必须使用public static final修饰（全局常量），可以省略不写</li><li>方法：jdk8之前，只能声明抽象方法，使用publicabstract修饰；jdk8，可以声明静态方法，默认方法；jdk9，可以声明私有方法</li><li>不能有构造器和代码块</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Bullet</span> <span class="hljs-variable">bullet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bullet</span>();<br>        bullet.fly();<br>        bullet.attack();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">MIN_SPEED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">MAX_SPEED</span> <span class="hljs-operator">=</span> <span class="hljs-number">7900</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Attackable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bullet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span>, Attackable &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;让子弹飞一会儿&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子弹有攻击性&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>类相较于父类来说称为子类，相较于实现的接口来说，称为实现类。一个类只能有一个直接父类，但是可以实现多个接口</p></li><li><p>如果一个类没有将其实现的接口中的所有方法都实现，那么可以将该方法声明为抽象类</p></li><li><p>接口和接口之间可以继承，并且可以多继承</p></li><li><p>接口的多态的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">接口名 变量名 = <span class="hljs-keyword">new</span> 实现类();<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsbTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br><br>        <span class="hljs-comment">// 1. 创建接口实现类的对象</span><br>        <span class="hljs-type">Usb</span> <span class="hljs-variable">usb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Camera</span>();<br>        computer.transfer(usb1);<br>        <span class="hljs-comment">// 2. 创建接口实现类的匿名对象</span><br>        computer.transfer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Camera</span>());<br>        <span class="hljs-comment">// 3. 创建接口匿名实现类的对象</span><br>        <span class="hljs-type">Usb</span> <span class="hljs-variable">usb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Usb</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;打印机开始接收数据&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;打印机停止接收数据&quot;</span>);<br>            &#125;<br>        &#125;;<br>        computer.transfer(usb2);<br>        <span class="hljs-comment">// 4. 创建接口匿名实现类的匿名对象</span><br>        computer.transfer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Usb</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;硬盘开始接收数据&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;硬盘停止接收数据&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Usb</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Usb usb)</span> &#123;<br>        usb.start();<br>        usb.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Camera</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Usb</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;相机开始接收数据&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;相机停止接收数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>仔细看一下上面的代码</li><li>抽象类和接口的异同<ul><li>相同：都可以声明抽象方法；都不能实例化</li><li>不同：抽象类一定有构造器，接口没有构造器；</li></ul></li></ul><h3 id="final方法的扩充">final方法的扩充</h3><ul><li>jdk8之前，只能声明抽象方法，使用publicabstract修饰；jdk8，可以声明静态方法，默认方法；jdk9，可以声明私有方法</li><li>接口中声明的静态方法只能被接口调用，不能使用其实现类进行调用</li><li>默认方法关键字：default</li><li>接口中声明的默认方法可以被实现类继承，实现类在没有重写该方法的情况下，默认调用接口中声明的默认方法。如果实现类重写了该方法，则调用的是自己重写的方法。</li><li>接口冲突：实现了两个接口，两个接口中定义了同名同参数的默认方法，则实现类在没有重写此两个接口默认方法的情况下，会报错。<ul><li>解决方法：实现类必须重写接口中定义的同名同参数的方法</li></ul></li><li>类优先原则：子类继承了父类，并实现了接口。父类和接口中声明了同名同参数的方法，此时调用方法是调用了父类中的方法。</li><li>如何在子类（实现类）中调用父类或接口中被重写的方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SubClass</span> <span class="hljs-variable">subClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();<br>        subClass.method2();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类中的方法1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类中的方法1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.method1();         <span class="hljs-comment">// 调用父类</span><br>        <span class="hljs-built_in">this</span>.method1();          <span class="hljs-comment">// 调用自己</span><br>        Method.<span class="hljs-built_in">super</span>.method1();  <span class="hljs-comment">// 调用接口</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;接口中的方法1&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内部类">内部类</h2><ul><li>内部类：将类A定义在类B里面，则类A称为内部类InnerClass，类B称为外部类 OuterClass</li><li>为什么需要内部类：<ul><li>当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整结构B又只在为外部事物A提供服务，不在其他地方单独使用，那么这个内部的完整结构B最好使用内部类</li><li>遵循高内聚、低耦合的面向对象开发原则</li></ul></li><li>内部类的举例<ul><li>Thread类内部声明了State类，表示线程的生命周期</li><li>HashMap类中声明了Node类，表示封装的key和value</li></ul></li><li>内部类的分类<ul><li>成员内部类：直接声明在外部类的里面<ul><li>静态内部类</li><li>非静态内部类</li></ul></li><li>局部内部类：声明在方法内、构造器内、代码块内<ul><li>匿名的局部内部类</li><li>非匿名的局部内部类</li></ul></li></ul></li><li>成员内部类的理解<ul><li>与外部类具有相同特性</li><li>和其他成员相同，可以使用四种权限修饰符进行修饰</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClassTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建静态的成员内部类</span><br>        Person.<span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>.Dog();<br>        dog.eat();<br>        <span class="hljs-comment">// 2. 创建非静态的成员内部类</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        Person.<span class="hljs-type">Bird</span> <span class="hljs-variable">bird</span> <span class="hljs-operator">=</span> p1.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>        bird.eat();<br><br>        bird.show(<span class="hljs-string">&quot;啄木鸟&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;人&quot;</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;狗吃骨头&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;鹦鹉&quot;</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;鸟吃米&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String name)</span> &#123;<br>            System.out.println(name);<br>            System.out.println(<span class="hljs-built_in">this</span>.name);<br>            System.out.println(Person.<span class="hljs-built_in">this</span>.name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举类">枚举类</h2><ul><li><p>枚举类本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建</p></li><li><p>若枚举只有一个对象，则可以作为一种单例模式的视线方式</p></li><li><p>枚举类的实现</p><ul><li>在JDK5之前，需要自定义枚举类型</li><li>在之后，支持enum关键字来快速定义枚举类型</li></ul></li><li><p>枚举类和普通类有以下几个不同点：</p><ol type="1"><li>枚举类不能指定继承的父类（因为继承了java.lang.Enum类），但是可以实现多个接口，枚举类默认实现了Comparable接口和Serializable接口</li><li>枚举类的构造方法的访问权限只可为private</li><li>枚举类的实例必须显式列出</li></ol></li><li><p>JDK5.0之前枚举类的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// jdk5.0 之前定义枚举类的方式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Season</span> &#123;<br>    <span class="hljs-comment">// 2. 声明当前类的对象的实例变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String seasonName;  <span class="hljs-comment">// 季节的名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String seasonDesc;  <span class="hljs-comment">// 季节的描述</span><br><br>    <span class="hljs-comment">// 1. 私有化类的构造器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Season</span><span class="hljs-params">(String seasonName, String seasonDesc)</span> &#123;<br>        <span class="hljs-built_in">this</span>.seasonName = seasonName;<br>        <span class="hljs-built_in">this</span>.seasonDesc = seasonDesc;<br>    &#125;<br>    <span class="hljs-comment">// 3. 提供实例变量的get方法</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> seasonName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonDesc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> seasonDesc;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 创建当前类的实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">spring</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;春天&quot;</span>, <span class="hljs-string">&quot;春暖花开&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">summer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;夏天&quot;</span>, <span class="hljs-string">&quot;夏日炎炎&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">autumn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;秋天&quot;</span>, <span class="hljs-string">&quot;秋高气爽&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">winter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;冬天&quot;</span>, <span class="hljs-string">&quot;白雪皑皑&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Enum类中常用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 调用toString方法</span><br>        System.out.println(Season.SPRING);<br>        <span class="hljs-comment">// 获取当前对象名</span><br>        System.out.println(Season.SUMMER.name());<br>        <span class="hljs-comment">// 获取所有对象数组</span><br>        Season[] values = Season.values();<br>        <span class="hljs-keyword">for</span> (Season value : values) &#123;<br>            System.out.println(value);<br>        &#125;<br>        <span class="hljs-comment">// valueOf(String objName): 返回当前枚举类中名称为objName的枚举类对象，如果不存在，则报错</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">objName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;WINTER&quot;</span>;<br>        <span class="hljs-type">Season</span> <span class="hljs-variable">season</span> <span class="hljs-operator">=</span> Season.valueOf(objName);<br>        System.out.println(season);<br>        <span class="hljs-comment">// ordinal(): 返回次序号，默认从0开始</span><br>        System.out.println(Season.AUTUMN.ordinal());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span> &#123;<br>    SPRING(<span class="hljs-string">&quot;春天&quot;</span>),<br>    SUMMER(<span class="hljs-string">&quot;夏天&quot;</span>),<br>    AUTUMN(<span class="hljs-string">&quot;秋天&quot;</span>),<br>    WINTER(<span class="hljs-string">&quot;冬天&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Season</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Season&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br>================================================================================<br>Season&#123;name=<span class="hljs-string">&#x27;春天&#x27;</span>&#125;<br>SUMMER<br>Season&#123;name=<span class="hljs-string">&#x27;春天&#x27;</span>&#125;<br>Season&#123;name=<span class="hljs-string">&#x27;夏天&#x27;</span>&#125;<br>Season&#123;name=<span class="hljs-string">&#x27;秋天&#x27;</span>&#125;<br>Season&#123;name=<span class="hljs-string">&#x27;冬天&#x27;</span>&#125;<br>Season&#123;name=<span class="hljs-string">&#x27;冬天&#x27;</span>&#125;<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>实际中的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmployeeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;小张&quot;</span>, <span class="hljs-number">26</span>, Status.BUSY);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> Status status;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, Status status)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Status <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatus</span><span class="hljs-params">(Status status)</span> &#123;<br>        <span class="hljs-built_in">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Employee&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, status=&quot;</span> + status +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123;<br>    BUSY, FREE, VOCATION, DIMISSION;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="注解">注解</h2><ul><li><p>Annotation注解：从JDK5.0开始引入，以<code>@注解名</code>在代码中存在。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-meta">@SuppressWarnings(value=&quot;unchecked&quot;)</span><br></code></pre></td></tr></table></figure><ul><li>Annotation可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数，这些信息被保存在Annotation的"name=value"对中</li><li>注解可以在类编译、运行时进行加载，体现不同的功能</li></ul></li><li><p>在<code>JavaSE</code>中，注解的使用比较简单。在<code>JavaEE/Android</code>中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的<code>繁冗代码</code>和<code>XML</code>配置等</p></li><li><p>一定程度上可以说：<code>框架 = 注解 + 反射 + 设计模式</code></p></li><li><p>Java基础阶段涉及的三个常用注解</p><ul><li><span class="citation"data-cites="Override">@Override</span>：限定重写父类方法，只能用于方法，可以提供检查机制</li><li><span class="citation"data-cites="Deprecated">@Deprecated</span>：表示所修饰的元素（类、方法等）已过时。通常是因为所修饰的结构危险或存在更好的选择</li><li><span class="citation"data-cites="SuppressWarnings">@SuppressWarnings</span>：抑制编译器警告</li></ul></li><li><p>自定义注解：以SupperWarnings为参照，进行定义即可</p></li><li><p>元注解：对现有的注解进行解释说明的注解</p><ul><li><span class="citation"data-cites="Target">@Target</span>：用于描述注解的使用范围</li><li><span class="citation"data-cites="Retention">@Retention</span>：用于描述注解的声明周期</li><li><span class="citation"data-cites="Documented">@Documented</span>：表明这个注解应该被javadoc工具记录</li><li><span class="citation"data-cites="Inherited">@Inherited</span>：允许子类继承父类中的注解</li></ul></li></ul><h2 id="junit单元测试">JUnit单元测试</h2><ul><li>测试分类<ul><li>黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值</li><li>白盒测试：需要写代码，关注程序具体的执行流程</li></ul></li><li>JUnit是Erich和Kent编写的一个测试框架，供Java开发人员编写单元测试用。</li><li>JUnit测试是白盒测试</li><li>要使用JUnit，必须在项目的编译路径中引入JUnit的库，即相关的.class文件组成的jar包。jar就是一个压缩包，是开发好的第三方工具类，以.class文件形式存在</li><li>IDEA中导入JUnit包<ol type="1"><li>从https://github.com/junit-team/junit4/wiki/Download-and-Install中下载两个jar包</li><li>File-&gt;ProjectStructure-&gt;Libraries-&gt;加号-&gt;Java-&gt;选择包-&gt;选择添加到的模块-&gt;OK-&gt;Apply（每次只能添加一个包，或者把两个包放在一个文件夹下，选择该文件夹即可）</li><li>Modules-&gt;上一步选择添加的模块-&gt;Dependencies即可查看导入的包，Scope显示<code>Compile</code></li></ol></li><li>成功导入两个包后，在想要测试的方法上面加上@Test注解即可</li><li>单元测试的要求<ul><li>单元测试类必须是public，非抽象，包含唯一的无参构造器</li><li><span class="citation"data-cites="Test标记的方法本身必须是public">@Test标记的方法本身必须是public</span>，非抽象的，非静态的，void无返回值，()无参数的</li></ul></li><li>默认情况下，在单元测试方法中使用Scanner会失效<ul><li>解决方案：Help-&gt;Edit Custom VMOptions中加入-Deditable.java.test.console=true，然后重启IDEA即可</li></ul></li><li>由于单元测试需要经常写，所以可以将单元测试方法设置为一个模板<ul><li><figure><img src="自定义JUnit模板步骤1.png" alt="自定义JUnit模板步骤1" /><figcaption aria-hidden="true">自定义JUnit模板步骤1</figcaption></figure></li><li><figure><img src="自定义JUnit模板步骤2.png" alt="自定义JUnit模板步骤2" /><figcaption aria-hidden="true">自定义JUnit模板步骤2</figcaption></figure></li></ul></li></ul><h2 id="包装类">包装类</h2><ul><li><p>Java提供了两种类型：基本数据类型和引用数据类型。当遇到一些只针对对象设计的API或新特性时，如何将基本数据类型进行应用。因此提出了包装类的结构。</p></li><li><table><thead><tr class="header"><th style="text-align: center;">基本数据类型</th><th style="text-align: center;">包装类</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">byte</td><td style="text-align: center;">Byte</td></tr><tr class="even"><td style="text-align: center;">short</td><td style="text-align: center;">Short</td></tr><tr class="odd"><td style="text-align: center;">int</td><td style="text-align: center;">Integer</td></tr><tr class="even"><td style="text-align: center;">long</td><td style="text-align: center;">Long</td></tr><tr class="odd"><td style="text-align: center;">float</td><td style="text-align: center;">Float</td></tr><tr class="even"><td style="text-align: center;">double</td><td style="text-align: center;">Double</td></tr><tr class="odd"><td style="text-align: center;">boolean</td><td style="text-align: center;">Boolean</td></tr><tr class="even"><td style="text-align: center;">char</td><td style="text-align: center;">Character</td></tr></tbody></table></li><li><p>其中前六个数值类型的包装类都有个公共的父类Number</p></li><li><p>基本类型与其包装类的相互转换</p><ul><li>基本数据类型-&gt;包装类（装箱）<ol type="1"><li>使用包装类的构造器（JDK9之后不建议使用）</li><li>valueOf方法（建议使用）</li></ol></li><li>包装类-&gt;基本数据类型（拆箱）<ol type="1"><li>xxxValue()</li></ol></li></ul></li><li><p>jdk5.0特性：自动拆箱，自动装箱</p><ul><li>直接给包装类赋值就行</li><li>将包装类直接就可以赋值给基本数据类型</li><li>以上是一种语法糖，实际上也是通过valueOf和xxxValue()实现的</li></ul></li><li><p>String与基本数据类型、包装类之间的转换</p><ul><li>包装类-&gt;String<ul><li>String.valueOf()</li></ul></li><li>String-&gt;基本数据类型、包装类<ul><li>包装类.parseXxx()</li></ul></li><li>从目标类型中找方法</li></ul></li></ul><h2 id="idea的使用">IDEA的使用</h2><ul><li>通用快捷键<ul><li>撤销：ctrl+z</li><li>反撤销：ctrl+shift+z</li></ul></li><li>常用提高编写速度快捷键<ul><li>智能提示：alt+enter</li><li>使用块环绕：ctrl+alt+t（选择想要环绕的代码，然后再按快捷键）</li><li>自动生成返回值变量：ctrl+alt+v</li><li>复制指定行代码：ctrl+d</li><li>删除指定行代码：ctrl+y</li><li>切换到下一行代码空位：shift+enter</li><li>切换到下一行代码空位：ctrl+alt+enter</li><li>向上移动代码：ctrl+shift+↑</li><li>向下移动代码：ctrl+shift+↓</li><li>方法的形参列表提醒：ctrl+p</li><li>批量修改指定名称：shift+f6</li><li>抽取代码重构方法：ctrl+alt+m</li><li>重写父类的方法：ctrl+o</li><li>实现接口的方法：ctrl+i</li><li>选中的结构的大小写切换：ctrl+shift+u</li><li>批量导包：ctrl+alt+o</li><li>类结构：ctrl+f12</li><li>查看继承树结构：ctrl+h</li><li>查看方法文档：ctrl+q</li><li>类的UML关系图：ctrl+alt+u</li><li>折叠代码块：ctrl+shift+-</li><li>展开代码块：ctrl+shift++</li><li>查找：ctrl+f</li><li>替换：ctrl+r</li><li>全项目搜索文本：ctrl+shift+f</li><li>格式化代码：ctrl+alt+l</li><li>单行注释：ctrl+/</li><li>多行注释：ctrl+shift+/</li><li>缩进：tab</li><li>反缩进：shift+tab</li></ul></li><li>断点调试 Debug<ol type="1"><li>添加断点</li><li>启动调试</li><li>单步执行</li><li>观察变量和执行流程</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python命名规范</title>
    <link href="/2024/03/29/Python%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <url>/2024/03/29/Python%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="python命名规范">Python命名规范</h1><ul><li><p>通用的四种命名方式</p><ul><li>小写下划线：lower_uderscore</li><li>大写下划线：UPPER_UNDERSCORE</li><li>大驼峰：CamelCase</li><li>小驼峰：mixedCase（在Python中不会用到）</li></ul></li><li><p>大写下划线只用来表示常量</p></li><li><p>其他命名都是小写下划线</p></li><li><p>单下划线：占位符，表示用不到的变量</p></li><li><p>一个前置下划线，表示弱私有，尝试表达private性质，但是还是可以强制使用的</p></li><li><p>单前置下划线的小tips：在from module import*时，是不会把单下划线的global variable导入，比较偏无所谓记不记</p></li><li><p>双前置下划线，表示强私有，但是在实际中是对双前置下划线变量进行namemangling，改为单下划线+类名+该变量名</p><ul><li><div class="sourceCode" id="cb1"><preclass="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> MyClass:</span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>          <span class="va">self</span>.__srcret <span class="op">=</span> <span class="dv">0</span></span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  o <span class="op">=</span> MyClass()</span><span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(o._MyClass__srcret)</span></code></pre></div></li><li>所以该机制不是一个安全的feature，只是为了防止误用</li></ul></li><li><p>前后各有两个下划线，叫做dunderscore（double underscore），表示Python中的magicmethod，对于Python的使用者不要把自定义的方法写成这种格式</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基本语法</title>
    <link href="/2024/03/24/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/03/24/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="java语言概述">1 Java语言概述</h1><h2 id="简要介绍">简要介绍</h2><ul><li>Java是学习JavaEE后台、大数据、Android开发的基石</li><li>常用的DOS命令<ul><li>DOS（Disk OperatingSystem，磁盘操作系统）是微软公司在Windows之前推出的一个操作系统，是单用户、单任务的操作系统。后来被Windows系统取代</li><li>md：创建文件夹</li><li>cd：跳转路径</li><li>rd：删除文件夹</li><li>del：删除文件</li><li>cls：清屏</li></ul></li><li>Talk is cheap, show me your code</li><li>Java是SUN公司于1995年推出的高级编程语言</li><li>Java之父：Gosling（詹姆斯 高斯林）</li><li>Java在1.2版本开始分成了J2SE（标准版）、J2EE（企业版）、J2ME（小型版）</li><li>Java从5.0版本开始不再采用1.几的版本编号，平台更名为JavaSE、JavaEE、JavaME</li><li>Java 8.0是5.0以来变化最大的版本，长期支持版本LST，2014年</li><li>Java9.0开始每半年更新一次，每年3月和9月就发布新版本</li><li>JavaSE 标准版<ul><li>支持面向桌面级应用的Java平台</li></ul></li><li>JavaEE 企业版<ul><li>服务器端Web应用开发</li></ul></li><li>JavaME 小型版<ul><li>移动终端</li><li><code>Android开发不等同于Java ME开发</code></li></ul></li></ul><h2 id="开发环境搭建">开发环境搭建</h2><ul><li>JDK（Java DevelopmentKit）：Java程序开发工具包，包含JRE和开发人员使用的工具</li><li>JRE（Java RuntimeEnvironment）：Java程序的运行时环境，包含JVM和运行时所需要的核心类库</li><li>本文档采用Java8.0和Java17.0对比参考学习，主要使用Java17</li><li>安装完Java17后，会自动在系统环境变量path中添加<code>C:\Program Files\Common Files\Oracle\Java\javapath</code>，这个路径自动映射到我们选择安装的路径下面。</li><li>我们采用JAVA_HOME的方式进行环境变量的配置，将上面自动添加的也不做修改，只是让%JAVA_HOME%。（至于为什么不删除，我也不知道）</li></ul><h2 id="helloworld">HelloWorld</h2><ul><li><p>Java程序开发：编写、编译、运行</p></li><li><p>将源代码写到.java的源文件中</p></li><li><p>通过javac命令对该java文件进行编译，生成一个或多个字节码文件.class</p></li><li><p>通过java命令对生成的class文件进行运行</p></li><li><p>在HelloWorld.java文件中编写代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloChina</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>命令javacHelloWorld.java编译生成HelloChina.class字节码文件</p></li><li><p>命令java HelloChina运行该字节码文件，得到结果</p></li><li><p><code>编译以后，会生成一个或多个字节码文件，每一个字节码文件对应一个Java类，并且字节码文件名与类名相同</code></p></li><li><p><code>在一个源文件中，只允许一个类是public的，并且要求该类名要与源文件名相同</code></p></li></ul><h2 id="注释">注释</h2><ul><li><p>单行注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单行注释</span><br></code></pre></td></tr></table></figure></li><li><p>多行数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>单行注释和多行注释中的信息不参与编译，字节码文件中不包含注释信息</p></li><li><p>文档注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"><span class="hljs-doctag">@author</span> 指定java程序的作者</span><br><span class="hljs-comment"><span class="hljs-doctag">@version</span> 指定源文件的版本</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>文档注释内容可以被JDK提供的工具 javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档</p></li><li><p>文档注释必须写在类、接口、方法、构造器、成员字段前面，而写在其他位置，比如函数内部，是无效的文档注释。</p></li><li><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javadoc -d mydoc -author -version HelloWorld.java<br></code></pre></td></tr></table></figure><ul><li><p>-d mydoc：mydoc为输出文档的文件夹</p></li><li><p>-author -version为指定输出的内容</p></li><li><p>HelloWorld.java为指定的java源文件</p></li><li><p>在生成的文件夹下查看index.html即可查看对应的文档</p></li></ul></li><li><p>在类或者方法上面写文档注释也会在生成文档中显示</p></li></ul><h2 id="api文档">API文档</h2><ul><li>API 应用程序接口</li><li>Java 17文档在线注释：https://docs.oracle.com/en/java/javase/17/docs/api/index.html</li></ul><h2 id="jvm">JVM</h2><ul><li>Java的优点：<ul><li>跨平台性：程序运行在JVM上，Write Once, Run Anywhere</li><li>面向对象性</li><li>健壮性</li><li>安全性高</li><li>简单性</li><li>高性能<ul><li>有许多性能优化机制，比之前性能提升了几十倍，比如JIT（Just InTime）即时编译技术</li></ul></li></ul></li><li>Java的缺点：<ul><li>语法复杂</li><li>适合大型网站开发，架构重</li><li>并非适用于所有领域</li></ul></li><li>JVM功能<ul><li>实现Java的跨平台性</li><li>内存管理（分配和回收）</li><li><code>Java还是存在内存溢出和内存泄漏的可能</code></li></ul></li></ul><h2 id="补充">补充</h2><ul><li>Java是一个半编译半解释型语言<ul><li>目前主流的商用Java虚拟机（如HotSpot、OpenJ9）里，Java程序<strong>最初都是通过解释器</strong>(Interpreter）进行<strong>解释执行</strong>的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”（HotSpotCode），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码<strong>编译成本地机器码</strong>，并以各种手段尽可能地进行代码优化（运行时完成这个任务的后端编译器被称为即时编译器，JIT，JustIn Time）</li><li>之前编译成字节码文件的编译器称为前端编译器，后面的JIT编译器称为后端编译器</li><li>并不是所有的JVM都采用解释器与编译器并存的运行架构</li></ul></li></ul><h1 id="变量与运算符">2 变量与运算符</h1><h2 id="关键字">关键字</h2><ul><li>关键字keyword：被Java语言赋予了特殊的含义，用作专门用途的字符串（或单词）</li><li>关键字都是小写字母</li><li>关键字参考链接：https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</li></ul><h2 id="标识符">标识符</h2><ul><li>Java中变量、方法、类等要素命名时使用的字符序列，称为标识符</li><li>规则：<ul><li>由26个英文字母大小写，0-9，_ 或 $ 组成</li><li>数字不可用开头</li><li>不可用使用关键字和保留字，但能包含关键字和保留字</li><li>Java中严格区分大小写，长度无限制</li><li>标识符不能包含空格</li></ul></li><li>规范<ul><li>包名：多单词组成时所有字母都小写</li><li>类名、接口名：大驼峰</li><li>变量名、方法名：小驼峰</li><li>常量名：所有字母大写，多单词用下划线连接</li></ul></li></ul><h2 id="变量">变量</h2><ul><li>变量是内存中的一个存储区域</li><li><code>变量类型 变量名 = 变量值</code></li><li>Java是强类型语言</li><li>Java中的变量类型<ul><li>基本数据类型<ul><li>整型：<ul><li>byte：1字节；<span class="math inline">\(-128\sim127\)</span></li><li>short：2字节；<span class="math inline">\(-2^{15}\sim2^{15}-1\)</span></li><li>int：4字节；<span class="math inline">\(-2^{31}\sim2^{31}\)</span>；默认</li><li>long：8字节；<span class="math inline">\(-2^{63}\sim2^{63}\)</span>；赋值时需要以“l”或“L”作为后缀</li></ul></li><li>浮点型：<ul><li>float：4字节；<span class="math inline">\(-3.403E38\sim3.403E38\)</span>；赋值时需要以“f”或“F”作为后缀；float表数范围要比long类型的表数范围更大，但是精度不高</li><li>double：8字节；<span class="math inline">\(-1.798E308\sim1.798E308\)</span>​；默认</li><li>并不是所有小数都可以精确的用二进制浮点数表示，二进制浮点数不能精确表示0.1，0.01，0.001这样10的负次幂。</li><li>float、double不适合在不容许舍入误差的金融计算领域，如果需要精确数字计算或保留指定位数的精度，需要使用<code>BigDecimal</code>类</li></ul></li><li>字符型：<ul><li>char ：2字节；Java中所有字符都使用Unicode编码；</li></ul></li><li>布尔型：<ul><li>boolean：4字节；只能是true和false，不能是0或1，与C语言不同</li><li>Java虚拟机中没有任何提供boolean值专用的字节码指示，在编译之后都使用java虚拟机中的int数据类型来代替，true用1表示，false用0表示</li></ul></li></ul></li><li>引用数据类型<ul><li>类 class</li><li>数组 array</li><li>接口 interface</li><li>枚举 enum</li><li>注解 annotation</li><li>记录 record</li></ul></li></ul></li><li>同一个作用域内不能声明两个同名的变量</li></ul><h3 id="运算规则">运算规则</h3><ul><li><p>boolean不能参与运算，只有其他7种可以做运算</p></li><li><p>运算规则</p><ul><li>自动类型提升</li><li>强制类型转换</li></ul></li><li><p>当容量小的变量与容量大的变量做运算时，结果自动转换为容量大的数据类型</p></li><li><p><code>byte和short</code>任意组合运算，结果是int类型</p></li><li><p>强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.234</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)num1;<br></code></pre></td></tr></table></figure><ul><li>强制类型转换可能会导致精度损失</li></ul></li></ul><h3 id="与string的运算">与String的运算</h3><ul><li>String是引用数据类型，可以使用<code>""</code>进行赋值</li><li>String与基本数据类型变量只能做连接运算，使用<code>+</code>表示</li><li>boolean参与运算也是把true或false直接进行拼接</li></ul><h3 id="底层存储方式">底层存储方式</h3><ul><li>进制<ul><li>二进制：以<code>0b</code>或<code>0B</code>开头</li><li>八进制：以数字<code>0</code>开头</li><li>十六进制：以<code>0x</code>或<code>0X</code>开头</li></ul></li><li>二进制<ul><li>二进制是由德国数理哲学大师莱布尼茨发明（就是微积分里面的那个人）</li></ul></li><li>进制转换<ul><li>二进制-&gt;十进制<ul><li>计算机存储使用<code>二进制补码</code>形式存储，并且最高位是符号位</li><li>正数：最高位是0</li><li>负数：最高位是1</li></ul></li><li>规定<ul><li>正数的补码与反码、原码一样，称为三码合一</li><li>负数的补码与反码、原码不一样<ul><li>负数的<code>原码</code>：把十进制转换为二进制，然后最高位设置为1</li><li>负数的<code>反码</code>：在原码基础上，最高位不变，其余位去反</li><li>负数的<code>补码</code>：反码 + 1</li></ul></li></ul></li></ul></li><li>二进制转八进制<ul><li>从低位到高位，每三个二进制看成一组，转换成八进制数</li></ul></li><li>二进制转十六进制<ul><li>从低位到高位，每四个二进制看成一组，转换成十六进制数</li></ul></li></ul><h2 id="运算符">运算符</h2><ul><li>按照功能分类：<ul><li>算数运算符：+，-，*，/，%，++，--</li><li>赋值运算符：=，+=，-=，*=，/=，%=，&gt;&gt;=，&lt;&lt;=，&gt;&gt;&gt;=，&amp;=，|=，^=等</li><li>比较（关系）运算符：&gt;，&gt;=，&lt;，&lt;=，==，!=，instanceof（检测是否是类的对象）</li><li>逻辑运算符：&amp;，|，^，!，&amp;&amp;，||</li><li>位运算符：&amp;，|，^，~，&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;</li><li>条件运算符：(条件表达式)?结果1:结果2</li><li>Lambda运算符：-&gt;（后面讲解）</li></ul></li><li>按照操作数个数分类<ul><li>一元运算符（单目运算符）</li><li>二元运算符（双目运算符）</li><li>三元运算符（三目运算符）</li></ul></li></ul><h1 id="流程控制语句">3 流程控制语句</h1><ul><li>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。</li><li>程序设计中规定的三种流程结构，即：<ul><li>顺序结构</li><li>分支结构<ul><li>if...else</li><li>switch-case</li></ul></li><li>循环结构<ul><li>for</li><li>while</li><li>do-while</li><li>JDK5.0提供了foreach循环，方便的遍历集合、数组元素</li></ul></li></ul></li></ul><h2 id="顺序结构">顺序结构</h2><ul><li>一般写的代码都是顺序结构，Java中定义变量时采用合法的前向引用</li></ul><h2 id="分支结构">分支结构</h2><ul><li>if...else</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">1</span>) &#123;<br>    语句块<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">2</span>) &#123;<br>    语句块<span class="hljs-number">2</span>;<br>&#125;<br>...<br><span class="hljs-keyword">else</span> &#123;<br>    语句块n;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>switch-case</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (表达式) &#123;<br>    <span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:<br>        语句块<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 常亮<span class="hljs-number">2</span>:<br>        语句块<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">default</span>:<br>        语句块n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>switch 中的表达式结果只能是 byte  short  char  int  枚举(JDK5.0新增) String(JDK7.0新增)</li></ul><h2 id="循环结构">循环结构</h2><ul><li><p>循环结构：在满足某些条件下，反复执行特定代码的功能</p></li><li><p>for</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> ( ; ; ) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>while</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> () &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>do-while：至少执行一次循环体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br><br>&#125; <span class="hljs-keyword">while</span> ();<br></code></pre></td></tr></table></figure></li><li><p>循环结构四要素</p><ul><li>初始化部分</li><li>循环条件部分</li><li>循环体部分</li><li>迭代部分</li></ul></li></ul><h2 id="scanner">Scanner</h2><ul><li><p>在Java中我们通过Scanner类获取键盘输入</p></li><li><p>步骤</p><ul><li>导包：<code>import java.utils.Scanner;</code></li><li>创建Scanner类型对象：<code>Scanner scan = new Scanner(System.in);</code></li><li>调用方法：<code>next() / nextXxx()</code><ul><li>next接收字符串</li><li>nextXxx接收其他基本类型</li></ul></li><li>释放资源：<code>scan.close();</code></li></ul></li><li><p>根据相应的方法来输入指定类型的值，如果输入的数据类型与要求的类型不匹配时，会报异常导致程序终止。</p></li><li><p>Scanner类中提供了byte  short  int  long  float  double  boolean String类型变量的方法，但是没有获取char类型的方法，可以通过接收String类型然后获取第一个字符的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> scan.next().charAt(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="随机数">随机数</h2><ul><li>Java中的lang包下有一个Math类，该类有一个random方法返回一个<spanclass="math inline">\([0.0,1.0)\)</span>范围内的double值</li><li>其他任何范围或精度都可以通过对其返回的double值进行放缩得到</li></ul><h2 id="breakcontinue">break&amp;continue</h2><ul><li>break：适用于switch-case结构、循环结构；结束<code>当前循环</code></li><li>continue：适用于循环结构；结束<code>当次循环</code></li></ul><h1 id="idea">4 IDEA</h1><ul><li>IDEA是JetBrains公司的产品，该公司总部位于捷克的布拉格。</li><li>分为两个版本</li></ul><h2 id="更改设置">更改设置</h2><ul><li>在<code>File-Project Structure</code>中可以进行JDK的切换</li><li>自动导包：在<code>File-Setting-Editor-General-Auto Import</code>中将<code>Add unambiguous import on the fly</code>和<code>Optimize imports on the fly</code>的两个勾选上</li><li>项目编码修改为UTF-8：<ul><li><figure><img src="更改项目编码格式.png" alt="更改项目编码格式" /><figcaption aria-hidden="true">更改项目编码格式</figcaption></figure></li></ul></li><li>设置自动编译<ul><li><figure><img src="设置自动编译.png" alt="设置自动编译" /><figcaption aria-hidden="true">设置自动编译</figcaption></figure></li></ul></li></ul><h2 id="工程与模块">工程与模块</h2><ul><li>层级关系：project - module - package - class</li><li>删除module步骤<ul><li>先右键选择Remove Module</li><li>再右键选择Delete</li></ul></li><li>Module迁移<ul><li>将Module复制到本项目与其他Module同级的路径下，然后打开ProjectSettings选择Module，Import该Module</li></ul></li><li>单独设置某一路径的编解码格式：Settings - Editor - FileEncodings，点击加号选择路径并选择格式即可</li></ul><h1 id="数组">5 数组</h1><ul><li><p>数组本身是引用数据类型，数组中的元素可以是任何数据类型，数组在内存中是一整块连续的空间</p></li><li><p>声明和初始化语句</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式1：数组初始化和赋值分开</span><br>元素类型[] 数组名 = <span class="hljs-keyword">new</span> 元素类型[n];<br><span class="hljs-comment">// 方式2：数组初始化和赋值同时</span><br>元素类型[] 数组名 = <span class="hljs-keyword">new</span> 元素类型[] &#123;元素<span class="hljs-number">1</span>, 元素<span class="hljs-number">2</span>, ... , 元素n&#125;;<br><span class="hljs-comment">// 方式2的省略，使用类型推断</span><br>元素类型[] 数组名 = &#123;元素<span class="hljs-number">1</span>, 元素<span class="hljs-number">2</span>, ... , 元素n&#125;;<br></code></pre></td></tr></table></figure></p><ul><li>一旦初始化后，长度就确定了，且不可更改</li></ul></li><li><p>长度：length属性获取数组长度</p></li><li><p>遍历：for循环</p></li><li><p>默认值</p><ul><li>整型：0</li><li>浮点型：0.0</li><li>字符型：0 / 000</li><li>布尔型：false</li><li>引用数据类型：null</li></ul></li></ul><h2 id="内存结构">内存结构</h2><ul><li>为了提高运算效率，Java虚拟机对空间进行了不同区域的划分，每一片区域都有特定的数据处理方式和内存管理方式</li><li>JVM由三个独立部分组成（<code>类运执</code>）<ul><li>类加载子系统</li><li>运行时数据区（<code>两栈堆区器</code>）<ul><li>虚拟机栈：存储正在执行的每个Java方法的局部变量表等。局部变量表存放了编译期可知长度的各种基本数据类型、对象引用、方法执行完、自动释放。</li><li>堆内存：存储对象（包括数组对象），new来创建的，都存储在堆内存</li><li>方法区：存储已被虚拟机加载的类信息、常量、（静态变量）、即时编译器编译后的代码等数据</li><li>本地方法栈：当程序中调用了native的本地方法时，本地方法执行期间的内存区域</li><li>程序计数器：是CPU中的寄存器，包含每一个线程下一条要执行的指令的地址</li></ul></li><li>执行引擎</li><li>图片解析<ul><li><img src="JVM组成.png" alt="JVM组成" style="zoom: 50%;" /></li></ul></li></ul></li><li>与数组有关的内存结构<ul><li>虚拟机栈：存放方法中声明的变量</li><li>堆：存放数组的实体（即数组中的所有元素）</li></ul></li></ul><h2 id="多维数组">多维数组</h2><ul><li><p>对于二维数组的理解，可以看做是一维数组又作为另一个一维数组的元素存在</p></li><li><p>从数组底层运行机制来看，其实没有多维数组</p></li><li><p>声明和初始化</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二维数组静态初始化</span><br>元素类型[][] 数组名称 = <span class="hljs-keyword">new</span> 元素类型[][]&#123;&#123;...&#125;,&#123;...&#125;,&#123;...&#125;&#125;;<br>元素类型[][] 数组名称 = &#123;&#123;...&#125;,&#123;...&#125;,&#123;...&#125;&#125;;<br><span class="hljs-comment">// 二维数组动态初始化</span><br>元素类型[][] 数组名称 = <span class="hljs-keyword">new</span> 元素类型[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br>元素类型[][] 数组名称 = <span class="hljs-keyword">new</span> 元素类型[<span class="hljs-number">2</span>][];<br></code></pre></td></tr></table></figure></p></li><li><p>调用.length方法获取长度，内层就调用该元素数组的.length</p></li><li><p>一旦声明了元素数组的长度，那么该元素存储的就是该元素数组的地址值，如果没有声明长度，那么就是null，结合上面动态初始化两种方式进行理解。</p></li><li><p>遍历</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums[i].length; j++) &#123;<br>        System.out.println(nums[i][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul><h2 id="数组常见算法">数组常见算法</h2><ul><li>数组元素反转</li><li>数组扩容</li><li>元素查找</li><li>数组排序</li></ul><h2 id="arrays工具类">Arrays工具类</h2><ul><li><p>java.utils.Arrays为操作数组的工具类，包含了用来操作数组的各方方法（比如排序或搜索）</p></li><li><p>常用操作</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断两个数组是否相等</span><br><span class="hljs-type">boolean</span> Arrays.equals(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b);<br><span class="hljs-comment">// 输出数组元素信息</span><br>String Arrays.toString(<span class="hljs-type">int</span>[] a);<br><span class="hljs-comment">// 将指定值填充到数组之中</span><br><span class="hljs-keyword">void</span> Arrays.fill(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> val);<br><span class="hljs-comment">// 快速排序</span><br><span class="hljs-keyword">void</span> Arrays.sort(<span class="hljs-type">int</span>[] a);<br><span class="hljs-comment">// 二分查找，数组必须有序</span><br><span class="hljs-keyword">void</span> Arrays.binarySearch(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> key);<br></code></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程OOP解析</title>
    <link href="/2024/03/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8BOOP%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/03/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8BOOP%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程-oop">面向对象编程 OOP</h1><h2 id="封装">封装</h2><h2 id="继承">继承</h2><h2 id="多态">多态</h2><ul><li>多态：父类指针/引用指向子类对象，从而在调用方法的时候，通过指向的子类对象的不同而调用不同的子类方法。</li><li>C++中的多态是通过继承和虚函数来实现的</li><li>Java中的多态是通过继承和接口来实现的</li></ul><h2 id="c">C++</h2><ol type="1"><li>继承就是允许派生类拥有调用基类中属性和方法的权利</li><li>成员函数可以分为三种：普通成员函数、虚函数、纯虚函数</li><li>虚函数表示希望子类重新实现，且父类中有对应的实现方式</li><li>纯虚函数表示要求子类一定要实现，且父类中没有对应的实现方式</li><li>为什么要把某些函数设成虚函数?：父类在定义函数时决定暂缓具体实现步骤,因为子类在设计时有更具体的,精细的想法,我作为父类的设计者允许子类去override, 通过把自己的函数设置成虚函数,子类才有机会(权限)去重新定义。</li><li>含有一个纯虚函数的类称为纯虚类，纯虚类不允许声明对象</li></ol><h2 id="java">Java</h2><ol type="1"><li>Java中的接口是一个类，可以简单的等效于C++的纯虚类</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>链接库指北</title>
    <link href="/2024/02/17/%E9%93%BE%E6%8E%A5%E5%BA%93%E6%8C%87%E5%8C%97/"/>
    <url>/2024/02/17/%E9%93%BE%E6%8E%A5%E5%BA%93%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识">基础知识</h1><p>为了实现代码的复用我们使用链接库的形式对代码进行封装，链接库是写好的现有的，成熟的，可以复用的代码。本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存中执行。</p><p>链接库有两种：静态库（.a、.lib）和动态库（.so、.dll）</p><p>在Linux中静态库文件后缀是.a，动态库文件后缀是.so</p><p>在Windows中静态库文件后缀是.lib，动态库文件后缀是.dll</p><p>编写的代码有以下三种分发方式：</p><ol type="1"><li>源码：头文件 + 源文件</li><li>动态库：头文件 + LIB文件 + DLL文件<ul><li>其中头文件和LIB文件是可选的</li></ul></li><li>静态库：头文件 + LIB文件</li></ol><h1 id="静态库">静态库</h1><p>之所以称为静态库，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</p><p>静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是<strong>一组目标文件（.o/.obj文件）的集合</strong>，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：</p><ul><li>静态库对函数库的链接是放在编译时期完成的。</li><li>程序在运行时与函数库再无瓜葛，移植方便。</li><li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li></ul><p>函数和数据被编译进一个二进制文件（通常扩展名为.LIB）。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其他模块组合起来创建最终的可执行文件（.EXE文件）。当发布产品时，只需要发布这个可执行文件，并不需要发布被使用的静态库。</p><h2 id="静态库的配置">静态库的配置</h2><p>静态库由头文件、LIB文件组成</p><p>使用方式有两种</p><p>第一种是最简单、比较偷懒、适合自己做练习的时候使用：</p><ol type="1"><li>直接include头文件的绝对地址</li><li>直接使用命令引用LIB文件，代码如下</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;LIB文件的绝对地址&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>第二种是使用Visual Studio进行配置：</p><ol type="1"><li><p>打开项目的属性页，配置属性 -&gt; C/C++ -&gt;附加包含目录，点击添加头文件所在的父路径，即配置好头文件的路径。</p></li><li><p>配置属性 -&gt; 链接器 -&gt; 常规 -&gt;附加库目录，点击添加LIB所在的父路径</p></li><li><p>配置属性 -&gt; 链接器 -&gt; 输入 -&gt;附加依赖项，添加LIB文件的全名，包含后缀</p></li></ol><p>注意配置的平台和版本要与程序中对应</p><p>然后在程序中包含该头文件即可使用该静态库中的导出项</p><h1 id="动态库">动态库</h1><p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，这样可以节省内存空间，在程序修改方面也更加方便，只需更新.dll文件即可。</p><p>以下以Windows系统中的DLL为例</p><h2 id="动态库的配置">动态库的配置</h2><p>动态库由头文件（可选）、LIB文件（可选）、DLL文件组成</p><p>具体配置过程为：</p><ul><li><p>头文件的配置</p><ul><li>属性页：配置属性 -&gt; C/C++ -&gt;附加包含目录，点击添加头文件所在的父路径</li></ul></li><li><p>LIB文件的配置</p><ul><li><p>属性页：配置属性-&gt;链接器-&gt;常规-&gt;附加库目录，点击添加LIB所在的父路径</p></li><li><p>属性页：配置属性-&gt;链接器-&gt;输入-&gt;附加依赖项，添加LIB文件的全名，包含后缀</p></li></ul></li><li><p>DLL文件的配置</p><ul><li>将生成的DLL文件复制到exe程序的当前目录中即可，也不一定放在一起，Windows有DLL的搜索路径，在那些路径下都是可以的</li></ul></li></ul><p>第三方动态库目录解析：</p><ul><li><p>build目录放着编译源码的相关文件</p></li><li><p>include目录放着头文件，后期写代码的时候要包含这个文件</p></li><li><p>lib目录放着生成的文件，编译后生成的LIB文件和DLL文件都会在这个目录中</p></li></ul><p>补充函数结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> 调用约定 Add(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br>    <span class="hljs-comment">//........</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用约定，顾名思义就是对函数调用的一个约束和规定(规范)，描述了函数参数是怎么传递和由谁清除堆栈的。它决定以下内容：</p><ol type="1"><li>函数参数的压栈顺序</li><li>由调用者还是被调用者把参数弹出栈</li><li>以及产生函数修饰名的方法</li></ol><p>常见的调用约定有：__stdcall, __cdecl, __fastcall,__thiscall，__thiscall一般是类的成员函数会用，在使用时我们不会声明成这样，所以一般用前三种。</p><p>在编写动态库时，就是在对函数、变量、类进行导出。</p><p>其中函数的导出方式有两种：</p><ol type="1"><li><p>def文件</p><ul><li><p>优点：通用性很好</p></li><li><p>缺点：导出比较麻烦</p></li></ul></li><li><p>__declspec(dllexport)</p><ul><li><p>优点：导出方式简单</p></li><li><p>缺点：通用性较差</p></li></ul></li></ol><p>如果打算给其他语言调用，导出函数的参数，返回值类型必须使用基本类型</p><ul><li><p>基本类型：int, char, double, char*, …</p></li><li><p>非基本类型：std::string, std::vector, …</p></li></ul><h2 id="动态库创建">动态库创建</h2><p>在VS中创建<code>具有导出项的DLL动态链接库</code>，创建完成后打开的是dllmain.cpp文件，这个是dll的主函数，暂时不用管，目前主要讲导出的方式</p><h3 id="declspecdllexport">__declspec(dllexport)</h3><p>在头文件中有一个与项目名称相同的.h头文件，将其打开，其中的代码是编辑器为我们生成的一个示例代码，其中包括类的导出，变量的导出，函数的导出。</p><p>将其中的类导出和变量导出删掉，写一个导出的加法函数进行练习，注意cpp文件中的也要删除</p><p>仿照函数的导出方式，写一个Add函数，输入两个int变量，返回两个数的和</p><p>生成该项目，成功后即完成了两个函数的导出，一个是Add函数，一个是自带的函数</p><p>此时将dll文件和生成的exe文件一起打包即可运行，运行程序代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../ExportDLL/ExportDLL.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;D:\\Desktop\\bilibiliDLLTest\\ExportDLL\\x64\\Debug\\ExportDLL.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-built_in">Add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;Pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="def文件">def文件</h3><p>首先将上一步中函数前面添加的宏去掉，恢复成最普通的代码格式</p><p>然后在DLL项目中右键 -&gt; 添加新建项 -&gt; Visual C++ -&gt; 代码-&gt; 模块定义文件</p><p>在创建的文件的LIBRARY关键字后面写上库的名字，文件内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LIBRARY ExportDLL<br>EXPORTS<br>Add<br></code></pre></td></tr></table></figure><p>正常使用即可</p><p>但是推荐使用__declspec(dllexport)进行导出，方便简洁</p><h3 id="c语言调用">C语言调用</h3><p>如果把调用的文件由cpp变成c时，是无法调用的，需要在编写dll时对宏进行处理一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>以上代码的含义是，将Add以C语言的方式来解析函数</p><p>此时重新生成调用也可成功，将后缀由c变成cpp也是成功的</p><h3 id="其他语言调用">其他语言调用</h3><p>若是要将dll生成给C或CPP调用时，使用__declspec(dllexport)方式比较方便</p><p>如果要把代码给Java、JavaScript、C#等语言调用时，__declspec(dllexport)方法就不会那么方便，下面我们将以C#进行说明</p><p>先将def文件的依赖去掉，将ExportDLL属性页 -&gt; 配置属性 -&gt; 链接器-&gt; 所有选项 -&gt;模块定义文件中的Source.def删除，然后添加__declspec(dllexport)</p><h3 id="c调用">C#调用</h3><p>我们在创建dll工程的时候，编写的函数都没有显示指出调用约定，在属性页中进行设置，C/C++-&gt;所有选项-&gt;调用约定，VS中默认的是__cdecl(/Gd)，</p><p>创建一个控制台应用(.NET Framework)，名称为UseDLL_CSharp</p><p>将属性 -&gt; 生成 -&gt; 生成路径修改为 -&gt; ..\Debug\</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Runtime.InteropServices;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">UseDLL_CSharp</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;ExportDLL.dll&quot;</span>, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> a = Add(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>);<br>            Console.WriteLine(a);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果将DLL工程中调用约定写成__stdcall，就会出现找不到入口点的问题，原因在于dllexport虽然可以很方便的对函数进行导出，但是导出是由当前版本的编译器决定的，会对函数进行一系列的修饰，无法管理该修饰，如果使用def的方式就会好很多</p><p>所以如果希望对除C和C++以外的语言调用时，最好使用def的格式导出</p><h1 id="疑难杂症">疑难杂症</h1><h2 id="c向dll传递数据">C#向DLL传递数据</h2><h3 id="字符串类型的数据传输">字符串类型的数据传输</h3><p>C#：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 声明</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span>[] path</span>)</span>;<br><span class="hljs-comment">// 调用</span><br>livoxLidarInit(Encoding.Default.GetBytes(path));<br></code></pre></td></tr></table></figure><p>DLL：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span>;<br></code></pre></td></tr></table></figure><h2 id="dll向c传递数据">DLL向C#传递数据</h2><p>在开发过程中，除了C#主动调用DLL中的函数外，还有种情况是DLL向C#传递数据，此时需要使用函数指针，委托等工具进行设置。</p><p>基本逻辑为，将C#中编写的函数指针传递给DLL中，在DLL中调用函数指针就是在调用C#中的函数，从而完成DLL向C#的数据传递。</p><h3 id="c端">C#端</h3><ol type="1"><li>首先声明回调函数代理</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallbackDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span>;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>从DLL中引入设置回调函数的函数</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;LivoxLidar.dll&quot;</span>, CallingConvention = CallingConvention.StdCall)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetCallback</span>(<span class="hljs-params">CallbackDelegate callback</span>)</span>;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>编写回调函数</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyCallback</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span><br>&#123;<br>Console.WriteLine(a);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>设置回调函数</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">SetCallback(MyCallback);<br></code></pre></td></tr></table></figure><h3 id="c-dll端">C++ DLL端：</h3><ol type="1"><li>声明函数指针类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*CallbackFunc)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>设置函数指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> CallbackFunc g_callback = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>编写设置回调函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetCallback</span><span class="hljs-params">(CallbackFunc callback)</span> </span>&#123;<br>g_callback = callback;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>记得将设置回调函数向外导出</p></blockquote><ol start="4" type="1"><li>在合适位置调用该函数指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (g_callback != <span class="hljs-literal">nullptr</span>) &#123;<br><span class="hljs-built_in">g_callback</span>(<span class="hljs-number">123</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/CPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>CPP</tag>
      
      <tag>链接库</tag>
      
      <tag>动态链接库</tag>
      
      <tag>静态链接库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenTK入门</title>
    <link href="/2024/01/31/OpenTK%E5%85%A5%E9%97%A8/"/>
    <url>/2024/01/31/OpenTK%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍">介绍</h1><ul><li>官网：<a href="https://opentk.net/">OpenTK - OpenTK</a></li><li>官方文档：<a href="https://opentk.net/learn/index.html">LearnOpenTK- OpenTK</a></li><li>以下内容，采用版本为<strong>OpenTK 4.x</strong></li><li>出于在C#中使用OpenGL的需求，发现一个封装库OpenTK，以下为该封装库在Winform开发中的使用过程</li></ul><h1 id="下载">下载</h1><ul><li>在NuGet包管理器中下载<code>OpenTK</code>和<code>OpenTK.WinForms</code></li></ul><h1 id="入门使用">入门使用</h1><ul><li><p>在工具箱中将<code>GLControl</code>控件拖入窗口，即可在窗口中添加渲染组件。</p></li><li><p>在程序上方引入包：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br></code></pre></td></tr></table></figure></li></ul><h2 id="渲染管线">渲染管线</h2><figure><img src="pipeline.png" alt="Pipeline graph" /><figcaption aria-hidden="true">Pipeline graph</figcaption></figure><ul><li>VERTEX DATA[]：顶点数据</li><li>VERTEXSHADER：将顶点移动到其位置。这是应用模型位置等操作的阶段。</li><li>SHAPEASSEMBLY：OpenGL通过将顶点组合成三角形来工作；这个阶段就是实现这个过程的阶段。</li><li>GEOMETRYSHADER：一个可选的阶段。允许你对形状组装的结果进行微调。</li><li>RASTERIZATION：将三角形转换为片段的过程。</li><li>FRAGMENTSHADER：修改片段以包括颜色数据等内容。这是应用纹理和光照等操作的阶段。</li><li>TESTS ANDBLENDING：片段着色器的结果与场景的其他部分集成的阶段。</li></ul><p>蓝色背景的部分是可编程的，灰色背景的部分是可以使用功能进行轻微自定义</p><h2 id="流程">流程</h2><h3 id="函数介绍">函数介绍</h3><p>在<code>glControl1_Load</code>函数中添加如下代码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GL</span>.ClearColor(<span class="hljs-number">0</span>.<span class="hljs-number">2</span>f, <span class="hljs-number">0</span>.<span class="hljs-number">3</span>f, <span class="hljs-number">0</span>.<span class="hljs-number">3</span>f, <span class="hljs-number">1</span>.<span class="hljs-number">0</span>f);<br></code></pre></td></tr></table></figure><p>该函数是控件第一次加载的函数，任何与初始化有关的函数都应该放在<code>glControl1_Load</code>中间。</p><p><code>GL.ClearColor</code>接收四个0~1的浮点数，用于决定窗口在帧之间清除后的颜色。</p><hr /><p>在<code>glControl1_Paint</code>函数中添加如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.Clear(ClearBufferMask.ColorBufferBit);<br><span class="hljs-comment">//Code goes here.</span><br>glControl1.SwapBuffers();<br></code></pre></td></tr></table></figure><p>该函数是控件的绘制代码</p><p>GL.Clear清除了屏幕，并且使用GL.ClearColor设置的对应颜色刷新屏幕</p><p>Code goes here.为渲染代码</p><p>几乎任何现代 OpenGL都是所谓的“双缓冲”，先绘制绘制完成后再交换缓冲区</p><hr /><p>在<code>glControl1_SizeChanged</code>函数中添加如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br></code></pre></td></tr></table></figure><p>该函数是用于尺寸变更时重新设置视角</p><h3 id="顶点输入">顶点输入</h3><p>OpenGL是一个3D图形库，因此我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z坐标）。并且OpenGL仅在（x、y和z）处于-1.0到1.0之间的特定范围内时才处理3D 坐标</p><p>以下是一个简单的顶点坐标示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">float</span>[] vertices = &#123;<br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">//Bottom-left vertex</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">//Bottom-right vertex</span><br>     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>  <span class="hljs-comment">//Top vertex</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="归一化设备坐标">归一化设备坐标</h3><ul><li>Normalized Device Coordinates (NDC)</li><li>在顶点着色器中处理顶点坐标后，它们应位于归一化设备坐标中，这是一个小空间，其中x、y 和 z 值从 -1.0 到 1.0不等。任何超出此范围的坐标都将被丢弃/裁剪，并且在屏幕上不可见。</li><li>与普通的屏幕坐标系不同，坐标系如下图所示</li></ul><p><img src="2-ndc.png" /></p><h3 id="缓冲区">缓冲区</h3><p>在上面定义完顶点数据后，我们需要进行渲染管线的第一步，顶点着色器。我们需要完成以下任务：在GPU上创建内存；配置OpenGL如何解释内存；指定如何将数据发送到GPU。完成以上设置后，顶点着色器会处理我们提供给它的任意数量的顶点</p><p>我们通过顶点缓冲区对象（VBO）来管理这些内存，该对象可以在 GPU的内存中存储大量顶点。使用这些缓冲区对象的优点是，我们可以一次将大批量数据发送到显卡，而不必一次发送一个顶点的数据。从CPU向显卡发送数据相对较慢，因此只要有可能，我们都会尝试一次发送尽可能多的数据。一旦数据进入显卡的内存中，顶点着色器几乎可以立即访问顶点，使其速度非常快。</p><p>顶点缓冲区对象有一个与该缓冲区对应的唯一ID，因此我们可以使用<code>GL.GenBuffers</code>生成一个缓冲器并返回该缓冲区的ID。</p><p>在<code>glControl1_Load</code>函数中添加如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> VertexBufferObject;<br>VertexBufferObject = GL.GenBuffer();<br></code></pre></td></tr></table></figure><p>OpenGL有多种类型的缓冲区对象，顶点缓冲区对象的缓冲区类型为<code>BufferTarget.ArrayBuffer</code>，balabalabala</p><p>我们可以使用<code>GL.BindBuffer</code>函数将新创建的缓冲区绑定到<code>BufferTarget.ArrayBuffer</code>类型上，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br></code></pre></td></tr></table></figure><p>绑定完成后，我们可以通过<code>GL.BufferData</code>函数向缓冲区中放入之前定义的顶点数据：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br></code></pre></td></tr></table></figure><ul><li><p>该函数用于将顶点数据放入缓冲区</p></li><li><p>第一个参数为要赋值到缓冲区的类型</p></li><li><p>第二个参数是传递给缓冲区的对象大小，以字节为单位</p></li><li><p>第三个参数是发送的实际数据</p></li><li><p>第四个参数是<code>BufferUsageHint</code>，用于指示显卡如何管理给定数据</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">StaticDraw：数据很可能根本不会改变或很少改变。<br>DynamicDraw：数据可能会发生很大变化。<br>StreamDraw：每次绘制数据时都会发生变化。<br></code></pre></td></tr></table></figure></li></ul><p>程序结束时会释放所有资源，但是如何出于某种原因需要手动释放缓冲区，可以调用如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.BindBuffer(BufferTarget.ArrayBuffer, <span class="hljs-number">0</span>);<br>GL.DeleteBuffer(VertexBufferObject);<br></code></pre></td></tr></table></figure><p>以上，我们完成了将顶点数据存储在显卡的内存中，由名为VBO的顶点缓冲区对象管理。接下来，我们要创建一个顶点和片段着色器来实际处理这些数据。</p><h3 id="着色器">着色器</h3><p>如果我们想做一些渲染，OpenGL要求我们至少设置一个顶点和片段着色器。</p><p>我们需要做的第一件事是用着色器语言GLSL（OpenGL着色语言）编写顶点着色器，然后编译这个着色器，以便我们可以在我们的应用程序中使用它。下面是GLSL 中一个非常基本的顶点着色器的源代码：</p><p>顶点着色器代码：shader.vert</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>GLSL看起来类似于C。每个着色器都以声明其版本开头。从OpenGL3.3及更高版本开始，GLSL的版本号与OpenGL的版本匹配（例如，GLSL版本420对应于OpenGL版本4.2）。</p><p>接下来，在顶点着色器中用关键字<code>in</code>声明所有输入顶点属性。目前我们只关心位置数据，因此我们只需要一个顶点属性。GLSL具有矢量数据类型，根据其后缀数字包含1到4个浮点数。由于每个顶点都有一个3D坐标，我们使用名称<code>aPosition</code>创建一个<code>vec3</code>输入变量。我们还通过<code>layout(location = 0)</code>明确设置了输入变量的位置，稍后你会看到我们为什么需要这个位置。</p><p>每个着色器的入口点是<code>void main()</code>函数。这是你可以进行任何处理的地方。然而，在这里，我们只是将输入数据分配给了<code>gl_Position</code>，这是顶点着色器的内置变量，表示该顶点的最终位置。然而，<code>gl_Position</code>是一个<code>vec4</code>，但我们的输入顶点是<code>vec3</code>。为此，我们使用<code>vec4</code>函数使向量变得足够长。</p><p>当前的顶点着色器可能是我们能想象的最简单的顶点着色器，因为我们对输入数据没有进行任何处理，只是将其转发到着色器的输出。在实际应用中，输入数据通常不是已经在标准化设备坐标中，因此我们首先必须将输入数据转换为在OpenGL可见区域内的坐标。</p></blockquote><p>片段着色器代码：shader.frag</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> vec4 FragColor;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    FragColor = vec4(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.2f</span>, <span class="hljs-number">1.0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>片段着色器是我们将为渲染三角形创建的第二个也是最后一个着色器。片段着色器主要是关于计算像素的颜色输出。为了保持简单，片段着色器将始终输出一种橙色。</p><p>在计算机图形中，颜色表示为一个包含4个值的向量：红色、绿色、蓝色和alpha（不透明度）分量，通常缩写为RGBA。在OpenGL或GLSL中定义颜色时，我们将每个分量的强度设置为介于0.0和1.0之间的值。例如，如果我们将红色设置为1.0f并将绿色设置为1.0f，我们将获得混合了两种颜色并得到黄色的颜色。给定这三个颜色分量，我们可以生成超过1600万种不同的颜色！</p><p>片段着色器只需要一个输出变量，那就是一个大小为4的向量，定义了我们自己要计算的最终颜色输出。我们可以使用关键字<code>out</code>声明输出值，这里我们迅速命名为<code>FragColor</code>。接下来，我们只需将一个<code>vec4</code>分配给颜色输出，作为橙色，并且alpha值为1.0（1.0表示完全不透明）。</p></blockquote><h3 id="编译着色器">编译着色器</h3><p>有了着色器源代码，现在需要编译着色器。这是在运行时完成的；预先编译着色器并将其与程序打包在一起是不可能的，因为编译后的着色器取决于许多因素，比如显卡型号、制造商和驱动程序。相反，我们在程序开始时包含着色器源代码并对其进行编译。</p><p>我们将通过创建一个Shader类来实现这一点，该类编译着色器并封装了我们稍后将看到的几个函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shader</span><br>&#123;<br>    <span class="hljs-built_in">int</span> Handle;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shader</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> vertexPath, <span class="hljs-built_in">string</span> fragmentPath</span>)</span><br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在构造函数中，handle将代表着我们最终着色器程序编译完成后的位置。我们将在构造函数中进行所有初始化工作。</p><p>首先，在构造函数中定义两个整数：VertexShader和FragmentShader。这些是各个着色器的句柄。它们在构造函数中定义，因为在完整的着色器程序完成后，我们不再需要各个着色器。</p><p>接下来，我们需要从各个着色器文件中加载源代码。我们可以这样做：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> VertexShaderSource = File.ReadAllText(vertexPath);<br><span class="hljs-built_in">string</span> FragmentShaderSource = File.ReadAllText(fragmentPath);<br></code></pre></td></tr></table></figure><p>然后，我们生成我们的着色器，并将源代码绑定到着色器上。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">VertexShader = GL.CreateShader(ShaderType.VertexShader);<br>GL.ShaderSource(VertexShader, VertexShaderSource);<br><br>FragmentShader = GL.CreateShader(ShaderType.FragmentShader);<br>GL.ShaderSource(FragmentShader, FragmentShaderSource);<br></code></pre></td></tr></table></figure><p>接下来，我们编译着色器并检查是否有错误。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.CompileShader(VertexShader);<br><br>GL.GetShader(VertexShader, ShaderParameter.CompileStatus, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> success);<br><span class="hljs-keyword">if</span> (success == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">string</span> infoLog = GL.GetShaderInfoLog(VertexShader);<br>    Console.WriteLine(infoLog);<br>&#125;<br><br>GL.CompileShader(FragmentShader);<br><br>GL.GetShader(FragmentShader, ShaderParameter.CompileStatus, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> success);<br><span class="hljs-keyword">if</span> (success == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">string</span> infoLog = GL.GetShaderInfoLog(FragmentShader);<br>    Console.WriteLine(infoLog);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在编译过程中出现任何错误，您可以使用函数GL.GetShaderInfoLog获取调试字符串。假设没有问题，我们可以继续链接。</p><p>我们的各个着色器已经编译完成，但要实际使用它们，我们必须将它们链接到一个可以在GPU上运行的程序中。这就是我们从现在开始谈论“着色器”时所指的内容。我们可以这样做：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#">Handle = GL.CreateProgram();<br><br>GL.AttachShader(Handle, VertexShader);<br>GL.AttachShader(Handle, FragmentShader);<br><br>GL.LinkProgram(Handle);<br><br>GL.GetProgram(Handle, GetProgramParameterName.LinkStatus, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> success);<br><span class="hljs-keyword">if</span> (success == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">string</span> infoLog = GL.GetProgramInfoLog(Handle);<br>    Console.WriteLine(infoLog);<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是全部了！现在，handle是一个可用的着色器程序。</p><p>在离开构造函数之前，我们应该进行一些清理工作。现在，各个顶点和片段着色器已经被链接后就变得无用了；当你链接时，编译的数据被复制到着色器程序中。你也不需要将这些单独的着色器附加到程序中；让我们将它们分离然后删除它们。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">GL.DetachShader(Handle, VertexShader);<br>GL.DetachShader(Handle, FragmentShader);<br>GL.DeleteShader(FragmentShader);<br>GL.DeleteShader(VertexShader);<br></code></pre></td></tr></table></figure><p>现在我们有一个有效的着色器，所以让我们添加一种使用它的方法。将以下函数添加到Shader类中：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span><br>&#123;<br>    GL.UseProgram(Handle);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们需要在这个类被销毁后清理handle。我们不能在终结器中这样做，因为面向对象语言的问题。相反，我们必须从IDisposable派生，并记得手动调用Dispose来释放我们的着色器。在你的其余代码下面，添加以下内容：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> disposedValue = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> disposing</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!disposedValue)<br>    &#123;<br>        GL.DeleteProgram(Handle);<br><br>        disposedValue = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br>~Shader()<br>&#123;<br>    <span class="hljs-keyword">if</span> (disposedValue == <span class="hljs-literal">false</span>)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;GPU Resource leak! Did you forget to call Dispose()?&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>&#123;<br>    Dispose(<span class="hljs-literal">true</span>);<br>    GC.SuppressFinalize(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>恭喜！我们现在有了一个功能完备的着色器类。</p><p>在你的窗口类中，添加一个新的属性，Shadershader;。然后，在glControl1_Load中，添加一行shader = newShader("shader.vert","shader.frag");。<code>接着，转到OnUnload，并添加一行shader.Dispose();。？？</code></p><p>尝试运行；如果控制台没有输出任何内容，那么你的着色器已经成功编译了！</p><h3 id="链接顶点属性">链接顶点属性</h3><p>顶点着色器允许我们以顶点属性的形式指定任何输入。虽然这提供了很大的灵活性，但这意味着我们必须手动指定输入数据的哪一部分传递给顶点着色器中的哪个顶点属性。这意味着我们必须在渲染之前指定OpenGL应该如何解释顶点数据。</p><p>这种格式信息存储在所谓的顶点数组对象（VAO）中。VAO包含有关顶点格式以及要从哪些缓冲区读取的信息。我们稍后将更详细地讨论这一点，但首先我们创建一个VAO并绑定它，如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> VertexArrayObject = GL.GenVertexArray();<br>GL.BindVertexArray(VertexArrayObject);<br></code></pre></td></tr></table></figure><p>我们创建并绑定了VAO后，可以开始指定顶点格式和数据缓冲区。为此，首先需要查看我们顶点缓冲区的格式。</p><p>我们的顶点缓冲区数据格式如下：</p><p><img src="2-vertex_attribute_pointer.png" /></p><ul><li>位置数据存储为32位（4字节）浮点值。</li><li>每个位置由其中的3个值组成。</li><li>每组3个值之间没有空格（或其他值）。这些值在数组中紧密地排列。</li><li>数据中的第一个值位于缓冲区的开头。</li></ul><p>有了这些知识，我们可以告诉OpenGL如何解释顶点数据（每个顶点属性），使用GL.VertexAttribPointer：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>GL.VertexAttribPointer函数具有许多参数，让我们仔细地逐个讨论它们：</p><ul><li>第一个参数指定了我们要配置的顶点属性。记住，我们在顶点着色器中使用了layout(location=0)来指定位置顶点属性的位置。这将位置顶点属性的位置设置为0，因此我们传入0。</li><li>接下来的参数指定了顶点属性的大小。位置顶点属性是一个vec3，因此由3个值组成。</li><li>第三个参数指定了数据的类型，这里是浮点数（在GLSL中，vec*由浮点值组成）。</li><li>接下来的参数指定了是否希望数据被标准化。如果我们输入整数数据类型（int、byte），并将其设置为true，那么整数数据在转换为浮点数时会被标准化为0（或对于有符号数据为-1）和1。对我们来说，这并不相关，所以我们将其保持为false。</li><li>第五个参数被称为步长（stride），告诉我们相邻顶点属性之间的间隔空间。由于下一组位置数据恰好位于比一个浮点数大3倍的位置，我们将该值指定为步长。请注意，由于我们知道数组是紧密打包的（下一个顶点属性值之间没有空间），我们也可以将步长指定为0，让OpenGL确定步长（这仅在值紧密打包时有效）。每当我们有更多的顶点属性时，我们都必须仔细定义每个顶点属性之间的间隔，但我们稍后会看到更多的例子。</li><li>最后一个参数是位置数据在缓冲区中开始的偏移量。由于位置数据位于数据数组的开头，这个值就是0。我们将在后面更详细地探讨这个参数。</li></ul><p>每个顶点属性从由VBO管理的内存中获取其数据，它从哪个VBO获取数据（您可以有多个VBO）是由在调用GL.VertexAttribPointer时绑定到ArrayBuffer的VBO决定的。由于在调用glVertexAttribPointer之前，先前定义的VBO仍然绑定，因此顶点属性0现在与其顶点数据关联起来了。</p><p>现在我们已经指定了OpenGL应该如何解释顶点数据，我们还应该使用GL.EnableVertexAttribArray启用顶点属性，将顶点属性的位置作为其参数；顶点属性默认是禁用的。</p><p>从那时起，我们已经准备就绪：我们使用顶点缓冲对象初始化了缓冲区中的顶点数据，设置了顶点和片段着色器，并告诉OpenGL如何将顶点数据链接到顶点着色器的顶点属性。在OpenGL中绘制对象现在看起来会像这样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><br>GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>shader.Use()<br><span class="hljs-comment">// 3. now draw the object</span><br>someOpenGLFunctionThatDrawsOurTriangle();<br></code></pre></td></tr></table></figure><p>每次我们想要绘制一个对象时，我们都必须重复这个过程。这可能看起来不是很多，但想象一下，如果我们有五个或更多的顶点属性，以及可能有数百个不同的对象（这并不罕见）。为每个对象绑定适当的缓冲对象并配置所有顶点属性很快就会变得繁琐起来。如果有一种方法可以将所有这些状态配置存储到一个对象中，并简单地绑定该对象来恢复其状态呢？</p><h3 id="顶点数组对象">顶点数组对象</h3><p>顶点数组对象（Vertex ArrayObject，也称为VAO）可以像顶点缓冲对象一样绑定，从那时起，任何后续的顶点属性调用都将存储在VAO中。这样做的好处是，当配置顶点属性指针时，您只需要进行一次调用，每当我们想要绘制对象时，我们只需绑定相应的VAO。这使得在不同的顶点数据和属性配置之间切换就像绑定不同的VAO一样简单。我们刚刚设置的所有状态都存储在VAO中。</p><p>核心OpenGL要求我们使用VAO，这样它才知道如何处理我们的顶点输入。如果我们没有绑定VAO，OpenGL很可能会拒绝绘制任何东西。</p><p>顶点数组对象存储以下内容：</p><ul><li>GL.EnableVertexAttribArray或GL.DisableVertexAttribArray的调用。</li><li>通过GL.VertexAttribPointer进行的顶点属性配置。</li><li>通过GL.VertexAttribPointer调用与顶点属性相关联的顶点缓冲对象。</li></ul><p><img src="2-vertex_array_objects.png" /></p><p>要生成一个VAO的过程与生成VBO的过程相似。作为一个属性，添加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> VertexArrayObject;<br></code></pre></td></tr></table></figure><p>然后，在OnLoad中，在调用GL.BindVertexArray之前，添加：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">VertexArrayObject = GL.GenVertexArray();<br></code></pre></td></tr></table></figure><p>要使用VAO，你只需要绑定VAO使用GL.BindVertexArray。从那时起，我们应该绑定/配置相应的VBO(s)和属性指针，并且然后解绑VAO以便以后使用。只要我们想要绘制一个对象，我们只需在绘制对象之前简单地绑定带有所需设置的VAO，然后绘制对象，就这样。在代码中，这看起来会像这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// ..:: 初始化代码（只需一次（除非你的对象经常变化））:: ..</span><br><span class="hljs-comment">// 1. 绑定顶点数组对象</span><br>GL.BindVertexArray(VertexArrayObject);<br><span class="hljs-comment">// 2. 将我们的顶点数组复制到OpenGL要使用的缓冲区中</span><br>GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><span class="hljs-comment">// 3. 然后设置我们的顶点属性指针</span><br>GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>然后，要实际绘制对象，你可以在渲染循环中放置以下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.UseProgram();<br>GL.BindVertexArray(VertexArrayObject);<br>someOpenGLFunctionThatDrawsOurTriangle();<br></code></pre></td></tr></table></figure><p>这就是全部！我们在过去几百万页中所做的一切都导致了这一刻，一个存储了我们的顶点属性配置和使用哪个VBO的VAO。通常，当你有多个对象要绘制时，你首先生成/配置所有的VAO（因此也生成/配置了所需的VBO和属性指针），然后存储它们以供以后使用。当我们想要绘制我们的对象之一时，我们取相应的VAO，绑定它，然后绘制对象，再次解绑VAO。</p><p>为了绘制我们选择的对象，OpenGL为我们提供了GL.DrawArrays函数，它使用当前激活的着色器、先前定义的顶点属性配置以及VBO的顶点数据（通过VAO间接绑定）来绘制图元。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">shader.Use();<br>GL.BindVertexArray(VertexArrayObject);<br>GL.DrawArrays(PrimitiveType.Triangles, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>GL.DrawArrays函数的第一个参数是我们想要绘制的OpenGL图元类型。由于我在开头说过我们想要绘制一个三角形，而我不喜欢欺骗你，我们传入PrimitiveType.Triangles。第二个参数指定了我们想要绘制的顶点数组的起始索引；因为我们想要绘制所有的顶点，所以我们将其留在0。最后一个参数指定了我们想要绘制的顶点数量，这是3（我们只从我们的数据中渲染一个三角形，它恰好是3个顶点长）。</p><p>现在尝试编译代码，如果出现任何错误，请从错误开始逆向操作。当你的应用程序编译成功后，你应该会看到以下结果。</p><p><img src="hellotriangle.png" /></p><h3 id="补充说明动态检索着色器布局">补充说明：动态检索着色器布局</h3><p>在这个例子中，当我们调用GL.VertexAttribPointer时，我们为变量的位置使用了硬编码的布局0。这仅适用于我们在shader.vert中显式将布局设置为0的情况。但是，如果你不想这样做呢？如果你愿意，你可以在运行时检索位置。</p><p>如果你想这样做，可以在你的Shader类中添加以下函数。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">csharpCopy codepublic <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetAttribLocation</span><span class="hljs-params">(string attribName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> GL.<span class="hljs-title">GetAttribLocation</span><span class="hljs-params">(Handle, attribName)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在设置VAO时，你可以使用shader.GetAttribLocation("aPosition")代替0。如果你这样做，你就不必再在着色器中包含layout(location=0)这一行了。</p><p>本教程将坚持使用硬编码的值，但重要的是要知道两种方法都可以实现。</p><hr /><p>以上就是OpenTK的绘制三角形的简单的入门使用</p><h1 id="进阶使用">进阶使用</h1><h2 id="元素缓冲区对象">元素缓冲区对象</h2><p>我们已经渲染了我们的第一个三角形，但是如果我们想做一些更复杂的事情呢？比如说，一个矩形？</p><p>OpenGL专门使用三角形进行渲染。它对正方形和其他形状有部分支持，但是这些功能已经被废弃很长时间了，不应该使用。你可以通过定义六个顶点来制作两个看起来像一个形状的三角形，但是这样做会浪费，因为一个矩形只需要四个顶点。虽然这可能看起来不是很糟糕，但是考虑一个立方体：如果没有浪费，只需要八个顶点，但是如果你使用每个面由两个三角形组成的方法，那么单个立方体就需要36个顶点！随着模型变得更复杂，数字只会变得更糟；显然，需要一种更好的方法。</p><p>有很多不同的方法可以做到这一点（比如三角带），但是在本教程中，我们将使用称为元素缓冲对象的东西，它是一种允许我们重复使用顶点来创建多个图元的缓冲区类型。使用EBO，我们将能够仅使用四个顶点创建一个矩形。</p><p>用以下内容替换你的顶点数组：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">float</span>[] vertices = &#123;<br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右上角</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下角</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 左下角</span><br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">// 左上角</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>然后，在下面，添加以下数组：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">uint</span>[] indices = &#123;  <span class="hljs-comment">// 注意我们从0开始！</span><br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,   <span class="hljs-comment">// 第一个三角形</span><br>    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    <span class="hljs-comment">// 第二个三角形</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>索引数组将被提供给我们的EBO，以指定哪些顶点将用于创建三角形。这个数组将使用顶点0、1和3创建一个三角形，使用顶点1、2和3创建第二个三角形。</p><p>接下来，在属性下面，添加以下行：int ElementBufferObject。</p><p>现在，在OnLoad中，在初始化VertexBufferObject的地方下面，我们以类似的方式初始化ElementBufferObject：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">ElementBufferObject = GL.GenBuffer();<br>GL.BindBuffer(BufferTarget.ElementArrayBuffer, ElementBufferObject);<br>GL.BufferData(BufferTarget.ElementArrayBuffer, indices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">uint</span>), indices, BufferUsageHint.StaticDraw);<br></code></pre></td></tr></table></figure><blockquote><p>警告：绑定元素数组缓冲区是特殊的，只有在当前绑定了VAO时才能绑定。从概念上讲，它可以被认为是VAO拥有绑定槽。如果解绑VAO，则元素数组缓冲区仍然绑定到VAO！</p></blockquote><p>这几乎和使用VBO的方式完全一样！大多数OpenGL的缓冲区类型都会遵循这种模式：使用GL.GenBuffer()创建，使用GL.BindBuffer进行绑定，然后使用GL.BufferData添加数据。</p><p>现在，EBO已经准备好了。在OnRenderFrame中，用以下内容替换DrawArrays的调用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>这些参数依次是：</p><p>图元类型。和上次一样，我们想要使用原始的三角形。要绘制的顶点数。我们使用索引的长度来绘制所有内容。EBO元素的类型。无符号整型。我们要绘制的偏移量。因为我们想要绘制所有内容，所以我们只使用0。</p><p>就是这样！现在如果运行你的程序，你应该能够看到你有一个矩形，而不是一个三角形。</p><h2 id="着色器-1">着色器</h2><p>如在入门使用章节中所述，着色器是在GPU上运行的小程序。这些程序针对图形管线的每个特定部分运行。从基本意义上讲，着色器不过是将输入转换为输出的程序。着色器也是非常隔离的程序，它们不允许彼此通信；它们之间唯一的通信方式是通过它们的输入和输出。</p><p>在前一章中，我们简要介绍了着色器及其如何正确使用。现在我们将以更一般的方式解释着色器，特别是OpenGL着色语言。</p><h3 id="glslopengl着色语言">GLSL（OpenGL着色语言）</h3><p>着色器是用类似C的语言GLSL编写的。GLSL专门用于图形处理，并包含针对向量和矩阵操作的有用特性。</p><p>着色器总是以版本声明开头，然后是一系列的输入和输出变量、uniform变量以及它的主函数。每个着色器的入口点都在它的主函数中，在那里我们处理任何输入变量并将结果输出到它的输出变量中。如果你不知道uniform是什么，不用担心，我们马上就会讲到。</p><p>一个着色器通常具有以下结构：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version version_number</span><br><span class="hljs-keyword">in</span> type in_variable_name;<br><span class="hljs-keyword">in</span> type in_variable_name;<br><br><span class="hljs-keyword">out</span> type out_variable_name;<br><br><span class="hljs-keyword">uniform</span> type uniform_name;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>  <span class="hljs-comment">// 处理输入并进行一些奇怪的图形处理</span><br>  ...<br>  <span class="hljs-comment">// 将处理后的内容输出到输出变量</span><br>  out_variable_name = weird_stuff_we_processed;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们特别谈论顶点着色器时，每个输入变量也被称为顶点属性。我们可以声明的顶点属性数量受到硬件限制。OpenGL保证至少有16个4分量的顶点属性可用，但一些硬件可能允许更多，您可以通过查询GL_MAX_VERTEX_ATTRIBS来获取：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> nrAttributes = <span class="hljs-number">0</span>;<br>GL.GetInteger(GetPName.MaxVertexAttribs, <span class="hljs-keyword">out</span> nrAttributes);<br>Console.WriteLine(<span class="hljs-string">&quot;支持的最大顶点属性数量：&quot;</span> + nrAttributes);<br></code></pre></td></tr></table></figure><p>这通常返回至少16的最小值，对于大多数情况来说应该足够了。</p><h3 id="类型">类型</h3><p>与任何其他编程语言一样，GLSL具有用于指定我们想要使用的变量类型的数据类型。GLSL具有大多数我们从C语言等语言中了解的默认基本类型：int、float、double、uint和bool。GLSL还具有两种容器类型，我们将经常使用它们，即向量和矩阵。我们将在以后的章节中讨论矩阵。</p><h3 id="向量">向量</h3><p>在GLSL中，向量是一个包含任何基本类型中提到的1、2、3或4个组件的容器。它们可以采用以下形式（n代表组件的数量）：</p><ul><li>vecn：n个浮点数的默认向量。</li><li>bvecn：n个布尔值的向量。</li><li>ivecn：n个整数的向量。</li><li>uvecn：n个无符号整数的向量。</li><li>dvecn：n个双精度组件的向量。</li></ul><p>大多数时候，我们将使用基本的vecn，因为对于大多数情况来说，float类型已经足够了。</p><p>可以通过vec.x来访问向量的组件，其中x是向量的第一个组件。您可以使用.x、.y、.z和.w来分别访问它们的第一个、第二、第三和第四个组件。GLSL还允许您使用rgba表示颜色或使用stpq表示纹理坐标，以访问相同的组件。</p><p>向量数据类型允许进行一些有趣且灵活的组件选择，称为swizzling。Swizzling允许我们使用以下语法：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> someVec;<br><span class="hljs-type">vec4</span> differentVec = someVec.xyxx;<br><span class="hljs-type">vec3</span> anotherVec = differentVec.zyw;<br><span class="hljs-type">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;<br></code></pre></td></tr></table></figure><p>您可以使用最多4个字母的任意组合来创建一个新的向量（相同类型的）只要原始向量具有这些组件；例如，不允许访问vec2的.z组件。我们还可以将向量作为参数传递给不同的向量构造函数调用，从而减少所需的参数数量：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> vect = <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.7</span>);<br><span class="hljs-type">vec4</span> result = <span class="hljs-type">vec4</span>(vect, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);<br><span class="hljs-type">vec4</span> otherResult = <span class="hljs-type">vec4</span>(result.xyz, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><p>因此，向量是一种灵活的数据类型，我们可以用它来处理各种输入和输出。在本书中，您将看到许多关于如何创造性地管理向量的示例。</p><h3 id="输入和输出">输入和输出</h3><p>着色器本身是很好的小程序，但它们是整体的一部分，因此我们希望在各个着色器上有输入和输出，以便我们可以移动数据。GLSL专门为此目的定义了in和out关键字。每个着色器都可以使用这些关键字指定输入和输出，其中输出变量与下一个着色器阶段的输入变量匹配时，它们将被传递。然而，顶点着色器和片段着色器有所不同。</p><p>顶点着色器应该接收某种形式的输入，否则它将是相当无效的。顶点着色器的输入与众不同，它直接从顶点数据中接收输入。为了定义顶点数据的组织方式，我们使用位置元数据来指定输入变量，以便我们可以在CPU上配置顶点属性。我们在前一章中已经看到了这一点，即layout（location=0）。因此，顶点着色器需要额外的布局规范来指定其输入，以便我们可以将其与顶点数据链接起来。</p><p>也可以省略layout（location =0）规范，并在OpenGL代码中通过glGetAttribLocation查询属性位置，但我更喜欢在顶点着色器中设置它们。这样更容易理解，也节省了您（和OpenGL）一些工作。</p><p>另一个例外是，片段着色器需要一个vec4颜色输出变量，因为片段着色器需要生成最终的输出颜色。如果您未在片段着色器中指定输出颜色，则这些片段的颜色缓冲输出将未定义（通常意味着OpenGL将它们渲染为黑色或白色）。</p><p>因此，如果我们想要从一个着色器发送数据到另一个着色器，我们必须在发送着色器中声明一个输出，在接收着色器中声明一个类似的输入。当两侧的类型和名称相等时，OpenGL将这些变量链接在一起，然后可以在着色器之间发送数据（这是在链接程序对象时完成的）。为了向您展示这在实践中是如何工作的，我们将修改上一章中的着色器，让顶点着色器决定片段着色器的颜色。</p><h3 id="顶点着色器">顶点着色器</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos; <span class="hljs-comment">// 位置变量在位置0处</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> vertexColor; <span class="hljs-comment">// 向片段着色器指定一个颜色输出</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// 将vec3直接传递给vec4的构造函数</span><br>    vertexColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// 将输出变量设置为深红色</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="片段着色器">片段着色器</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> vertexColor; <span class="hljs-comment">// 来自顶点着色器的输入变量（名称和类型相同）</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = vertexColor;<br>&#125;<br></code></pre></td></tr></table></figure><p>您可以看到，我们声明了一个vertexColor变量作为vec4输出，在顶点着色器中设置了它，并在片段着色器中声明了一个类似的vertexColor输入。由于它们都具有相同的类型和名称，片段着色器中的vertexColor与顶点着色器中的vertexColor链接在一起。由于我们在顶点着色器中将颜色设置为深红色，因此结果片段应该也是深红色。</p><h3 id="uniforms">Uniforms</h3><p>统一变量是另一种将数据从CPU上的应用程序传递到GPU上的着色器的方式。然而，与顶点属性相比，统一变量稍有不同。首先，统一变量是全局的。全局意味着每个着色器程序对象中的统一变量都是唯一的，并且可以在着色器程序的任何阶段的任何着色器中访问。其次，无论您将统一变量的值设置为什么，统一变量都会保持其值，直到被重新设置或更新为止。</p><p>要在GLSL中声明一个统一变量，我们只需在着色器中添加uniform关键字，然后加上一个类型和一个名称。从那时起，我们就可以在着色器中使用新声明的统一变量。让我们看看这次我们能否通过一个统一变量来设置三角形的颜色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br>  <br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec4</span> ourColor; <span class="hljs-comment">// 我们将在OpenGL代码中设置这个变量。</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = ourColor;<br>&#125;   <br></code></pre></td></tr></table></figure><p>我们在片段着色器中声明了一个uniform vec4ourColor，并将片段的输出颜色设置为该统一变量的内容。由于统一变量是全局变量，我们可以在任何我们想要的着色器阶段定义它们，所以不需要再通过顶点着色器来将数据传递到片段着色器。我们在顶点着色器中没有使用这个统一变量，因此也不需要在那里定义它。</p><p>如果您声明了一个在GLSL代码中未被使用的统一变量，编译器将在编译后的版本中静默删除该变量，这是导致一些令人沮丧的错误的原因；请牢记这一点！</p><p>目前这个统一变量是空的；我们还没有向统一变量中添加任何数据，所以让我们尝试一下。我们首先需要找到着色器中统一变量属性的索引/位置。一旦我们有了统一变量的索引/位置，我们就可以更新它的值。我们不再将单一颜色传递到片段着色器中，让我们通过随时间逐渐改变颜色来增添一些色彩：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">double</span> timeValue = _timer.Elapsed.TotalSeconds;<br><span class="hljs-built_in">float</span> greenValue = (<span class="hljs-built_in">float</span>)Math.Sin(timeValue) / <span class="hljs-number">2.0f</span> + <span class="hljs-number">0.5f</span>;<br><span class="hljs-built_in">int</span> vertexColorLocation = GL.GetUniformLocation(_shader.Handle, <span class="hljs-string">&quot;ourColor&quot;</span>);<br>GL.Uniform4(vertexColorLocation, <span class="hljs-number">0.0f</span>, greenValue, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br></code></pre></td></tr></table></figure><p>首先，我们通过StopWatch对象_calld_timer获取了运行时间（以秒为单位）。然后，我们使用sin函数将颜色在0.0- 1.0范围内变化，并将结果存储在greenValue中。</p><p>然后，我们使用glGetUniformLocation查询ourColor统一变量的位置。我们向查询函数提供了着色器程序和统一变量的名称（我们要从中检索位置的名称）。如果glGetUniformLocation返回-1，则表示找不到位置。最后，我们可以使用glUniform4f函数设置统一变量的值。请注意，查找统一变量的位置不需要您首先使用着色器程序，但是更新统一变量需要您首先使用程序（通过调用glUseProgram），因为它会将统一变量设置为当前活动的着色器程序。</p><p>由于OpenGL本质上是一个C库，它不支持函数重载，因此无论函数是否可以使用不同类型进行调用，OpenGL都为每种所需类型定义了新的函数；glUniform就是一个很好的例子。该函数需要用于要设置的统一变量类型的特定后缀。一些可能的后缀包括：</p><ul><li><p>f：该函数希望值为float。</p></li><li><p>i：该函数希望值为int。</p></li><li><p>ui：该函数希望值为unsigned int。</p></li><li><p>3f：该函数希望值为3个float。</p></li><li><p>fv：该函数希望值为float向量/数组。</p></li></ul><p>每当您想要配置OpenGL选项时，只需选择与您的类型对应的重载函数。在我们的情况下，我们想要单独设置统一变量的4个浮点数，因此我们通过glUniform4f传递我们的数据（请注意，我们也可以使用fv版本）。</p><p>现在我们知道如何设置统一变量的值了，我们可以将它们用于渲染。如果我们希望颜色逐渐改变，我们希望在每一帧更新这个统一变量，否则三角形将保持单一的固定颜色，如果我们只设置一次。因此，我们计算greenValue，并在每次渲染迭代之前更新统一变量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderFrame</span>(<span class="hljs-params">FrameEventArgs e</span>)</span><br>&#123;<br>    <span class="hljs-keyword">base</span>.OnRenderFrame(e);<br><br>    <span class="hljs-comment">// 渲染</span><br>    <span class="hljs-comment">// 清除颜色缓冲区</span><br>    GL.Clear(ClearBufferMask.ColorBufferBit);<br><br>    <span class="hljs-comment">// 确保激活着色器</span><br>    _shader.Use();<br><br>    <span class="hljs-comment">// 更新统一变量颜色</span><br>    <span class="hljs-built_in">double</span> timeValue = _timer.Elapsed.TotalSeconds;<br>    <span class="hljs-built_in">float</span> greenValue = (<span class="hljs-built_in">float</span>)Math.Sin(timeValue) / <span class="hljs-number">2.0f</span> + <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-built_in">int</span> vertexColorLocation = GL.GetUniformLocation(_shader.Handle, <span class="hljs-string">&quot;ourColor&quot;</span>);<br>    GL.Uniform4(vertexColorLocation, <span class="hljs-number">0.0f</span>, greenValue, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br><br><br>    <span class="hljs-comment">// 现在渲染三角形</span><br>    GL.BindVertexArray(_vertexArrayObject);<br>    GL.DrawArrays(PrimitiveType.Triangles, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 交换缓冲区</span><br>    SwapBuffers();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是前一段代码的一个相对简单的改编。这一次，在绘制三角形之前，我们每帧更新一次统一变量的值。如果您正确更新了统一变量，您应该可以看到三角形的颜色从绿色逐渐变为黑色，然后再变回绿色。</p><p>正如您所看到的，统一变量是一个有用的工具，用于设置每一帧可能会变化的属性，或者用于在应用程序和着色器之间交换数据，但是如果我们想为每个顶点设置一个颜色怎么办？在这种情况下，我们必须为每个顶点声明许多统一变量。更好的解决方案是在顶点属性中包含更多的数据，这就是我们接下来要做的事情。</p><h3 id="更多属性">更多属性</h3><p>在上一章中，我们学习了如何填充VBO、配置顶点属性指针并将所有数据存储在 VAO中。这一次，我们还想要向顶点数据中添加颜色数据。我们将颜色数据作为 3个浮点数添加到顶点数组中。我们分别为三角形的每个角分配了红色、绿色和蓝色：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">float</span>[] _vertices =<br>&#123;<br>    <span class="hljs-comment">// positions        // colors</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// bottom right</span><br>   <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// bottom left</span><br>    <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>    <span class="hljs-comment">// top </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>由于我们现在要发送更多数据到顶点着色器，因此需要调整顶点着色器以接收颜色值作为顶点属性输入。请注意，我们使用布局说明符将aColor 属性的位置设置为 1：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;   <span class="hljs-comment">// the position variable has attribute position 0</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aColor; <span class="hljs-comment">// the color variable has attribute position 1</span><br>  <br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> ourColor; <span class="hljs-comment">// output a color to the fragment shader</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    ourColor = aColor; <span class="hljs-comment">// set ourColor to the input color we got from the vertex data</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们不再使用 uniform 来设置片段的颜色，而是使用了 ourColor输出变量，因此还需要更改片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;  <br><span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> ourColor;<br>  <br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = <span class="hljs-type">vec4</span>(ourColor, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们添加了另一个顶点属性并更新了 VBO的内存，因此必须重新配置顶点属性指针。VBO内存中的更新数据现在如下所示：</p><p><img src="4-vertex_attribute_pointer_interleaved.png" /></p><p>了解了当前的布局，我们可以使用 glVertexAttribPointer更新顶点格式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>GL.VertexAttribPointer(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br>GL.EnableVertexAttribArray(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>glVertexAttribPointer 的前几个参数相对简单。这次我们在属性位置 1上配置了顶点属性。颜色值有 3个浮点数大小，并且我们不对值进行归一化处理。</p><p>由于我们现在有两个顶点属性，因此必须重新计算步幅值。为了获取数据数组中的下一个属性值（例如位置向量的下一个x 分量），我们必须向右移动 6个浮点数，其中三个用于位置值，三个用于颜色值。这给了我们步幅值为 6乘以浮点数的大小（= 24字节）。此外，这次我们必须指定偏移量。对于每个顶点，位置顶点属性首先出现，因此偏移量为0。颜色属性在位置数据之后开始，因此偏移量为 3 * sizeof(float) 字节（= 12字节）。</p><p>运行应用程序应该会产生以下图像：</p><p><img src="更多属性.png" /></p><p>图像可能不是您预期的，因为我们只提供了 3种颜色，而不是我们现在看到的庞大颜色调色板。这一切都是片段着色器中称为片段插值的结果。当渲染三角形时，光栅化阶段通常会产生比最初指定的顶点更多的片段。然后，光栅化器根据它们在三角形形状上的位置确定每个片段的位置。基于这些位置，它会对所有片段着色器的输入变量进行插值。举个例子，假设我们有一条线，上点是绿色，下点是蓝色。如果片段着色器在线的70%位置处运行，那么其结果的颜色输入属性将是绿色和蓝色的线性组合；更准确地说是：30%的蓝色和 70% 的绿色。</p><p>这正是在三角形中发生的情况。我们有 3 个顶点，因此有 3种颜色，从三角形的像素来看，它可能包含大约 50000个片段，片段着色器在这些像素之间进行颜色插值。如果您仔细观察颜色，您会发现这一切都是有道理的：从红色到蓝色首先变成紫色，然后变成蓝色。片段插值应用于所有片段着色器的输入属性。</p><h2 id="纹理">纹理</h2><p>我们学到了通过为每个顶点指定颜色来为对象添加更多细节，从而创建一些有趣的图像。然而，为了获得相当程度的逼真感，我们必须拥有许多顶点，以便我们可以指定许多颜色。这会增加相当多的额外开销，因为每个模型都需要更多的顶点，而且每个顶点都需要一个颜色属性。</p><p>艺术家和程序员通常更喜欢使用纹理。纹理是一个2D图像（虽然存在1D和3D纹理，但它们并不常见），用于为对象添加细节；可以将纹理想象成一个带有漂亮砖块图像（例如）的纸张，整齐地折叠在你的3D房屋上，使得你的房子看起来像是外部有石头覆盖。由于我们可以在单个图像中插入许多细节，因此我们可以产生这样的幻觉，即对象非常详细，而无需指定额外的顶点。</p><p>除了图像之外，纹理还可以用于存储大量数据以发送到着色器，但我们将把这留到另一个话题。</p><p>下面你将看到一个砖墙的纹理图像被映射到前面教程中的三角形上。</p><p><img src="wall.jpg" /></p><p>为了将纹理映射到三角形上，我们需要告诉三角形的每个顶点它对应纹理的哪一部分。因此，每个顶点都应该有一个与之关联的纹理坐标，指定从纹理图像中采样的部分。然后，片段插值会为其他片段完成剩余工作。</p><p>纹理坐标在x和y轴上的范围是从0到1（记住我们使用的是2D纹理图像）。使用纹理坐标检索纹理颜色称为采样。纹理坐标从纹理图像的左下角（0,0）开始，到右上角（1,1）结束。下面的图像展示了我们如何将纹理坐标映射到三角形上：</p><p><img src="5-tex_coords.png" /></p><p>我们为三角形指定了3个纹理坐标点。我们希望三角形的左下边对应纹理的左下边，因此我们对三角形的左下顶点使用了纹理坐标(0,0)。对于右下边，我们使用了(1,0)作为纹理坐标。三角形的顶部应该对应纹理图像的顶部中心，因此我们将(0.5,1.0)作为其纹理坐标。我们只需将3个纹理坐标传递给顶点着色器，然后顶点着色器将这些坐标传递给片段着色器，后者将为每个片段精确插值所有纹理坐标。</p><p>结果的纹理坐标如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">float</span>[] texCoords = &#123;<br>    <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// lower-left corner  </span><br>    <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// lower-right corner</span><br>    <span class="hljs-number">0.5f</span>, <span class="hljs-number">1.0f</span>   <span class="hljs-comment">// top-center corner</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>纹理采样具有宽泛的解释，并且可以通过许多不同的方式进行。因此，我们的任务是告诉OpenGL应该如何对其纹理进行采样。</p><h3 id="纹理包裹">纹理包裹</h3><p>纹理坐标通常范围在 (0,0) 到 (1,1)之间，但如果我们指定超出此范围的坐标会发生什么？OpenGL的默认行为是重复纹理图像（基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多选项：</p><ul><li>Repeat（重复）：纹理的默认行为。重复纹理图像。</li><li>MirroredRepeat（镜像重复）：与 GL_REPEAT相同，但在每次重复时镜像图像。</li><li>ClampToEdge（夹取到边缘）：将坐标夹取在 0 和 1之间。结果是，较高的坐标将夹取到边缘，导致边缘拉伸的图案。</li><li>ClampToBorder（夹取到边界）：超出范围的坐标现在被赋予用户指定的边界颜色。</li></ul><p>每个选项在使用纹理坐标超出默认范围时都会产生不同的视觉效果。让我们看看这些选项在示例纹理图像上的效果：</p><p><img src="5-texture_wrapping.png" /></p><p>上述提到的每个选项都可以通过 GL.TexParameter函数针对每个坐标轴（s、t（如果您使用 3D 纹理，则为 p，相当于x、y、z））进行设置：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br></code></pre></td></tr></table></figure><blockquote><p>注意：您必须将枚举强制转换为 int 才能使 GL.TexParameter 接受它。</p></blockquote><p>第一个参数指定纹理目标；我们使用 2D 纹理，因此纹理目标是TextureTarget.Texture2D。</p><p>第二个参数要求我们告诉它我们想设置哪个选项以及对应的纹理轴。我们想配置WRAP 选项，并为 S 和 T 轴指定它。</p><p>最后一个参数要求我们传入我们想要的纹理包裹模式，在这种情况下，OpenGL将使用 TextureWrapMode.Repeat 设置当前活动纹理的纹理包裹选项。</p><p>如果我们选择 TextureWrapMode.ClampToBorder选项，我们还应该指定边界颜色。这可以使用 fv 版本的 glTexParameter函数来完成，其中选项为TextureParameterName.TextureBorderColor，我们传入一个边界颜色值的浮点数组：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">float</span>[] borderColor = &#123; <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureBorderColor, borderColor);<br></code></pre></td></tr></table></figure><h3 id="纹理过滤">纹理过滤</h3><p>纹理坐标不依赖于分辨率，而可以是任何浮点值，因此OpenGL必须确定要将纹理坐标映射到哪个纹理像素（也称为纹素）。如果您有一个非常大的对象和一个低分辨率的纹理，这变得尤为重要。您现在可能已经猜到，OpenGL也有针对这种纹理过滤的选项。有几个选项可用，但现在我们将讨论最重要的选项：最近和线性。</p><p>最近（也称为最近邻过滤）是OpenGL的默认纹理过滤方法。当设置为最近时，OpenGL选择最靠近纹理坐标的像素中心。下面您可以看到4个像素，十字表示确切的纹理坐标。左上角的纹素其中心最靠近纹理坐标，因此被选为采样颜色：</p><p><img src="5-texture_filter_nearest.png" /></p><p>线性（也称为（双）线性过滤）从纹理坐标的相邻纹素中取得一个插值的值，从而近似计算出纹素之间的颜色。纹理坐标到纹素中心的距离越小，该纹素的颜色就对采样颜色贡献越大。下面我们可以看到返回的相邻像素的混合颜色：</p><p><img src="5-texture_filter_linear.png" /></p><p>但是，这种纹理过滤方法的视觉效果是什么呢？让我们看看在大对象上使用低分辨率纹理时这些方法的工作方式（因此纹理被放大，单个纹素是可见的）：</p><p><img src="5-texture_filtering.png" /></p><p>最近邻过滤产生了明显的像素块模式，我们可以清楚地看到形成纹理的像素，而线性过滤产生了更平滑的模式，单个像素不太明显。线性过滤产生了更真实的输出，但有些开发人员更喜欢复古、像素化的外观，因此选择了最近邻选项。</p><p>纹理过滤可以针对放大和缩小操作（放大或缩小时）进行设置，因此您可以在纹理被缩小时使用最近邻过滤，而在纹理被放大时使用线性过滤。因此，我们必须通过GL.TexParameter为两种选项指定过滤方法。代码应该类似于设置包装方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.Nearest);<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br></code></pre></td></tr></table></figure><h3 id="mipmaps">Mipmaps</h3><p>想象一下，我们有一个庞大的房间，里面摆放着成千上万个物体，每个物体都附有一个贴图。远处的物体和近处的物体都使用同样的高分辨率贴图。由于远处的物体只产生少量片段，OpenGL在从高分辨率贴图中为片段选择正确的颜色值时会遇到困难，因为它必须为跨越贴图大部分区域的片段选择一个贴图颜色。这将在小物体上产生可见的伪影，而且在小物体上使用高分辨率贴图也浪费了内存和计算资源。</p><p>为了解决这个问题，OpenGL 引入了一种叫做 Mipmaps的概念，它基本上是一组贴图图像，其中每个后续的贴图都是前一个贴图的一半大小。Mipmaps背后的思想应该很容易理解：在距离观察者一定距离后，OpenGL将使用最适合对象距离的不同 Mipmap贴图。因为对象远处，较小的分辨率对用户来说不会明显。此外，Mipmaps还有一个额外的好处，就是它们对性能也有好处。让我们更仔细地看看 Mipmapped贴图是什么样子：</p><p><img src="5-mipmaps.png" /></p><p>手动创建每个贴图图像的 Mipmapped 贴图集合很麻烦，但幸运的是，OpenGL可以在我们创建贴图后通过一次调用GL.GenerateMipmap(GenerateMipmapTarget.Texture2D)来为我们完成所有工作。稍后在贴图教程中，您将看到如何使用此函数。</p><p>在渲染过程中切换 Mipmap 级别时，OpenGL 可能会显示一些伪影，例如两个Mipmap 层之间可见的锐利边缘。就像普通的贴图过滤一样，我们也可以使用Nearest 和 Linear 过滤来在 Mipmap级别之间进行切换。我们可以用以下四个选项之一来指定 Mipmap级别之间的过滤方法：</p><ul><li>NearestMipmapNearest：选择最接近的 Mipmap来匹配像素大小，并使用最近邻插值进行贴图采样。</li><li>LinearMipmapNearest：选择最接近的 Mipmap级别，并使用线性插值进行采样。</li><li>NearestMipmapLinear：在最接近像素大小的两个 Mipmap之间进行线性插值，并通过最近邻插值采样贴图。</li><li>LinearMipmapLinear：在最接近的两个 Mipmap之间进行线性插值，并通过线性插值采样贴图。</li></ul><p>与贴图过滤一样，我们可以使用 GL.TexParameter将过滤方法设置为上述四种方法之一：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.LinearMipmapLinear);<br>GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br></code></pre></td></tr></table></figure><p>一个常见的错误是将其中一种 Mipmap过滤选项设置为放大过滤器。这没有任何效果，因为 Mipmaps主要用于当贴图缩小时：贴图放大不使用 Mipmaps，给它一个 Mipmap过滤选项将生成一个 OpenGL GL_INVALID_ENUM 错误代码。</p><h3 id="加载和创建纹理">加载和创建纹理</h3><p>现在我们已经创建了纹理，我们需要修改我们的着色器和顶点来使用纹理。</p><p>首先，用以下顶点数组替换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">float</span>[] vertices =<br>&#123;<br>    <span class="hljs-comment">//Position          Texture coordinates</span><br>     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-comment">// 右上</span><br>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 右下</span><br>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下</span><br>    <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>  <span class="hljs-comment">// 左上</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>回想一下我们之前讨论的纹理坐标以及它们的工作原理。我们将它们添加到每个顶点中。</p><p>接下来，我们将修改顶点属性位置以将纹理坐标发送到着色器。</p><p>用以下调用替换您对VertexAttribPointer的调用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.VertexAttribPointer(vertexLocation, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>几乎完全相同，只是将步长从3 * sizeof(float)更改为5 *sizeof(float)以适应新的纹理坐标。</p><p>在其下面，添加以下行：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> texCoordLocation = shader.GetAttribLocation(<span class="hljs-string">&quot;aTexCoord&quot;</span>);<br>GL.EnableVertexAttribArray(texCoordLocation);<br>GL.VertexAttribPointer(texCoordLocation, <span class="hljs-number">2</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br></code></pre></td></tr></table></figure><p>再次几乎完全与上次调用相同，只是数据包数从3变为2，并且初始偏移量为3 *sizeof(float)。</p><p>现在，我们需要修改我们的着色器。首先是顶点着色器。新代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoord;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>    texCoord = aTexCoord;<br><br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们添加了另一个输入变量aTexCoord，它将是纹理坐标。我们将其原样转发到输出变量texCoord，以便片段着色器可以使用它。说到片段着色器，接下来是它：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outputColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture0;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    outputColor = <span class="hljs-built_in">texture</span>(texture0, texCoord);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到一个全新的变量类型sampler2D。简单来说，那是着色器中纹理的表示。</p><p>最多可以一次绑定16个不同的纹理（取决于您的硬件，可能更多，但OpenGL要求至少16个）。在下一个例子中，我将向您展示如何同时使用多个纹理。但是，现在我们不需要做其他任何事情。</p><p>如果您一切都做对了，当您运行代码时，您应该看到以下内容：</p><p><img src="texture_result.png" /></p><p>祝贺您绘制了您的第一个纹理！下次，我将演示如何同时绘制多个纹理。</p><h3 id="完整代码">完整代码</h3><h4 id="form1.cs">Form1.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Diagnostics;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> OpenTK.WinForms;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Windows.Forms.VisualStyles.VisualStyleElement;<br><span class="hljs-keyword">using</span> OpenTK.Mathematics;<br><span class="hljs-keyword">using</span> OpenTK.Windowing.GraphicsLibraryFramework;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br><br>        <span class="hljs-built_in">float</span>[] vertices =<br>        &#123;<br>            <span class="hljs-comment">//Position          Texture coordinates</span><br>             <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-comment">// 右上</span><br>             <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 右下</span><br>            <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下</span><br>            <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>  <span class="hljs-comment">// 左上</span><br>        &#125;;<br>        <span class="hljs-built_in">uint</span>[] indices = &#123;  <span class="hljs-comment">// note that we start from 0!</span><br>            <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,   <span class="hljs-comment">// first triangle</span><br>            <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    <span class="hljs-comment">// second triangle</span><br>        &#125;;<br>        <span class="hljs-built_in">int</span> VertexBufferObject;<br>        <span class="hljs-built_in">int</span> vertexArrayObject;<br>        <span class="hljs-built_in">int</span> ElementBufferObject;<br>        <span class="hljs-keyword">private</span> Texture _texture;<br>        Shader shader;<br>        Stopwatch timer;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Form1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.ClearColor(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>            <br><br>            <span class="hljs-comment">// Create and bind VAO</span><br>            vertexArrayObject = GL.GenVertexArray();<br>            GL.BindVertexArray(vertexArrayObject);<br><br>            <span class="hljs-comment">// Create and bind VBO</span><br>            VertexBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>            <span class="hljs-comment">// Provide vertex data to the VBO</span><br>            GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><br>            ElementBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ElementArrayBuffer, ElementBufferObject);<br>            GL.BufferData(BufferTarget.ElementArrayBuffer, indices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">uint</span>), indices, BufferUsageHint.StaticDraw);<br><br>            shader = <span class="hljs-keyword">new</span> Shader(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.vert&quot;</span>, <span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.frag&quot;</span>);<br>            timer = <span class="hljs-keyword">new</span> Stopwatch();<br>            shader.Use();<br><br>            <span class="hljs-comment">// Specify the vertex attribute pointers</span><br>            GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>            GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-built_in">int</span> texCoordLocation = GL.GetAttribLocation(shader.Handle, <span class="hljs-string">&quot;aTexCoord&quot;</span>);<br>            GL.EnableVertexAttribArray(texCoordLocation);<br>            GL.VertexAttribPointer(texCoordLocation, <span class="hljs-number">2</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br><br>            _texture = Texture.LoadFromFile(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/Resources/container.png&quot;</span>);<br>            _texture.Use(TextureUnit.Texture0);<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Paint</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, PaintEventArgs e</span>)</span><br>        &#123;<br>            GL.Clear(ClearBufferMask.ColorBufferBit);<br><br>            GL.BindVertexArray(vertexArrayObject);<br><br>            _texture.Use(TextureUnit.Texture0);<br>            shader.Use();<br><br>            GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br><br>            glControl1.SwapBuffers();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_SizeChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> deltaTime</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//var input = KeyboardState;</span><br><br>            <span class="hljs-comment">//if (input.IsKeyDown(Keys.Escape))</span><br>            <span class="hljs-comment">//&#123;</span><br>            <span class="hljs-comment">//    Close();</span><br>            <span class="hljs-comment">//&#125;</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">timer1_Tick</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">float</span> deltaTime = (<span class="hljs-built_in">float</span>)timer.Elapsed.TotalSeconds;<br>            timer.Restart();<br><br>            OnUpdate(deltaTime);<br>            <br>            glControl1.Invalidate();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="texture.cs">Texture.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> System.Drawing;<br><span class="hljs-keyword">using</span> System.Drawing.Imaging;<br><span class="hljs-keyword">using</span> PixelFormat = OpenTK.Graphics.OpenGL.PixelFormat;<br><span class="hljs-keyword">using</span> StbImageSharp;<br><span class="hljs-keyword">using</span> System.IO;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Texture</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Handle;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture <span class="hljs-title">LoadFromFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// Generate handle</span><br>            <span class="hljs-built_in">int</span> handle = GL.GenTexture();<br><br>            <span class="hljs-comment">// Bind the handle</span><br>            GL.ActiveTexture(TextureUnit.Texture0);<br>            GL.BindTexture(TextureTarget.Texture2D, handle);<br><br>            <span class="hljs-comment">// For this example, we&#x27;re going to use .NET&#x27;s built-in System.Drawing library to load textures.</span><br><br>            <span class="hljs-comment">// OpenGL has it&#x27;s texture origin in the lower left corner instead of the top left corner,</span><br>            <span class="hljs-comment">// so we tell StbImageSharp to flip the image when loading.</span><br>            StbImage.stbi_set_flip_vertically_on_load(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// Here we open a stream to the file and pass it to StbImageSharp to load.</span><br>            <span class="hljs-keyword">using</span> (Stream stream = File.OpenRead(path))<br>            &#123;<br>                ImageResult image = ImageResult.FromStream(stream, ColorComponents.RedGreenBlueAlpha);<br><br>                <span class="hljs-comment">// Now that our pixels are prepared, it&#x27;s time to generate a texture. We do this with GL.TexImage2D.</span><br>                <span class="hljs-comment">// Arguments:</span><br>                <span class="hljs-comment">//   The type of texture we&#x27;re generating. There are various different types of textures, but the only one we need right now is Texture2D.</span><br>                <span class="hljs-comment">//   Level of detail. We can use this to start from a smaller mipmap (if we want), but we don&#x27;t need to do that, so leave it at 0.</span><br>                <span class="hljs-comment">//   Target format of the pixels. This is the format OpenGL will store our image with.</span><br>                <span class="hljs-comment">//   Width of the image</span><br>                <span class="hljs-comment">//   Height of the image.</span><br>                <span class="hljs-comment">//   Border of the image. This must always be 0; it&#x27;s a legacy parameter that Khronos never got rid of.</span><br>                <span class="hljs-comment">//   The format of the pixels, explained above. Since we loaded the pixels as RGBA earlier, we need to use PixelFormat.Rgba.</span><br>                <span class="hljs-comment">//   Data type of the pixels.</span><br>                <span class="hljs-comment">//   And finally, the actual pixels.</span><br>                GL.TexImage2D(TextureTarget.Texture2D, <span class="hljs-number">0</span>, PixelInternalFormat.Rgba, image.Width, image.Height, <span class="hljs-number">0</span>, PixelFormat.Rgba, PixelType.UnsignedByte, image.Data);<br>            &#125;<br><br>            <span class="hljs-comment">// Now that our texture is loaded, we can set a few settings to affect how the image appears on rendering.</span><br><br>            <span class="hljs-comment">// First, we set the min and mag filter. These are used for when the texture is scaled down and up, respectively.</span><br>            <span class="hljs-comment">// Here, we use Linear for both. This means that OpenGL will try to blend pixels, meaning that textures scaled too far will look blurred.</span><br>            <span class="hljs-comment">// You could also use (amongst other options) Nearest, which just grabs the nearest pixel, which makes the texture look pixelated if scaled too far.</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The default settings for both of these are LinearMipmap. If you leave these as default but don&#x27;t generate mipmaps,</span><br>            <span class="hljs-comment">// your image will fail to render at all (usually resulting in pure black instead).</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.Linear);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br><br>            <span class="hljs-comment">// Now, set the wrapping mode. S is for the X axis, and T is for the Y axis.</span><br>            <span class="hljs-comment">// We set this to Repeat so that textures will repeat when wrapped. Not demonstrated here since the texture coordinates exactly match</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br><br>            <span class="hljs-comment">// Next, generate mipmaps.</span><br>            <span class="hljs-comment">// Mipmaps are smaller copies of the texture, scaled down. Each mipmap level is half the size of the previous one</span><br>            <span class="hljs-comment">// Generated mipmaps go all the way down to just one pixel.</span><br>            <span class="hljs-comment">// OpenGL will automatically switch between mipmaps when an object gets sufficiently far away.</span><br>            <span class="hljs-comment">// This prevents moiré effects, as well as saving on texture bandwidth.</span><br>            <span class="hljs-comment">// Here you can see and read about the morié effect https://en.wikipedia.org/wiki/Moir%C3%A9_pattern</span><br>            <span class="hljs-comment">// Here is an example of mips in action https://en.wikipedia.org/wiki/File:Mipmap_Aliasing_Comparison.png</span><br>            GL.GenerateMipmap(GenerateMipmapTarget.Texture2D);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Texture(handle);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Texture</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> glHandle</span>)</span><br>        &#123;<br>            Handle = glHandle;<br>        &#125;<br><br>        <span class="hljs-comment">// Activate texture</span><br>        <span class="hljs-comment">// Multiple textures can be bound, if your shader needs more than just one.</span><br>        <span class="hljs-comment">// If you want to do that, use GL.ActiveTexture to set which slot GL.BindTexture binds to.</span><br>        <span class="hljs-comment">// The OpenGL standard requires that there be at least 16, but there can be more depending on your graphics card.</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>(<span class="hljs-params">TextureUnit unit</span>)</span><br>        &#123;<br>            GL.ActiveTexture(unit);<br>            GL.BindTexture(TextureTarget.Texture2D, Handle);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.cs">Shader.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shader</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Handle &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shader</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> vertexPath, <span class="hljs-built_in">string</span> fragmentPath</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">string</span> VertexShaderSource = File.ReadAllText(vertexPath);<br>            <span class="hljs-built_in">int</span> vertexShader = GL.CreateShader(ShaderType.VertexShader);<br>            GL.ShaderSource(vertexShader, VertexShaderSource);<br>            GL.CompileShader(vertexShader);<br><br><br>            <span class="hljs-built_in">string</span> FragmentShaderSource = File.ReadAllText(fragmentPath);<br>            <span class="hljs-built_in">int</span> fragmentShader = GL.CreateShader(ShaderType.FragmentShader);<br>            GL.ShaderSource(fragmentShader, FragmentShaderSource);<br>            GL.CompileShader(fragmentShader);<br><br>            <span class="hljs-comment">// Create shader program and link shaders</span><br>            Handle = GL.CreateProgram();<br>            GL.AttachShader(Handle, vertexShader);<br>            GL.AttachShader(Handle, fragmentShader);<br>            GL.LinkProgram(Handle);<br><br>            <span class="hljs-comment">// Clean up individual shaders</span><br>            GL.DetachShader(Handle, vertexShader);<br>            GL.DetachShader(Handle, fragmentShader);<br>            GL.DeleteShader(fragmentShader);<br>            GL.DeleteShader(vertexShader);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span><br>        &#123;<br>            GL.UseProgram(Handle);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.vert">shader.vert</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoord;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>    texCoord = aTexCoord;<br><br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.frag">shader.frag</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outputColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture0;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    outputColor = <span class="hljs-built_in">texture</span>(texture0, texCoord);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多纹理和纹理单元">多纹理和纹理单元</h2><p>你可能想知道为什么<code>sampler2D</code>变量是一个<code>uniform</code>，如果我们甚至没有使用<code>GL.Uniform*</code>为它分配一些值。使用<code>GL.Uniform1</code>，我们实际上可以为纹理采样器分配一个位置值，这样我们就可以在片段着色器中一次设置多个纹理。纹理的位置更常见地称为纹理单元。纹理的默认单元是0，这是默认的活动纹理单元，因此我们在上一节中没有分配位置；请注意，并非所有的图形驱动程序都会分配默认的纹理单元，因此上一节可能对您没有渲染。</p><p>纹理单元的主要目的是允许我们在着色器中使用多于一个纹理。通过为采样器分配纹理单元，我们可以一次绑定多个纹理，只要我们先激活相应的纹理单元。就像GL.BindTexture一样，我们可以使用GL.ActiveTexture激活纹理单元，传入我们想要使用的纹理单元：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.ActiveTexture(TextureUnit.Texture0); <span class="hljs-comment">// 绑定纹理之前先激活纹理单元</span><br>GL.BindTexture(TextureTarget.Texture2D, texture);<br></code></pre></td></tr></table></figure><p>激活了一个纹理单元之后，后续的GL.BindTexture调用将把纹理绑定到当前活动的纹理单元。纹理单元Texture0总是默认激活的，所以当使用GL.BindTexture时，我们不需要激活任何纹理单元。</p><p>OpenGL应该至少有16个纹理单元供您使用，您可以使用Texture0到Texture15来激活它们。</p><p>然而，我们仍然需要编辑片段着色器以接受另一个采样器。现在应该相对简单：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-comment">/* ... */</span><br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture1;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture2;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = <span class="hljs-built_in">mix</span>(<span class="hljs-built_in">texture</span>(texture1, TexCoord), <span class="hljs-built_in">texture</span>(texture2, TexCoord), <span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终的输出颜色现在是两个纹理查找的组合。GLSL的内置mix函数接受两个值作为输入，并根据其第三个参数进行线性插值。如果第三个值是0.0，它将返回第一个输入；如果是1.0，它将返回第二个输入值。值为0.2将返回第一个输入颜色的80%和第二个输入颜色的20%，从而得到两个纹理的混合色。</p><p>现在我们想要加载和创建另一个纹理；您现在应该熟悉了这些步骤。确保创建另一个纹理对象，加载图像并使用GL.TexImage2D生成最终的纹理。对于第二个纹理，我们将使用一个学习OpenGL时你的面部表情的图像：</p><p>要使用第二个纹理（和第一个纹理），我们需要稍微更改渲染过程，将两个纹理绑定到相应的纹理单元。首先，转到Texture.cs，并像这样修改Use函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>(<span class="hljs-params">TextureUnit unit = TextureUnit.Texture0</span>)</span><br>&#123;<br>    GL.ActiveTexture(unit);<br>    GL.BindTexture(TextureTarget.Texture2D, Handle);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在OnLoad中添加一个新属性来保存新纹理，并加载它。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Texture texture2;<br><br>...<br><br>texture2 = <span class="hljs-keyword">new</span> Texture(<span class="hljs-string">&quot;awesomeface.png&quot;</span>);<br></code></pre></td></tr></table></figure><p>新纹理已经准备好了，现在我们必须设置着色器uniform变量。在Shader.cs中添加以下函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetInt</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> location = GL.GetUniformLocation(Handle, name);<br><br>    GL.Uniform1(location, <span class="hljs-keyword">value</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数简化了设置着色器uniform变量的过程。采样器在CPU中表示为整数；将uniform设置为整数，它将检查纹理单元。</p><p>在OnLoad中创建纹理后，立即添加以下行：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">shader.SetInt(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">0</span>);<br>shader.SetInt(<span class="hljs-string">&quot;texture2&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这将uniform纹理1设置为使用纹理单元0中的内容，并将纹理2设置为使用纹理单元1中的内容。</p><p>最后，在OnRenderFrame中进行如下修改：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">GL.Clear(ClearBufferMask.ColorBufferBit);<br>GL.BindVertexArray(VertexArrayObject);<br><br>texture.Use(TextureUnit.Texture0);<br>texture2.Use(TextureUnit.Texture1);<br>shader.Use();<br><br>GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br><br>Context.SwapBuffers();<br><br><span class="hljs-keyword">base</span>.OnRenderFrame(e);<br></code></pre></td></tr></table></figure><p>绑定了两个纹理并且着色器正确设置后，您现在应该看到以下结果：</p><h3 id="完整代码-1">完整代码</h3><h4 id="form1.cs-1">Form1.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Diagnostics;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> OpenTK.WinForms;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Windows.Forms.VisualStyles.VisualStyleElement;<br><span class="hljs-keyword">using</span> OpenTK.Mathematics;<br><span class="hljs-keyword">using</span> OpenTK.Windowing.GraphicsLibraryFramework;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br><br>        <span class="hljs-built_in">float</span>[] vertices =<br>        &#123;<br>            <span class="hljs-comment">//Position          Texture coordinates</span><br>             <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-comment">// 右上</span><br>             <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 右下</span><br>            <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下</span><br>            <span class="hljs-number">-0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>  <span class="hljs-comment">// 左上</span><br>        &#125;;<br>        <span class="hljs-built_in">uint</span>[] indices = &#123;  <span class="hljs-comment">// note that we start from 0!</span><br>            <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,   <span class="hljs-comment">// first triangle</span><br>            <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    <span class="hljs-comment">// second triangle</span><br>        &#125;;<br>        <span class="hljs-built_in">int</span> VertexBufferObject;<br>        <span class="hljs-built_in">int</span> vertexArrayObject;<br>        <span class="hljs-built_in">int</span> ElementBufferObject;<br>        <span class="hljs-keyword">private</span> Texture _texture;<br>        <span class="hljs-keyword">private</span> Texture _texture2;<br>        Shader shader;<br>        Stopwatch timer;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Form1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.ClearColor(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>            <br><br>            <span class="hljs-comment">// Create and bind VAO</span><br>            vertexArrayObject = GL.GenVertexArray();<br>            GL.BindVertexArray(vertexArrayObject);<br><br>            <span class="hljs-comment">// Create and bind VBO</span><br>            VertexBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ArrayBuffer, VertexBufferObject);<br>            <span class="hljs-comment">// Provide vertex data to the VBO</span><br>            GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), vertices, BufferUsageHint.StaticDraw);<br><br>            ElementBufferObject = GL.GenBuffer();<br>            GL.BindBuffer(BufferTarget.ElementArrayBuffer, ElementBufferObject);<br>            GL.BufferData(BufferTarget.ElementArrayBuffer, indices.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">uint</span>), indices, BufferUsageHint.StaticDraw);<br><br>            shader = <span class="hljs-keyword">new</span> Shader(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.vert&quot;</span>, <span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/shader.frag&quot;</span>);<br>            timer = <span class="hljs-keyword">new</span> Stopwatch();<br>            shader.Use();<br><br>            <span class="hljs-comment">// Specify the vertex attribute pointers</span><br>            GL.VertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">0</span>);<br>            GL.EnableVertexAttribArray(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-built_in">int</span> texCoordLocation = GL.GetAttribLocation(shader.Handle, <span class="hljs-string">&quot;aTexCoord&quot;</span>);<br>            GL.EnableVertexAttribArray(texCoordLocation);<br>            GL.VertexAttribPointer(texCoordLocation, <span class="hljs-number">2</span>, VertexAttribPointerType.Float, <span class="hljs-literal">false</span>, <span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">float</span>));<br><br>            _texture = Texture.LoadFromFile(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/Resources/container.png&quot;</span>);<br>            _texture.Use(TextureUnit.Texture0);<br><br>            _texture2 = Texture.LoadFromFile(<span class="hljs-string">&quot;D:/Desktop/OpenTKTest/OpenTKTest/Resources/awesomeface.png&quot;</span>);<br>            _texture2.Use(TextureUnit.Texture1);<br><br>            shader.SetInt(<span class="hljs-string">&quot;texture0&quot;</span>, <span class="hljs-number">0</span>);<br>            shader.SetInt(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_Paint</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, PaintEventArgs e</span>)</span><br>        &#123;<br>            GL.Clear(ClearBufferMask.ColorBufferBit);<br><br>            GL.BindVertexArray(vertexArrayObject);<br><br>            _texture.Use(TextureUnit.Texture0);<br>            _texture2.Use(TextureUnit.Texture1);<br>            shader.Use();<br><br>            GL.DrawElements(PrimitiveType.Triangles, indices.Length, DrawElementsType.UnsignedInt, <span class="hljs-number">0</span>);<br><br>            glControl1.SwapBuffers();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">glControl1_SizeChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            GL.Viewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, glControl1.Width, glControl1.Height);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> deltaTime</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//var input = KeyboardState;</span><br><br>            <span class="hljs-comment">//if (input.IsKeyDown(Keys.Escape))</span><br>            <span class="hljs-comment">//&#123;</span><br>            <span class="hljs-comment">//    Close();</span><br>            <span class="hljs-comment">//&#125;</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">timer1_Tick</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">float</span> deltaTime = (<span class="hljs-built_in">float</span>)timer.Elapsed.TotalSeconds;<br>            timer.Restart();<br><br>            OnUpdate(deltaTime);<br>            <br>            glControl1.Invalidate();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="texture.cs-1">Texture.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><span class="hljs-keyword">using</span> System.Drawing;<br><span class="hljs-keyword">using</span> System.Drawing.Imaging;<br><span class="hljs-keyword">using</span> PixelFormat = OpenTK.Graphics.OpenGL.PixelFormat;<br><span class="hljs-keyword">using</span> StbImageSharp;<br><span class="hljs-keyword">using</span> System.IO;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Texture</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Handle;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture <span class="hljs-title">LoadFromFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// Generate handle</span><br>            <span class="hljs-built_in">int</span> handle = GL.GenTexture();<br><br>            <span class="hljs-comment">// Bind the handle</span><br>            GL.ActiveTexture(TextureUnit.Texture0);<br>            GL.BindTexture(TextureTarget.Texture2D, handle);<br><br>            <span class="hljs-comment">// For this example, we&#x27;re going to use .NET&#x27;s built-in System.Drawing library to load textures.</span><br><br>            <span class="hljs-comment">// OpenGL has it&#x27;s texture origin in the lower left corner instead of the top left corner,</span><br>            <span class="hljs-comment">// so we tell StbImageSharp to flip the image when loading.</span><br>            StbImage.stbi_set_flip_vertically_on_load(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// Here we open a stream to the file and pass it to StbImageSharp to load.</span><br>            <span class="hljs-keyword">using</span> (Stream stream = File.OpenRead(path))<br>            &#123;<br>                ImageResult image = ImageResult.FromStream(stream, ColorComponents.RedGreenBlueAlpha);<br><br>                <span class="hljs-comment">// Now that our pixels are prepared, it&#x27;s time to generate a texture. We do this with GL.TexImage2D.</span><br>                <span class="hljs-comment">// Arguments:</span><br>                <span class="hljs-comment">//   The type of texture we&#x27;re generating. There are various different types of textures, but the only one we need right now is Texture2D.</span><br>                <span class="hljs-comment">//   Level of detail. We can use this to start from a smaller mipmap (if we want), but we don&#x27;t need to do that, so leave it at 0.</span><br>                <span class="hljs-comment">//   Target format of the pixels. This is the format OpenGL will store our image with.</span><br>                <span class="hljs-comment">//   Width of the image</span><br>                <span class="hljs-comment">//   Height of the image.</span><br>                <span class="hljs-comment">//   Border of the image. This must always be 0; it&#x27;s a legacy parameter that Khronos never got rid of.</span><br>                <span class="hljs-comment">//   The format of the pixels, explained above. Since we loaded the pixels as RGBA earlier, we need to use PixelFormat.Rgba.</span><br>                <span class="hljs-comment">//   Data type of the pixels.</span><br>                <span class="hljs-comment">//   And finally, the actual pixels.</span><br>                GL.TexImage2D(TextureTarget.Texture2D, <span class="hljs-number">0</span>, PixelInternalFormat.Rgba, image.Width, image.Height, <span class="hljs-number">0</span>, PixelFormat.Rgba, PixelType.UnsignedByte, image.Data);<br>            &#125;<br><br>            <span class="hljs-comment">// Now that our texture is loaded, we can set a few settings to affect how the image appears on rendering.</span><br><br>            <span class="hljs-comment">// First, we set the min and mag filter. These are used for when the texture is scaled down and up, respectively.</span><br>            <span class="hljs-comment">// Here, we use Linear for both. This means that OpenGL will try to blend pixels, meaning that textures scaled too far will look blurred.</span><br>            <span class="hljs-comment">// You could also use (amongst other options) Nearest, which just grabs the nearest pixel, which makes the texture look pixelated if scaled too far.</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The default settings for both of these are LinearMipmap. If you leave these as default but don&#x27;t generate mipmaps,</span><br>            <span class="hljs-comment">// your image will fail to render at all (usually resulting in pure black instead).</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (<span class="hljs-built_in">int</span>)TextureMinFilter.Linear);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (<span class="hljs-built_in">int</span>)TextureMagFilter.Linear);<br><br>            <span class="hljs-comment">// Now, set the wrapping mode. S is for the X axis, and T is for the Y axis.</span><br>            <span class="hljs-comment">// We set this to Repeat so that textures will repeat when wrapped. Not demonstrated here since the texture coordinates exactly match</span><br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br>            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (<span class="hljs-built_in">int</span>)TextureWrapMode.Repeat);<br><br>            <span class="hljs-comment">// Next, generate mipmaps.</span><br>            <span class="hljs-comment">// Mipmaps are smaller copies of the texture, scaled down. Each mipmap level is half the size of the previous one</span><br>            <span class="hljs-comment">// Generated mipmaps go all the way down to just one pixel.</span><br>            <span class="hljs-comment">// OpenGL will automatically switch between mipmaps when an object gets sufficiently far away.</span><br>            <span class="hljs-comment">// This prevents moiré effects, as well as saving on texture bandwidth.</span><br>            <span class="hljs-comment">// Here you can see and read about the morié effect https://en.wikipedia.org/wiki/Moir%C3%A9_pattern</span><br>            <span class="hljs-comment">// Here is an example of mips in action https://en.wikipedia.org/wiki/File:Mipmap_Aliasing_Comparison.png</span><br>            GL.GenerateMipmap(GenerateMipmapTarget.Texture2D);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Texture(handle);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Texture</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> glHandle</span>)</span><br>        &#123;<br>            Handle = glHandle;<br>        &#125;<br><br>        <span class="hljs-comment">// Activate texture</span><br>        <span class="hljs-comment">// Multiple textures can be bound, if your shader needs more than just one.</span><br>        <span class="hljs-comment">// If you want to do that, use GL.ActiveTexture to set which slot GL.BindTexture binds to.</span><br>        <span class="hljs-comment">// The OpenGL standard requires that there be at least 16, but there can be more depending on your graphics card.</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>(<span class="hljs-params">TextureUnit unit</span>)</span><br>        &#123;<br>            GL.ActiveTexture(unit);<br>            GL.BindTexture(TextureTarget.Texture2D, Handle);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.cs-1">Shader.cs</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> OpenTK.Graphics.OpenGL;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">OpenTKTest</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shader</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Handle &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; _uniformLocations;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Shader</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> vertexPath, <span class="hljs-built_in">string</span> fragmentPath</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">string</span> VertexShaderSource = File.ReadAllText(vertexPath);<br>            <span class="hljs-built_in">int</span> vertexShader = GL.CreateShader(ShaderType.VertexShader);<br>            GL.ShaderSource(vertexShader, VertexShaderSource);<br>            GL.CompileShader(vertexShader);<br><br><br>            <span class="hljs-built_in">string</span> FragmentShaderSource = File.ReadAllText(fragmentPath);<br>            <span class="hljs-built_in">int</span> fragmentShader = GL.CreateShader(ShaderType.FragmentShader);<br>            GL.ShaderSource(fragmentShader, FragmentShaderSource);<br>            GL.CompileShader(fragmentShader);<br><br>            <span class="hljs-comment">// Create shader program and link shaders</span><br>            Handle = GL.CreateProgram();<br>            GL.AttachShader(Handle, vertexShader);<br>            GL.AttachShader(Handle, fragmentShader);<br>            GL.LinkProgram(Handle);<br><br>            <span class="hljs-comment">// Clean up individual shaders</span><br>            GL.DetachShader(Handle, vertexShader);<br>            GL.DetachShader(Handle, fragmentShader);<br>            GL.DeleteShader(fragmentShader);<br>            GL.DeleteShader(vertexShader);<br><br>            GL.GetProgram(Handle, GetProgramParameterName.ActiveUniforms, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> numberOfUniforms);<br>            _uniformLocations = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;();<br><br>            <span class="hljs-comment">// Loop over all the uniforms,</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; numberOfUniforms; i++)<br>            &#123;<br>                <span class="hljs-comment">// get the name of this uniform,</span><br>                <span class="hljs-keyword">var</span> key = GL.GetActiveUniform(Handle, i, <span class="hljs-keyword">out</span> _, <span class="hljs-keyword">out</span> _);<br><br>                <span class="hljs-comment">// get the location,</span><br>                <span class="hljs-keyword">var</span> location = GL.GetUniformLocation(Handle, key);<br><br>                <span class="hljs-comment">// and then add it to the dictionary.</span><br>                _uniformLocations.Add(key, location);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Use</span>()</span><br>        &#123;<br>            GL.UseProgram(Handle);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetInt</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> data</span>)</span><br>        &#123;<br>            GL.UseProgram(Handle);<br>            GL.Uniform1(_uniformLocations[name], data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.vert-1">shader.vert</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPosition;<br><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoord;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>)<br>&#123;<br>    texCoord = aTexCoord;<br><br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shader.frag-1">shader.frag</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330</span><br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> outputColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> texCoord;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture0;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture1;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    outputColor = <span class="hljs-built_in">mix</span>(<span class="hljs-built_in">texture</span>(texture0, texCoord), <span class="hljs-built_in">texture</span>(texture1, texCoord), <span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变换">变换</h2><p>我们已经知道如何创建对象，给它们上色和/或使用纹理给它们赋予详细的外观，但它们仍然不那么有趣，因为它们都是静态对象。我们可以尝试通过改变它们的顶点并重新配置它们的缓冲区来使它们移动，但这很麻烦，而且会消耗大量的处理能力。有更好的方法来转换对象，那就是使用（多个）矩阵对象。</p><p>矩阵是非常强大的数学构造，起初似乎令人望而生畏，但一旦你逐渐习惯了它们，它们将证明极其有用。当讨论矩阵时，我们将不得不对一些数学进行简要的探讨，对于更倾向于数学的读者，我将提供进一步阅读的额外资源。</p><p>然而，要完全理解变换，我们首先必须在讨论矩阵之前深入了解一些向量。本章的重点是为您提供我们以后需要的基本数学背景。如果这些主题很难，尽量理解它们，以后需要时随时回到本页面复习概念。</p><p>对上一节的图片进行旋转和缩放</p><p>首先引入<code>using OpenTK.Mathematics;</code></p><p>glControl1_Paint:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> transform = Matrix4.Identity;<br>transform = transform * Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(<span class="hljs-number">90.0f</span>));<br>transform = transform * Matrix4.CreateScale(<span class="hljs-number">1.1f</span>);<br>transform = transform * Matrix4.CreateTranslation(<span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>);<br></code></pre></td></tr></table></figure><p>这段代码是使用OpenGL数学库进行矩阵变换的示例。让我解释一下每一步的含义：</p><ol type="1"><li><p><code>Matrix4.Identity</code>:这是一个单位矩阵，表示没有任何变换。它是一个4x4的矩阵，对角线上的元素为1，其余为0。</p></li><li><p><code>Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(90.0f))</code>:这一行代码创建了一个绕着Z轴旋转90度的旋转矩阵。<code>MathHelper.DegreesToRadians()</code>是一个函数，用于将角度转换为弧度，因为大多数数学库使用弧度来表示角度。</p></li><li><p><code>Matrix4.CreateScale(1.1f)</code>:这一行代码创建了一个缩放矩阵，将对象沿着X、Y和Z方向各放大1.1倍。这意味着对象在每个方向上都会增加10%的大小。</p></li><li><p><code>Matrix4.CreateTranslation(0.1f, 0.1f, 0.1f)</code>:最后一行代码创建了一个平移矩阵，将对象沿着X、Y和Z方向各移动0.1个单位。</p></li></ol><p>在这些操作之后，<code>transform</code>矩阵将包含所有这些变换的组合。如果将这个矩阵应用到对象的顶点上，对象就会按照这些变换进行旋转、缩放和平移。</p><p>剩下看官方代码</p><h2 id="坐标系">坐标系</h2><p>在上节中，我们学习了如何利用矩阵通过转换矩阵来转换所有顶点。OpenGL希望在每次顶点着色器运行后，我们希望变得可见的所有顶点都位于归一化设备坐标中。也就是说，每个顶点的x、y和z坐标应该在-1.0和1.0之间；超出此范围的坐标将不可见。我们通常做的是在一个我们自己配置的范围内指定坐标，并在顶点着色器中将这些坐标转换为NDC。然后将这些NDC坐标传递给光栅化器，以将它们转换为屏幕上的2D坐标/像素。</p><p>将坐标转换为NDC，然后转换为屏幕坐标通常是逐步完成的，我们将一个对象的顶点转换为几个坐标系统，最后将它们转换为屏幕坐标。将它们转换为几个中间坐标系统的优点是，某些操作/计算在特定坐标系统中更容易，这很快就会变得明显。对我们来说，共有5种不同的重要坐标系统：</p><ol type="1"><li>局部空间（或对象空间）</li><li>世界空间</li><li>观察空间（或眼睛空间）</li><li>裁剪空间</li><li>屏幕空间</li></ol><p>在最终成为片段之前，这些坐标系统中的每一个都是顶点将被转换为的不同状态。</p><p>您现在可能对空间或坐标系统到底是什么感到困惑，所以我们将以更易于理解的方式解释它们，通过展示整体图像和每个特定空间实际执行的操作。</p><h3 id="全局视角">全局视角</h3><p>为了将一个坐标空间中的坐标转换到下一个坐标空间中，我们将使用几个变换矩阵，其中最重要的是模型（Model）、视图（View）和投影（Projection）矩阵。我们的顶点坐标首先从局部空间开始作为局部坐标，然后进一步转换为世界坐标、观察坐标、裁剪坐标，最终以屏幕坐标结束。下图展示了这个过程，并显示了每个转换的作用：</p><p><img src="8-coordinate_systems.png" /></p><ol type="1"><li><p>局部坐标是相对于对象的局部原点的坐标；它们是对象起始的坐标。</p></li><li><p>接下来的步骤是将局部坐标转换为世界空间坐标，这些坐标是相对于更大的世界的坐标。这些坐标是相对于世界的全局原点的，与许多其他对象一起放置在相对于世界原点的位置。</p></li><li><p>接下来，我们将世界坐标转换为视图空间坐标，以使每个坐标都是从摄像机或观察者的视角看到的。</p></li><li><p>当坐标处于视图空间时，我们希望将它们投影到裁剪坐标中。裁剪坐标被处理为-1.0和1.0的范围，并确定哪些顶点将出现在屏幕上。</p></li><li><p>最后，我们将裁剪坐标转换为屏幕坐标，这个过程称为视口变换，它将坐标从-1.0和1.0转换为由GL.Viewport定义的坐标范围。然后，得到的坐标被发送到光栅化器，将它们转换为片段。</p></li></ol><p>你可能已经对每个单独的空间有了一些了解。我们将顶点转换为所有这些不同的空间的原因是，某些操作在特定坐标系统中更有意义或更容易使用。例如，当修改对象时，在局部空间中进行修改是最合理的，而在世界坐标系中计算与其他对象位置相关的某些操作是最合理的，依此类推。如果我们愿意，我们可以定义一个从局部空间到裁剪空间的转换矩阵，但这样会给我们留下更少的灵活性。</p><p>我们将在下面更详细地讨论每个坐标系。</p><h4 id="局部空间">局部空间</h4><p>局部空间是与你的对象相关的坐标空间，即你的对象起始的地方。想象一下，你在建模软件（如Blender）中创建了一个立方体。你的立方体的原点可能在（0,0,0），即使你的立方体最终可能在你的最终应用程序中位于不同的位置。你创建的所有模型的初始位置可能都是（0,0,0）。因此，你模型的所有顶点都在局部空间中：它们都是相对于你的对象的局部坐标。</p><p>我们使用的容器的顶点被指定为介于-0.5和0.5之间的坐标，以0.0作为原点。这些是局部坐标。</p><h4 id="世界空间">世界空间</h4><p>如果我们直接将所有的对象导入应用程序中，它们可能都堆叠在世界原点（0,0,0）附近，这不是我们想要的。我们希望为每个对象定义一个位置，将它们放置在一个更大的世界中。世界空间中的坐标正是它们听起来的样子：所有顶点相对于（游戏）世界的坐标。这是一个坐标空间，你希望将你的对象转换到这个空间中，以使它们分散在各个地方（最好以一种真实的方式）。你的对象的坐标是从局部空间转换到世界空间的；这是通过模型矩阵完成的。</p><p>模型矩阵是一个转换矩阵，可以平移、缩放和/或旋转你的对象，将其放置在世界中的一个位置/方向上。可以将其想象为通过缩小房屋（在局部空间中有点太大了）、将其平移到郊区城镇并在y轴上稍微向左旋转一点，以便它与邻近的房屋整齐地配合。你也可以将前面教程中的矩阵想象成一种模型矩阵，用于将容器的局部坐标转换到场景/世界中的某个不同位置。</p><h4 id="视图空间">视图空间</h4><p>视图空间通常被称为OpenGL的摄像机（有时也称为相机空间或眼睛空间）。视图空间是将世界空间坐标转换为位于用户视图前方的坐标的结果。因此，视图空间就是从摄像机视角看到的空间。通常通过一系列平移和旋转来实现视图空间的转换，以便将某些物体转换到摄像机前面。这些组合的变换通常存储在一个视图矩阵中，该矩阵将世界坐标转换为视图空间。在下一个教程中，我们将详细讨论如何创建这样一个视图矩阵来模拟一个摄像机。</p><h4 id="剪裁空间">剪裁空间</h4><p>在每次顶点着色器运行结束时，OpenGL期望坐标位于特定范围内，任何超出此范围的坐标都将被裁剪。被裁剪的坐标将被丢弃，因此剩下的坐标将成为在屏幕上可见的片段。这也是裁剪空间得名的原因。</p><p>由于将所有可见坐标指定为范围-1.0和1.0并不直观，我们会指定我们自己的坐标集并将其转换回NDC，因为OpenGL期望它们是NDC。</p><p>为了将顶点坐标从视图空间转换为裁剪空间，我们定义了一个称为投影矩阵的矩阵，该矩阵指定了每个维度中的坐标范围，例如-1000和1000。然后，投影矩阵将在指定范围内的坐标转换为规范化设备坐标（-1.0，1.0）。所有超出此范围的坐标将不会映射到-1.0和1.0之间，因此将被裁剪。对于我们在投影矩阵中指定的范围，例如坐标（1250，500，750）将不可见，因为x坐标超出了范围，因此会转换为NDC中大于1.0的坐标，因此被裁剪。</p><blockquote><p>请注意，如果一个图元的一部分（例如一个三角形）超出了裁剪体积，OpenGL将重构该三角形为一个或多个三角形，以适应裁剪范围内。</p></blockquote><p>投影矩阵创建的视图框称为视锥体，位于该视锥体内的每个坐标将出现在用户的屏幕上。将坐标从指定范围转换为NDC并映射到2D视图空间坐标的整个过程称为投影，因为投影矩阵将3D坐标投影到易于映射到2D规范化设备坐标的坐标。</p><p>一旦所有顶点转换为裁剪空间，将执行最终操作，称为透视除法，其中我们将位置向量的x、y和z分量除以向量的齐次w分量；透视除法是将4D裁剪空间坐标转换为3D规范化设备坐标。这一步在每次顶点着色器运行结束时自动执行。</p><p>在这个阶段之后，将结果坐标映射到屏幕坐标（使用glViewport的设置），并转换为片段。</p><p>将视图坐标转换为裁剪坐标的投影矩阵可以采用两种不同形式，每种形式定义了自己独特的视锥体。我们可以创建正交投影矩阵或透视投影矩阵。</p><h3 id="正交投影">正交投影</h3><p>正交投影矩阵定义了一个立方体般的视锥体，它定义了剪裁空间，其中每个顶点在此盒子外部都会被裁剪。创建正交投影矩阵时，我们指定可见视锥体的宽度、高度和长度。在使用正交投影矩阵将坐标转换为裁剪空间后，所有落入此视锥体内部的坐标都不会被裁剪。视锥体看起来有点像一个容器：</p><p><img src="8-orthographic_frustum.png" /></p><p>视锥体定义了可见坐标，并由宽度、高度和近平面和远平面来指定。任何位于近平面前面的坐标都会被裁剪，对于位于远平面后面的坐标也是一样。正交投影视锥体直接将视锥体内的所有坐标映射到规范化设备坐标，因为每个向量的w分量保持不变；如果w分量等于1.0，则透视除法不会改变坐标。</p><p>要创建一个正交投影矩阵，我们使用<code>OpenTK</code>的<code>CreateOrthographicOffCenter</code>方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4.CreateOrthographicOffCenter(<span class="hljs-number">0.0f</span>, <span class="hljs-number">800.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">600.0f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure><p>前两个参数指定了视锥体的左边界和右边界，第三和第四个参数指定了视锥体的底部和顶部。通过这4个点，我们定义了近平面和远平面的大小，然后第5和第6个参数定义了近平面和远平面之间的距离。这个特定的投影矩阵将所有在这些x、y和z范围值之间的坐标转换为规范化设备坐标。</p><p>正交投影矩阵直接将坐标映射到您屏幕的2D平面，但实际上，直接投影会产生不真实的结果，因为投影不考虑透视。这就是透视投影矩阵为我们修正的内容。</p><h3 id="透视投影">透视投影</h3><p>如果你曾经欣赏过现实生活中的图形，你会注意到远处的物体看起来要小得多。这种奇怪的效果是我们所谓的透视。透视在望着无限公路或铁路的尽头时尤为明显，就像下面的图片所示：</p><p><img src="8-perspective.png" /></p><p>正如你所看到的，由于透视，线条在远处似乎重合。透视投影正是试图模仿这种效果，它使用透视投影矩阵来实现。投影矩阵将给定的视锥体范围映射到裁剪空间，但也以一种方式操纵每个顶点坐标的w值，使得离观察者越远的顶点坐标，其w分量越高。一旦坐标被转换到裁剪空间，它们就位于-w到w的范围内（范围之外的任何坐标都会被裁剪）。OpenGL要求可见坐标必须落在-1.0到1.0的范围内，作为最终顶点着色器的输出，因此一旦坐标位于裁剪空间中，透视除法就会应用到裁剪空间坐标上：<span class="math display">\[out=\begin{pmatrix}x/w\\y/w\\z/w\end{pmatrix}\]</span>每个顶点坐标的每个分量都被它的w分量除以，使得顶点距离观察者越远，顶点坐标就越小。这也是为什么w分量很重要的另一个原因，因为它帮助我们进行透视投影。得到的坐标随后处于规范化设备空间中。如果你有兴趣弄清楚正交投影和透视投影矩阵是如何实际计算的（并且不怕数学），我可以推荐这篇由Songho撰写的优秀文章。</p><p>在OpenTK中可以使用以下方式创建透视投影矩阵：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(<span class="hljs-number">45.0f</span>), (<span class="hljs-built_in">float</span>)width / (<span class="hljs-built_in">float</span>)height, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure><p>这段代码创建了一个透视投影矩阵。它通过参数指定了一个大的视锥体，定义了可见空间，视锥体之外的任何东西都不会出现在裁剪空间中，因此会被裁剪掉。透视视锥体可以想象成一个非均匀形状的盒子，其中每个在这个盒子内部的坐标都会映射到裁剪空间中的一个点。下面是一个透视视锥体的图像：<code>Matrix4.CreatePerspectiveFieldOfView</code></p><p><img src="8-perspective_frustum.png" /></p><p>第一个参数定义了fovy值，代表视场角（y代表垂直轴，因此是垂直视场角），并设置了视景体的大小。为了获得逼真的视图，通常将其设置为45度，但如果想要更像《毁灭战士》（Doom）风格的结果，可以将其设置为更高的值。第二个参数设置了纵横比，通过将视口的宽度除以其高度来计算。第三个和第四个参数设置了视锥体的近平面和远平面。通常将近距离设置为0.1f，远距离设置为100.0f。在视锥体的近平面和远平面之间以及内部的所有顶点都将被渲染。</p><blockquote><p>当透视矩阵的近平面值设置得稍微过高（例如10.0f）时，OpenGL会裁剪所有靠近相机的坐标（在0.0f和10.0f之间），这在视频游戏中会产生一个熟悉的视觉效果，即如果你靠近某些物体，你可以看穿它们。</p></blockquote><p>在使用正交投影时，每个顶点坐标都直接映射到裁剪空间，没有任何复杂的透视除法（实际上仍然进行了透视除法，但w分量不受影响（保持为1），因此没有效果）。由于正交投影不使用透视投影，因此远处的物体看起来不会变小，这会产生一种奇怪的视觉效果。因此，正交投影主要用于2D渲染以及一些建筑或工程应用中，在这些应用中我们不希望顶点受到透视的扭曲。用于3D建模的应用程序（如Blender）有时会使用正交投影进行建模，因为它更准确地描绘了每个对象的尺寸。下面你会看到Blender中两种投影方法的比较：</p><p><img src="8-perspective_orthographic.png" /></p><p>你可以看到，使用透视投影时，远处的顶点看起来要小得多，而在正交投影中，每个顶点与用户的距离相同。</p><h3 id="结合起来">结合起来</h3><p>我们为前面提到的每个步骤创建一个变换矩阵：模型、视图和投影矩阵。然后，顶点坐标被转换为裁剪坐标，如下所示：<span class="math display">\[V_{clip}=M_{projection}\cdot M_{view}\cdot M_{model}\cdot V_{local}\]</span>请注意，矩阵乘法的顺序是相反的（记住我们需要从右向左阅读矩阵乘法）。然后，将得到的顶点分配给顶点着色器中的gl_Position，然后OpenGL将自动执行透视除法和裁剪。</p><blockquote><p>然后呢？顶点着色器的输出要求坐标在裁剪空间中，这就是我们刚刚通过变换矩阵完成的。OpenGL然后对裁剪空间坐标执行透视除法，将它们转换为标准化设备坐标。然后，OpenGL使用GL.Viewport的参数将标准化设备坐标映射到屏幕坐标，在这里，每个坐标对应屏幕上的一个点（在我们的情况下是800x600屏幕）。这个过程被称为视口变换。</p></blockquote><p>这是一个难以理解的话题，所以如果你对每个空间的具体用途仍然不太清楚，也不必担心。在接下来的教程中，我们将看到如何实际运用这些坐标空间，并且会有足够的示例跟随在这些教程中。</p><h3 id="前往3d">前往3D</h3><p>现在我们知道如何将 3D 坐标转换为 2D坐标，我们可以开始展示我们的对象作为真正的 3D对象，而不是到目前为止我们一直展示的平淡的 2D 平面。</p><p>为了开始绘制 3D图形，我们首先创建一个模型矩阵。模型矩阵包括我们想要应用的平移、缩放和/或旋转，以将所有对象的顶点转换为全局世界空间。让我们通过绕x 轴旋转一下我们的平面，使其看起来好像躺在地板上。模型矩阵如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4 model = Matrix4.CreateRotationX(MathHelper.DegreesToRadians(<span class="hljs-number">-55.0f</span>));<br></code></pre></td></tr></table></figure><p>通过将顶点坐标与这个模型矩阵相乘，我们将顶点坐标转换为世界坐标。我们的平面略微位于地板上，因此代表了全局世界中的平面。</p><p>接下来，我们需要创建一个视图矩阵。我们想向后稍微移动场景，这样对象就变得可见（当在世界空间时，我们位于原点（0,0,0））。要在场景中移动，可以考虑以下内容：</p><ul><li>将相机向后移动，相当于将整个场景向前移动。</li></ul><p>这正是视图矩阵所做的，我们将整个场景向相机所在位置的反方向移动。因为我们想向后移动，而且由于OpenGL 是一个右手坐标系统，所以我们必须沿着正的 z 轴移动。我们通过沿着负z 轴平移场景来实现这一点。这会给人一种我们正在向后移动的印象。</p><blockquote><p>按照惯例，OpenGL 是一个右手坐标系统。这基本上意味着正 x轴在你的右边，正 y 轴向上，正 z 轴向后。想象一下，你的屏幕是 3个轴的中心，正 z 轴穿过屏幕朝向你。轴的方向如下所示：右手坐标系</p><p>要理解为什么它被称为右手坐标系，请按照以下步骤操作：</p><ol type="1"><li>将你的右手沿着正 y 轴伸展，手向上。</li><li>让你的大拇指指向右边。</li><li>让你的食指指向上方。</li><li>然后将你的中指向下弯曲 90 度。</li></ol><p>如果你做得对，你的大拇指应该指向正 x 轴，食指指向正 y 轴，中指指向正z 轴。如果你用左手这样做，你会发现 z轴是相反的。这被称为左手坐标系，DirectX通常使用它。请注意，在标准化设备坐标中，OpenGL实际上使用左手坐标系（投影矩阵会切换坐标系的左右性）。</p></blockquote><p>我们将在下一篇教程中更详细地讨论如何在场景中移动。目前，视图矩阵如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 注意我们将场景向我们想要移动的反方向进行平移。</span><br>Matrix4 view = Matrix4.CreateTranslation(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-3.0f</span>);<br></code></pre></td></tr></table></figure><p>我们需要定义的最后一件事是投影矩阵。我们想要在场景中使用透视投影，因此我们将声明投影矩阵如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(<span class="hljs-number">45.0f</span>), Width / Height, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br></code></pre></td></tr></table></figure><p>现在我们已经创建了变换矩阵，我们应该将它们传递给我们的着色器。首先让我们在顶点着色器中将变换矩阵声明为uniform，并将它们与顶点坐标相乘：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br>...<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// 注意我们从右到左读取乘法</span><br>    <span class="hljs-built_in">gl_Position</span> =  <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>) * model * view * projection;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还应该将矩阵发送到着色器中（通常在每次渲染迭代中执行，因为变换矩阵往往会经常变化）：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">shader.SetMatrix4(<span class="hljs-string">&quot;model&quot;</span>, model);<br>shader.SetMatrix4(<span class="hljs-string">&quot;view&quot;</span>, view);<br>shader.SetMatrix4(<span class="hljs-string">&quot;projection&quot;</span>, projection);<br></code></pre></td></tr></table></figure><p>现在，我们的顶点坐标经过了模型、视图和投影矩阵的变换，最终对象应该是：</p><p>向后倾斜，靠在地板上。 离我们有一点远。以透视方式显示（随着顶点越来越远，它应该变小）。让我们检查一下结果是否确实满足了这些要求：</p><h2 id="相机">相机</h2><p>在之前的教程中，我们讨论了视图矩阵以及如何使用视图矩阵在场景中移动（我们稍微向后移动了一点）。OpenGL本身并不熟悉摄像机的概念，但我们可以尝试通过将场景中的所有物体向相反方向移动来模拟摄像机，从而产生我们在移动的错觉。</p><p>在本教程中，我们将讨论如何在OpenGL中设置摄像机。我们将讨论一种FPS风格的摄像机，它允许您在3D场景中自由移动。在本教程中，我们还将讨论键盘和鼠标输入，并以一个自定义摄像机类结束。</p><h3 id="相机视图空间">相机/视图空间</h3><p>当我们谈论相机/视图空间时，我们指的是从相机的角度来看所有顶点坐标，相机被视为场景的原点：视图矩阵将所有世界坐标转换为相对于相机位置和方向的视图坐标。要定义一个相机，我们需要它在世界空间中的位置、它所看的方向，以及从相机指向右侧和向上的向量。一个细心的读者可能会注意到，实际上我们要创建一个由相机位置作为原点的具有三个垂直单位轴的坐标系。</p><p><img src="9-camera_axes.png" /></p><h4 id="位置">位置</h4><p>获取相机位置很容易。相机位置基本上是世界空间中指向相机位置的向量。我们将相机设置在上一个教程中设置的相同位置：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 Position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">3.0f</span>);<br></code></pre></td></tr></table></figure><p>不要忘记，正z轴穿过屏幕指向您，因此如果我们希望相机向后移动，我们沿着正z轴移动。</p><h4 id="相机方向">相机方向</h4><p>下一个所需的向量是相机的方向，即它指向的方向。目前，我们让相机指向我们场景的原点：(0,0,0)。记住，如果我们从彼此中减去两个向量，我们得到的是这两个向量的差向量？因此，从场景原点向量中减去相机位置向量得到方向向量。由于我们知道相机指向负z方向，我们希望方向向量指向相机的正z轴。如果我们交换减法顺序，我们现在得到一个指向相机正z轴的向量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 cameraTarget = Vector3.Zero;<br>Vector3 cameraDirection = Vector3.Normalize(cameraPos - cameraTarget);<br></code></pre></td></tr></table></figure><p>“方向向量”这个名称并不是最合适的选择，因为实际上它指向的是与其目标相反的方向。</p><h4 id="右轴">右轴</h4><p>我们需要的下一个向量是一个右向量，表示相机空间的正x轴。为了获得右向量，我们使用一个小技巧，首先指定一个指向上方的上向量（在世界空间中）。然后，我们对上向量和第2步中的方向向量进行叉乘。由于叉乘的结果是两个向量的垂直向量，我们将得到一个指向正x轴方向的向量（如果我们交换向量，我们将得到一个指向负x轴的向量）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 up = Vector3.UnitY;<br>Vector3 cameraRight = Vector3.Normalize(Vector3.Cross(up, cameraDirection));<br></code></pre></td></tr></table></figure><h4 id="上轴">上轴</h4><p>现在我们有了x轴向量和z轴向量，获取指向相机正y轴的向量相对较容易：我们对右向量和方向向量进行叉乘：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Vector3 cameraUp = Vector3.Cross(cameraDirection, cameraRight);<br></code></pre></td></tr></table></figure><p>通过使用叉乘和一些技巧，我们能够创建形成视图/相机空间的所有向量。对于数学倾向的读者来说，这个过程在线性代数中被称为Gram-Schmidt过程。使用这些相机向量，我们现在可以创建一个非常有用的LookAt矩阵来创建相机。</p><h3 id="lookat">LookAt</h3><p>矩阵的一个伟大之处在于，如果你使用3个垂直（或非线性）的轴定义了一个坐标空间，你可以创建一个包含这3个轴加上一个平移向量的矩阵，通过与该矩阵相乘，你可以将任何向量转换到该坐标空间。这正是LookAt矩阵的作用，现在我们有了3个垂直的轴和一个位置向量来定义相机空间，我们可以创建自己的LookAt矩阵：<span class="math display">\[LookAt=\begin{bmatrix}R_x&amp;R_y&amp;R_z&amp;0\\U_x&amp;U_y&amp;U_z&amp;0\\D_x&amp;D_y&amp;D_z&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix}*\begin{bmatrix}1&amp;0&amp;0&amp;-P_x\\0&amp;1&amp;0&amp;-P_y\\0&amp;0&amp;1&amp;-P_z\\0&amp;0&amp;0&amp;1\\\end{bmatrix}\]</span>其中，R是右向量，U是上向量，D是方向向量，P是相机的位置向量。请注意，位置向量是反转的，因为我们最终希望将世界向相反方向移动。使用这个LookAt矩阵作为我们的视图矩阵有效地将所有世界坐标转换为我们刚刚定义的视图空间。LookAt矩阵的作用正是它的名字所描述的：它创建一个指向给定目标的视图矩阵。</p><p>幸运的是，OpenTK已经为我们完成了所有这些工作。我们只需要指定相机位置、目标位置和一个在世界空间中表示上向量的向量（我们用于计算右向量的上向量）。OpenTK然后创建我们可以用作视图矩阵的LookAt矩阵：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">Matrix4 view = Matrix4.LookAt(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">3.0f</span>), <br>       <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>),<br>                        <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>));<br></code></pre></td></tr></table></figure><p><code>Matrix4.LookAt</code>函数分别需要位置、目标和上向量。这将创建一个与上一教程中使用的视图矩阵相同的视图矩阵。</p><h3 id="走动">走动</h3><p>现在是时候实际处理一些玩家输入并使我们的窗口响应了！首先，我们需要设置一个摄像机系统，因此在程序的顶部定义一些摄像机变量会很有用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">float</span> speed = <span class="hljs-number">1.5f</span>;<br><br>Vector3 position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">3.0f</span>);<br>Vector3 front = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-1.0f</span>);<br>Vector3 up = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,  <span class="hljs-number">0.0f</span>);<br></code></pre></td></tr></table></figure><p>在这里，我们引入了一个新的变量，以及用于LookAt函数的变量。speed变量将帮助我们定义相机移动时的速度。现在，LookAt函数变为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">view = Matrix4.LookAt(position, position + front, up);<br></code></pre></td></tr></table></figure><p>首先，我们将相机位置设置为之前定义的Position。方向是当前位置加上我们刚刚定义的方向向量。这确保了无论我们如何移动，相机都会保持朝向目标方向。让我们通过在按下某些键时更新Position向量来稍微调整这些变量。</p><p>我们已经看过如何在OnUpdateFrame函数中获取用户输入，现在我们可以扩展此功能以移动相机。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdateFrame</span>(<span class="hljs-params">FrameEventArgs e</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!IsFocused) <span class="hljs-comment">// check to see if the window is focused</span><br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    KeyboardState input = KeyboardState;<br><br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.W))<br>    &#123;<br>        position += front * speed; <span class="hljs-comment">//Forward </span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.S))<br>    &#123;<br>        position -= front * speed; <span class="hljs-comment">//Backwards</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.A))<br>    &#123;<br>        position -= Vector3.Normalize(Vector3.Cross(front, up)) * speed; <span class="hljs-comment">//Left</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.D))<br>    &#123;<br>        position += Vector3.Normalize(Vector3.Cross(front, up)) * speed; <span class="hljs-comment">//Right</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.Space))<br>    &#123;<br>        position += up * speed; <span class="hljs-comment">//Up </span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (input.IsKeyDown(Keys.LeftShift))<br>    &#123;<br>        position -= up * speed; <span class="hljs-comment">//Down</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>请注意，在顶部我们还检查窗口是否获得焦点，如果没有，就返回，这样可以避免窗口不在焦点时出现问题。</p></blockquote><p>每当我们按下WASD键中的一个时，相机的位置会相应地更新。如果我们想向前或向后移动，就会从位置向量中加或减去前向量。如果我们想侧向移动，我们会进行叉乘以创建一个右向量，并相应地沿着右向量移动。这样就产生了使用相机时熟悉的横向移动效果。此外，我们还添加了上升（空格键）或下降（LShift键）的功能，这与上升和下降相同，只是作用于上向量而不是前向量。</p><p>请注意，我们对结果右向量进行了归一化处理。如果我们不对该向量进行归一化处理，叉乘的结果可能会基于前变量而返回不同大小的向量。如果我们不对该向量进行归一化处理，我们移动的速度将取决于相机的方向，而不是保持一致的移动速度。</p><p>到目前为止，您应该已经能够以一种在不同系统中速度可能略有不同但您可能需要调整的速度移动相机了。</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenTK</tag>
      
      <tag>OpenGL</tag>
      
      <tag>图像渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/2024/01/23/git/"/>
    <url>/2024/01/23/git/</url>
    
    <content type="html"><![CDATA[<h1 id="配置">配置</h1><p>设置代理：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> http.proxy http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">1184</span><br>git config <span class="hljs-literal">--global</span> https.proxy http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">1184</span><br></code></pre></td></tr></table></figure><p>其中<code>1184</code>是本机代理的端口号</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WSL指南</title>
    <link href="/2023/11/07/WSL%E6%8C%87%E5%8D%97/"/>
    <url>/2023/11/07/WSL%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="wsl">WSL</h1><ul><li><strong>Windows Subsystem for Linux</strong></li><li>微软自己出的一个系统支持比较好的能在windows环境下打开的linux系统</li></ul><h2 id="常用命令">常用命令</h2><blockquote><ul><li>将终端关闭，WSL系统并不会关闭，需要手动进行关闭</li><li>每个终端没有权限直接操作内核关机，例如在shutdown命令或是reboot命令是不被允许的</li></ul></blockquote><ul><li>关闭所有版本（分发）的虚拟机</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--shutdown</span><br></code></pre></td></tr></table></figure><ul><li>关闭指定版本（分发）的虚拟机</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">-t</span> &lt;分发&gt;<br></code></pre></td></tr></table></figure><ul><li>查看当前所有分发虚拟机的状态</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">-l</span> <span class="hljs-literal">--all</span> <span class="hljs-literal">-v</span><br></code></pre></td></tr></table></figure><ul><li>设定默认打开的虚拟机</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">-s</span> &lt;分发&gt;<br></code></pre></td></tr></table></figure><ul><li>导出虚拟机分发至一个指定路径</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--export</span> &lt;分发&gt; &lt;储存包路径&gt;<br></code></pre></td></tr></table></figure><ul><li>导入虚拟机分发至一个指定路径</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--import</span> &lt;分发名字&gt; &lt;安装位置&gt; &lt;储存包路径&gt;  <span class="hljs-literal">--version</span> &lt;wsl版本&gt;<br></code></pre></td></tr></table></figure><ul><li>注销分发并删除根文件系统</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--unregister</span> &lt;分发&gt;<br></code></pre></td></tr></table></figure><h2 id="迁移">迁移</h2><ul><li>在<code>Microsoft Store</code>中下载的系统，默认存储在C盘中，占用较大内存空间</li><li>步骤如下：<ol type="1"><li>通过<code>wsl -l --running</code>查看正在运行的子系统</li><li>若有正在运行的子系统，则通过<code>wsl -t &lt;DistributionName&gt;</code>来终止其运行</li><li>利用<code>wsl --export &lt;DistributionName&gt; &lt;FileName&gt;</code>来备份子系统，结果会得到一个<code>tar</code>归档文件。<ul><li>假设有名为<code>Ubuntu-20.04</code>的子系统，想要将结果文件保存为<code>Ubuntu2004.tar</code>（同时指定其路径即为<code>D:\wsl\Ubuntu2004.tar</code>），则调用的命令为<code>wsl --export Ubuntu-20.04 D:\wsl\Ubuntu2004.tar</code></li></ul></li><li>使用<code>wsl --unregister Ubuntu-20.04</code>注销原始子系统。</li><li>然后利用<code>wsl --import &lt;DistributionName&gt; &lt;InstallLocation&gt; &lt;FileName&gt;</code>来恢复子系统。</li><li><code>ubuntu2004.exe config --default-user 用户名</code></li></ol></li></ul><p>配置代理https://blog.csdn.net/iftodayhappy/article/details/137236279</p><p>配置cudahttps://blog.csdn.net/weixin_43971236/article/details/134598022https://blog.csdn.net/iwanvan/article/details/122119595</p><p>多版本cuda问题https://blog.csdn.net/dhdhhy/article/details/130109501</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS进阶</title>
    <link href="/2023/11/04/ROS%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/11/04/ROS%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="ros-进阶">ROS 进阶</h1><h2 id="配置方法">配置方法</h2><ul><li><p>添加自定义头文件方式：<ahref="https://blog.csdn.net/qq_37945352/article/details/83303382">ROS中添加自定义头文件的方式_ros服务中添加自己包生成的头文件-CSDN博客</a></p></li><li><p>ROS中使用opencv方式：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(OpenCV REQUIRED)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">include</span> <span class="hljs-variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(opencv_test_node <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span> <span class="hljs-variable">$&#123;OpenCV_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="消息处理">消息处理</h2><h3 id="图像消息">图像消息</h3><ul><li><p><code>sensor_msgs/Image</code></p><ul><li><p>运行<code>rosmsg info sensor_msgs/Image</code>即可查看该消息的具体格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">std_msgs/Header header<br>  uint32 <span class="hljs-built_in">seq</span><br>  time stamp<br>  string frame_id<br>uint32 height<br>uint32 width<br>string encoding<br>uint8 is_bigendian<br>uint32 step<br>uint8[] data<br></code></pre></td></tr></table></figure></li><li><p><ahref="https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/Image.html">sensor_msgs/ImageDocumentation (ros.org)</a></p></li></ul></li><li><p>如果要使用<code>OpenCV</code>对图像进行处理，需要借助<code>cv_bridge</code>。CvBridge是一个ROS库，提供ROS和OpenCV之间的接口</p><ul><li><a href="http://wiki.ros.org/cv_bridge">cv_bridge - ROSWiki</a></li></ul></li></ul><h2 id="gazebo">Gazebo</h2><ul><li>在Gazebo中环境模型是以<code>.world</code>的文件进行保存</li><li>我们可以通过ros中的launch来启动加载world文件</li><li>在Gazebo中，机器人模型是通过URDF文件来描述的，URDF文件本质是xml格式</li><li>详见：<ahref="http://wiki.ros.org/urdf">http://wiki.ros.org/urdf</a></li><li><code>check_urdf mybot.urdf</code>检测urdf语法是否正确</li><li>我们可以通过ros中的launch来启动加载urdf文件</li><li>xacro文件是对urdf文件的补充，详见：<ahref="http://wiki.ros.org/xacro">xacro - ROS Wiki</a></li><li>gazebo插件：<ahref="https://classic.gazebosim.org/tutorials?tut=ros_gzplugins">Gazebo: Tutorial : Gazebo plugins in ROS (gazebosim.org)</a></li><li>gazebo标签的用法：https://classic.gazebosim.org/tutorials?tut=ros_urdf&amp;cat=connect_ros</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS基础入门</title>
    <link href="/2023/10/21/ROS%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2023/10/21/ROS%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="ros-安装">ROS 安装</h1><h2 id="操作系统">操作系统</h2><ul><li>使用 Ubuntu 系统<ul><li>虚拟机安装<ul><li>简单</li><li>硬件支持一般</li><li>初学者</li></ul></li><li>硬盘安装<ul><li>复杂</li><li>硬件支持好</li><li>有一定经验的开发者</li></ul></li></ul></li><li>系统版本匹配<ul><li>系统版本匹配参考：<ahref="http://wiki.ros.org/cn/ROS/Installation">cn/ROS/Installation - ROSWiki</a></li><li>采用版本：ROS Noetic Ninjemys + Ubuntu 20.04</li><li>建议在安装完操作系统后，制作一个快照，方便后期恢复初始系统</li></ul></li></ul><h2 id="编程语言">编程语言</h2><ul><li>在 Ros 中，采用 Python 和 C++ 两种语言进行开发，对 Python的支持可能不是特别完善。</li></ul><h3 id="安装-c-编译器和-python-解释器">安装 C++ 编译器和 Python解释器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install g++<br>sudo apt-get install python<br></code></pre></td></tr></table></figure><h2 id="安装ros">安装ROS</h2><ul><li><p>教程：<ahref="http://wiki.ros.org/cn/noetic/Installation/Ubuntu">cn/noetic/Installation/Ubuntu- ROS Wiki</a></p></li><li><p>安装 rosdep：<a href="http://wiki.ros.org/rosdep">rosdep - ROSWiki</a></p></li><li><p>测试安装成功，运行样例程序（以下三条命令运行在三个终端上）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">roscore<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun turtlesim turtlesim_node<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun turtlesim turtle_teleop_key<br></code></pre></td></tr></table></figure></li><li><p>至此 ROS 安装成功</p></li></ul><h1 id="ros-介绍">ROS 介绍</h1><ul><li><p>ROS = 通信机制 + 开发工具 + 应用功能 + 生态系统</p><ul><li>通信机制：松耦合分布式通信</li><li>开发工具：命令行、TF 坐标变换、Gazebo、Rviz、QT 工具箱</li><li>应用功能：很多</li><li>生态系统：<ul><li>发行版</li><li>软件源</li><li>ROS wiki：记录 ROS 信息文档的主要论坛</li><li>邮件列表</li><li>ROS Answers</li><li>博客：<ahref="http://www.ros.org/news">http://www.ros.org/news</a></li></ul></li></ul></li><li><p>节点 Node 和 节点管理器 ROS Master</p><ul><li>节点：执行单元<ul><li>执行具体任务的进行、独立运行的可执行文件</li><li>不同节点可使用不同的编程语言，可分布式运行在不同主机中</li><li>节点在系统中的名称必须是唯一的</li></ul></li><li>节点管理器：控制中心<ul><li>为节点提供命名和注册服务</li><li>跟踪和记录 话题 / 服务 通信，辅助结点相互查找、建立连接</li><li>提供参数服务器，节点使用此服务器存储和检索运行时的参数</li></ul></li></ul></li><li><p>话题 Topic：异步通信机制</p><ul><li>节点间用来传输数据的重要总线</li><li>使用<code>发布/订阅</code>模式，数据由发布者传输到订阅者，同一个话题的订阅者或发布者可以不唯一</li></ul></li><li><p>消息 Message：话题数据</p><ul><li>具有一定的类型和数据结构，包括 ROS提供的标准类型和用户自定义类型</li><li>使用编程语言无关的<code>.msg</code>文件定义，编译过程中生成对应的代码文件</li></ul></li><li><p>服务 Service：同步通信机制</p><ul><li>使用<code>客户端/服务器</code>模式，客户端发送请求数据，服务器完成处理后返回应答数据</li><li>使用编程语言无关的<code>.srv</code>文件定义请求和应答数据结构，编译过程中生成对应的代码文件</li></ul></li><li><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">话题</th><th style="text-align: center;">服务</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">同步性</td><td style="text-align: center;">异步</td><td style="text-align: center;">同步</td></tr><tr class="even"><td style="text-align: center;">通信模型</td><td style="text-align: center;">发布/订阅</td><td style="text-align: center;">客户端/服务器</td></tr><tr class="odd"><td style="text-align: center;">底层协议</td><td style="text-align: center;">ROSTCP/ROSUDP</td><td style="text-align: center;">ROSTCP/ROSUDP</td></tr><tr class="even"><td style="text-align: center;">反馈机制</td><td style="text-align: center;">无</td><td style="text-align: center;">有</td></tr><tr class="odd"><td style="text-align: center;">缓冲区</td><td style="text-align: center;">有</td><td style="text-align: center;">无</td></tr><tr class="even"><td style="text-align: center;">实时性</td><td style="text-align: center;">弱</td><td style="text-align: center;">强</td></tr><tr class="odd"><td style="text-align: center;">节点关系</td><td style="text-align: center;">多对多</td><td style="text-align: center;">一对多</td></tr><tr class="even"><td style="text-align: center;">使用场景</td><td style="text-align: center;">数据传输</td><td style="text-align: center;">逻辑处理</td></tr></tbody></table></li><li><p>参数 Parameter：全局共享字典</p><ul><li>可通过网络访问的共享、多变量字典</li><li>节点使用此服务器来存储和检索运行时的参数</li><li>适合存储静态、非二进制的配置参数，不适合存储动态配置的参数</li></ul></li><li><p>功能包 Package</p><ul><li>ROS 软件中的基本单元，包含节点源码、配置文件、数据定义等</li></ul></li><li><p>功能包清单 Package manifest</p><ul><li>记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等</li></ul></li><li><p>元功能包 Meta Packages</p><ul><li>组织多个用于同一目的功能包</li></ul></li></ul><h1 id="ros-操作">ROS 操作</h1><h2 id="命令行工具">命令行工具</h2><ul><li>常用命令<ul><li>rostopic</li><li>rosservice</li><li>rosnode</li><li>rosparam</li><li>rosmsg</li><li>rossrv</li><li>rosbag</li></ul></li></ul><h2 id="创建工作空间与功能包">创建工作空间与功能包</h2><ul><li><p>工作空间 workspace 是一个存放工程开发相关文件的文件夹</p><ul><li>src：代码空间</li><li>build：编译空间</li><li>devel：开发空间</li><li>install：安装空间</li></ul></li><li><p>创建工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/catkin_ws/src<br><span class="hljs-built_in">cd</span> ~/catkin_ws/src<br>catkin_init_workspace<br></code></pre></td></tr></table></figure></li><li><p>编译工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws/<br>catkin_make<br></code></pre></td></tr></table></figure></li><li><p>设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash<br></code></pre></td></tr></table></figure></li><li><p>检查环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$ROS_PACKAGE_PATH</span><br></code></pre></td></tr></table></figure></li><li><p>同一个工作空间下，不允许存在同名功能包。不同工作空间下，允许存在同名功能包。</p></li><li><p>创建功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws/src<br>catkin_create_pkg test_pkg std_msgs rospy roscpp<br></code></pre></td></tr></table></figure></li><li><p>编译功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws<br>catkin_make<br><span class="hljs-built_in">source</span> ~/catkin_ws/devel/setup.bash<br></code></pre></td></tr></table></figure></li></ul><h1 id="ros-编程开发">ROS 编程开发</h1><h2 id="发布者-publisher">发布者 Publisher</h2><h3 id="c-版本">C++ 版本</h3><ul><li><p>learning_topic/velocity_publisher.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/Twist.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ROS节点初始化</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;velocity_publisher&quot;</span>);<br><br><span class="hljs-comment">// 创建节点句柄</span><br>ros::NodeHandle n;<br><br><span class="hljs-comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span><br>ros::Publisher turtle_vel_pub = n.<span class="hljs-built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 设置循环的频率</span><br><span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>&#123;<br>    <span class="hljs-comment">// 初始化geometry_msgs::Twist类型的消息</span><br>geometry_msgs::Twist vel_msg;<br>vel_msg.linear.x = <span class="hljs-number">0.5</span>;<br>vel_msg.angular.z = <span class="hljs-number">0.2</span>;<br><br>    <span class="hljs-comment">// 发布消息</span><br>turtle_vel_pub.<span class="hljs-built_in">publish</span>(vel_msg);<br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, <br>vel_msg.linear.x, vel_msg.angular.z);<br><br>    <span class="hljs-comment">// 按照循环频率延时</span><br>    loop_rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>learning_topic/CMakeLists.txt</p><ul><li><p>以下代码要放在创建的功能包中的cmakelists.txt的install上面</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(velocity_publisher src/velocity_publisher.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(velocity_publisher <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><p>第一句是将<code>src/velocity_publisher.cpp</code>程序文件，编译成<code>velocity_publisher</code>可执行文件</p></li><li><p>第二句是将可执行文件<code>velocity_publisher</code>与<code>ros</code>相关库进行链接</p></li></ul></li><li><p>然后进行重新编译</p></li><li><p>如果为了避免每次打开命令行都要输入<code>source</code>，可以将<code>source</code>命令加入到主文件夹的<code>.bashrc</code>隐藏文件下（ctrl+ h 查看隐藏文件）</p></li></ul><h3 id="python-版本">Python 版本</h3><ul><li><p>为了跟<code>C++</code>版本进行区分，将<code>Python</code>版本代码，放到<code>/home/bjx/catkin_ws/src/learning_topic/scripts</code>文件夹中</p></li><li><p><code>Python</code>代码一定要有可执行权限，可以在<code>右键-属性-权限-执行</code>处进行修改，也可以通过命令行修改<code>chmod a+x hello.py</code></p></li><li><p><code>scripts/velocity_publisher.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment">########################################################################</span><br><span class="hljs-comment">####          Copyright 2020 GuYueHome (www.guyuehome.com).          ###</span><br><span class="hljs-comment">########################################################################</span><br><br><span class="hljs-comment"># 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> geometry_msgs.msg <span class="hljs-keyword">import</span> Twist<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">velocity_publisher</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;velocity_publisher&#x27;</span>, anonymous=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span><br>    turtle_vel_pub = rospy.Publisher(<span class="hljs-string">&#x27;/turtle1/cmd_vel&#x27;</span>, Twist, queue_size=<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">#设置循环的频率</span><br>    rate = rospy.Rate(<span class="hljs-number">10</span>) <br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():<br><span class="hljs-comment"># 初始化geometry_msgs::Twist类型的消息</span><br>        vel_msg = Twist()<br>        vel_msg.linear.x = <span class="hljs-number">0.5</span><br>        vel_msg.angular.z = <span class="hljs-number">0.2</span><br><br><span class="hljs-comment"># 发布消息</span><br>        turtle_vel_pub.publish(vel_msg)<br>    rospy.loginfo(<span class="hljs-string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, <br>vel_msg.linear.x, vel_msg.angular.z)<br><br><span class="hljs-comment"># 按照循环频率延时</span><br>        rate.sleep()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">try</span>:<br>        velocity_publisher()<br>    <span class="hljs-keyword">except</span> rospy.ROSInterruptException:<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li><p><code>#!/usr/bin/env python</code>是为了说明python文件为可执行文件，而不是脚本文件。</p></li><li><p><code># coding:utf-8</code>是保证编码格式。</p></li></ul></li><li><p>learning_topic/CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br>  scripts/velocity_publisher.py<br>  DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>再重新编译</p></li><li><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun learning_topic velocity_publisher.py<br></code></pre></td></tr></table></figure></li></ul><h2 id="订阅者-subscriber">订阅者 Subscriber</h2><h3 id="c-版本-1">C++ 版本</h3><ul><li><p>/src/pose_subscriber.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;turtlesim/Pose.h&quot;</span></span><br><br><span class="hljs-comment">// 接收到订阅的消息后，会进入消息回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">poseCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> turtlesim::Pose::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 将接收到的消息打印出来</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg-&gt;x, msg-&gt;y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化ROS节点</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;pose_subscriber&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span><br>    ros::Subscriber pose_sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;/turtle1/pose&quot;</span>, <span class="hljs-number">10</span>, poseCallback);<br><br>    <span class="hljs-comment">// 循环等待回调函数</span><br>    ros::<span class="hljs-built_in">spin</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>learning_topic/CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(pose_subscriber src/pose_subscriber.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(pose_subscriber <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><p>重新编译后，通过键盘修改小海龟位置参数，命令行也会同步出现位置的修改信息</p></li></ul><h3 id="python-版本-1">Python 版本</h3><ul><li><p>/scripts/pose_subscriber.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> turtlesim.msg <span class="hljs-keyword">import</span> Pose<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">poseCallback</span>(<span class="hljs-params">msg</span>):<br>    rospy.loginfo(<span class="hljs-string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg.x, msg.y)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pose_subscriber</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;pose_subscriber&#x27;</span>, anonymous=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span><br>    rospy.Subscriber(<span class="hljs-string">&quot;/turtle1/pose&quot;</span>, Pose, poseCallback)<br><br><span class="hljs-comment"># 循环等待回调函数</span><br>    rospy.spin()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pose_subscriber()<br></code></pre></td></tr></table></figure></li><li><p>learning_topic/CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br>  scripts/pose_subscriber.py<br>  DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>再重新编译</p></li><li><p>执行命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">rosrun learning_topic pose_subscriber.py<br></code></pre></td></tr></table></figure></li></ul><h2 id="话题消息">话题消息</h2><ul><li>当 ROS提供的消息类型无法满足我们的需要的时候，我们可以自己定义一个消息类型，以满足程序传输数据的要求。</li><li>此处我们以一个个人信息的消息发布为例，演示自定义话题的流程。</li></ul><h3 id="自定义话题消息">自定义话题消息</h3><ul><li><p>在<code>learning_topic</code>文件夹下创建文件夹<code>msg</code>用于管理所有的自定义消息类型</p></li><li><p>在<code>msg</code>文件夹下创建文件<code>Person.msg</code>文件，内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs msg">string name<br>uint8 sex<br>uint8 age<br><br>uint8 unknown = 0<br>uint8 male    = 1<br>uint8 female  = 2<br></code></pre></td></tr></table></figure></li><li><p>在<code>package.xml</code>中添加功能包依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>message_generation<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exec_depend</span>&gt;</span>message_runtime<span class="hljs-tag">&lt;/<span class="hljs-name">exec_depend</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</code>：这一行指定了在构建（编译）该ROS软件包时所需的依赖项。具体来说，它表示该软件包依赖于名为<code>message_generation</code>的软件包，用于生成ROS消息（Message）的包。在构建时，软件包将使用<code>message_generation</code>中的工具来处理和生成消息，以确保软件包正确地与其他ROS节点通信。</p></li><li><p><code>&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</code>：这一行指定了在运行时（当软件包被执行时）所需的依赖项。它表示该软件包在运行时依赖于名为<code>message_runtime</code> 的软件包。<code>message_runtime</code>包含运行时库，这些库允许软件包在运行时解析和使用ROS消息。</p></li><li><p>这些依赖关系的明确定义有助于ROS工具正确构建和部署软件包，以确保它们在运行时具有所需的依赖项。当构建和运行ROS软件包时，ROS工具（如<code>catkin_make</code>和<code>rosrun</code>）将自动处理这些依赖关系，以确保软件包能够正常工作。</p></li></ul></li><li><p>在功能包中的<code>CMakeLists.txt</code>中添加编译选项</p><ul><li><p>在<code>find_package</code>中添加功能包<code>message_generation</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">add_message_files(FILES Person.msg)<br>generate_messages(DEPENDENCIES std_msgs)<br></code></pre></td></tr></table></figure></li><li><p><code>add_message_files(FILES Person.msg)</code>：这一行代码告诉ROS构建系统，要将名为<code>Person.msg</code>的消息文件添加到该软件包中。这是一种将自定义消息定义添加到ROS软件包的方式。<code>Person.msg</code>文件包含了消息的结构和字段定义。当你运行<code>catkin_make</code>等构建工具时，ROS构建系统会处理这些消息定义文件，并生成相应的消息代码，以便在ROS程序中使用。</p></li><li><p><code>generate_messages(DEPENDENCIES std_msgs)</code>：这一行代码告诉ROS构建系统在生成消息时依赖于其他消息包。在这种情况下，它依赖于<code>std_msgs</code>软件包，这是ROS中包含许多标准消息类型的软件包。这意味着，如果你的<code>Person.msg</code>消息定义中使用了<code>std_msgs</code>中定义的消息类型，你需要指定这个依赖项，以确保生成的消息代码能够正确引用<code>std_msgs</code> 中的消息类型。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_package(<br><span class="hljs-comment">#  INCLUDE_DIRS include</span><br><span class="hljs-comment">#  LIBRARIES learning_topic</span><br>   CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime<br><span class="hljs-comment">#  DEPENDS system_lib</span><br>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>重新编译，之后在<code>/home/bjx/catkin_ws/devel/include/learning_topic</code>中可以看到编译生成的一个头文件</p></li></ul><h3 id="c-版本-2">C++ 版本</h3><h4 id="发布者">发布者</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将发布/person_info话题，自定义消息类型learning_topic::Person</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;learning_topic/Person.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ROS节点初始化</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;person_publisher&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span><br>    ros::Publisher person_info_pub = n.<span class="hljs-built_in">advertise</span>&lt;learning_topic::Person&gt;(<span class="hljs-string">&quot;/person_info&quot;</span>, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">// 设置循环的频率</span><br>    <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>    &#123;<br>        <span class="hljs-comment">// 初始化learning_topic::Person类型的消息</span><br>    learning_topic::Person person_msg;<br>person_msg.name = <span class="hljs-string">&quot;Tom&quot;</span>;<br>person_msg.age  = <span class="hljs-number">18</span>;<br>person_msg.sex  = learning_topic::Person::male;<br><br>        <span class="hljs-comment">// 发布消息</span><br>person_info_pub.<span class="hljs-built_in">publish</span>(person_msg);<br><br>       <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Publish Person Info: name:%s  age:%d  sex:%d&quot;</span>, <br>  person_msg.name.<span class="hljs-built_in">c_str</span>(), person_msg.age, person_msg.sex);<br><br>        <span class="hljs-comment">// 按照循环频率延时</span><br>        loop_rate.<span class="hljs-built_in">sleep</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(person_publisher src/person_publisher.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(person_publisher <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">add_dependencies</span>(person_publisher <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)<br></code></pre></td></tr></table></figure><h4 id="订阅者">订阅者</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;learning_topic/Person.h&quot;</span></span><br><br><span class="hljs-comment">// 接收到订阅的消息后，会进入消息回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">personInfoCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> learning_topic::Person::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 将接收到的消息打印出来</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, <br> msg-&gt;name.<span class="hljs-built_in">c_str</span>(), msg-&gt;age, msg-&gt;sex);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化ROS节点</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;person_subscriber&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span><br>    ros::Subscriber person_info_sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;/person_info&quot;</span>, <span class="hljs-number">10</span>, personInfoCallback);<br><br>    <span class="hljs-comment">// 循环等待回调函数</span><br>    ros::<span class="hljs-built_in">spin</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(person_subscriber src/person_subscriber.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(person_subscriber <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">add_dependencies</span>(person_subscriber <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)<br></code></pre></td></tr></table></figure><h4 id="运行程序">运行程序</h4><ul><li>编译</li><li>运行程序，发现输出个人信息</li><li>rosmaster是用于帮助建立连接，一旦连接成功建立，就不在需要master了。可以尝试关闭roscore，此时消息传输不会停止出错</li></ul><h3 id="python-版本-2">Python 版本</h3><h4 id="发布者-1">发布者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/user/bin/env python</span><br><span class="hljs-comment"># -*- coidng: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将发布/person_info话题，自定义消息类型learning_topic::Person</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> learning_topic.msg <span class="hljs-keyword">import</span> Person<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">velocity_publihser</span>():<br>    <span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;person_publisher&#x27;</span>, anonymous=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-comment"># 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span><br>    person_info_pub = rospy.Publisher(<span class="hljs-string">&#x27;/person_info&#x27;</span>, Person, queue_size=<span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">#设置循环的频率</span><br>    rate = rospy.Rate(<span class="hljs-number">10</span>) <br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():<br>        <span class="hljs-comment"># 初始化learning_topic::Person类型的消息</span><br>        person_msg = Person()<br>        person_msg.name = <span class="hljs-string">&quot;Tom&quot;</span><br>        person_msg.age  = <span class="hljs-number">18</span><br>        person_msg.sex  = Person.male<br><br>        <span class="hljs-comment"># 发布消息</span><br>        person_info_pub.publish(person_msg)<br>        rospy.loginfo(<span class="hljs-string">&quot;Publsh person message[%s, %d, %d]&quot;</span>,person_msg.name, person_msg.age, person_msg.sex)<br><br>        <span class="hljs-comment"># 按照循环频率延时</span><br>        rate.sleep()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">try</span>:<br>        velocity_publihser()<br>    <span class="hljs-keyword">except</span> rospy.ROSInterruptException:<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li><code>CMakeLists.txt</code>中添加配置</li></ul><h4 id="订阅者-1">订阅者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> learning_topic.msg <span class="hljs-keyword">import</span> Person<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">personInfoCallback</span>(<span class="hljs-params">msg</span>):<br>    rospy.loginfo(<span class="hljs-string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, <br> msg.name, msg.age, msg.sex)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person_subscriber</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;person_subscriber&#x27;</span>, anonymous=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span><br>    rospy.Subscriber(<span class="hljs-string">&quot;/person_info&quot;</span>, Person, personInfoCallback)<br><br><span class="hljs-comment"># 循环等待回调函数</span><br>    rospy.spin()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    person_subscriber()<br></code></pre></td></tr></table></figure><ul><li><code>CMakeLists.txt</code>中添加配置</li></ul><h4 id="运行程序-1">运行程序</h4><ul><li>编译</li><li>运行</li></ul><h2 id="客户端-client">客户端 Client</h2><ul><li><p>从本节开始，学习服务的相关实现</p></li><li><p>本节用到的例子是创建一个新的小海龟</p></li><li><p>创建一个新的功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_create_pkg learning_service roscpp rospy std_msgs geometry_msgs turtlesim<br></code></pre></td></tr></table></figure></li></ul><h3 id="c-版本-3">C++ 版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;turtlesim/Spawn.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化ROS节点</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;turtle_spawn&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>ros::NodeHandle node;<br><br>    <span class="hljs-comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;/spawn&quot;</span>);<br>ros::ServiceClient add_turtle = node.<span class="hljs-built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="hljs-string">&quot;/spawn&quot;</span>);<br><br>    <span class="hljs-comment">// 初始化turtlesim::Spawn的请求数据</span><br>turtlesim::Spawn srv;<br>srv.request.x = <span class="hljs-number">2.0</span>;<br>srv.request.y = <span class="hljs-number">2.0</span>;<br>srv.request.name = <span class="hljs-string">&quot;turtle2&quot;</span>;<br><br>    <span class="hljs-comment">// 请求服务调用</span><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]&quot;</span>, <br> srv.request.x, srv.request.y, srv.request.name.<span class="hljs-built_in">c_str</span>());<br><br>add_turtle.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-comment">// 显示服务调用结果</span><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Spwan turtle successfully [name:%s]&quot;</span>, srv.response.name.<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(turtle_spawn src/turtle_spawn.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(turtle_spawn <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">roscore<br>rosrun turtlesim turtlesim_node<br>rosrun learning_service turtle_spawn<br></code></pre></td></tr></table></figure><ul><li>编译运行后，此时会发现出现两只小海龟</li></ul><h3 id="python-版本-3">Python 版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn</span><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> turtlesim.srv <span class="hljs-keyword">import</span> Spawn<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">turtle_spawn</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;turtle_spawn&#x27;</span>)<br><br><span class="hljs-comment"># 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span><br>    rospy.wait_for_service(<span class="hljs-string">&#x27;/spawn&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        add_turtle = rospy.ServiceProxy(<span class="hljs-string">&#x27;/spawn&#x27;</span>, Spawn)<br><br><span class="hljs-comment"># 请求服务调用，输入请求数据</span><br>        response = add_turtle(<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-string">&quot;turtle2&quot;</span>)<br>        <span class="hljs-keyword">return</span> response.name<br>    <span class="hljs-keyword">except</span> rospy.ServiceException <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Service call failed: %s&quot;</span>%e)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-comment">#服务调用并显示调用结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Spwan turtle successfully [name:%s]&quot;</span> %(turtle_spawn())) <br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br> scripts/turtle_spawn.py<br>DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure><ul><li>编译运行后，此时会发现出现两只小海龟</li></ul><h2 id="服务器端-server">服务器端 Server</h2><ul><li>步骤<ol type="1"><li>初始化ROS结点</li><li>创建Server实例</li><li>循环等待服务请求，进入回调函数</li><li>在回调函数中完成服务功能的处理，并反馈应答数据</li></ol></li></ul><h3 id="c-版本-4">C++ 版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/Twist.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;std_srvs/Trigger.h&gt;</span></span><br><br>ros::Publisher turtle_vel_pub;<br><span class="hljs-type">bool</span> pubCommand = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// service回调函数，输入参数req，输出参数res</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">commandCallback</span><span class="hljs-params">(std_srvs::Trigger::Request  &amp;req,</span></span><br><span class="hljs-params"><span class="hljs-function">         std_srvs::Trigger::Response &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>pubCommand = !pubCommand;<br><br>    <span class="hljs-comment">// 显示请求数据</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Publish turtle velocity command [%s]&quot;</span>, pubCommand==<span class="hljs-literal">true</span>?<span class="hljs-string">&quot;Yes&quot;</span>:<span class="hljs-string">&quot;No&quot;</span>);<br><br><span class="hljs-comment">// 设置反馈数据</span><br>res.success = <span class="hljs-literal">true</span>;<br>res.message = <span class="hljs-string">&quot;Change turtle command state!&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ROS节点初始化</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;turtle_command_server&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 创建一个名为/turtle_command的server，注册回调函数commandCallback</span><br>    ros::ServiceServer command_service = n.<span class="hljs-built_in">advertiseService</span>(<span class="hljs-string">&quot;/turtle_command&quot;</span>, commandCallback);<br><br><span class="hljs-comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span><br>turtle_vel_pub = n.<span class="hljs-built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">// 循环等待回调函数</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Ready to receive turtle command.&quot;</span>);<br><br><span class="hljs-comment">// 设置循环的频率</span><br><span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-keyword">while</span>(ros::<span class="hljs-built_in">ok</span>())<br>&#123;<br><span class="hljs-comment">// 查看一次回调函数队列</span><br>    ros::<span class="hljs-built_in">spinOnce</span>();<br><br><span class="hljs-comment">// 如果标志为true，则发布速度指令</span><br><span class="hljs-keyword">if</span>(pubCommand)<br>&#123;<br>geometry_msgs::Twist vel_msg;<br>vel_msg.linear.x = <span class="hljs-number">0.5</span>;<br>vel_msg.angular.z = <span class="hljs-number">0.2</span>;<br>turtle_vel_pub.<span class="hljs-built_in">publish</span>(vel_msg);<br>&#125;<br><br><span class="hljs-comment">//按照循环频率延时</span><br>    loop_rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(turtle_command_server src/turtle_command_server.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(turtle_command_server <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">roscore<br>rosrun turtlesim turtlesim_node<br>rosrun learning_service turtle_command_server<br>rosservice call /turtle_command <span class="hljs-string">&quot;&#123;&#125;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="python-版本-4">Python 版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">import</span> thread, time<br><span class="hljs-keyword">from</span> geometry_msgs.msg <span class="hljs-keyword">import</span> Twist<br><span class="hljs-keyword">from</span> std_srvs.srv <span class="hljs-keyword">import</span> Trigger, TriggerResponse<br><br>pubCommand = <span class="hljs-literal">False</span><br>turtle_vel_pub = rospy.Publisher(<span class="hljs-string">&#x27;/turtle1/cmd_vel&#x27;</span>, Twist, queue_size=<span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">command_thread</span>():<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-keyword">if</span> pubCommand:<br>vel_msg = Twist()<br>vel_msg.linear.x = <span class="hljs-number">0.5</span><br>vel_msg.angular.z = <span class="hljs-number">0.2</span><br>turtle_vel_pub.publish(vel_msg)<br><br>time.sleep(<span class="hljs-number">0.1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">commandCallback</span>(<span class="hljs-params">req</span>):<br><span class="hljs-keyword">global</span> pubCommand<br>pubCommand = <span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>-pubCommand)<br><br><span class="hljs-comment"># 显示请求数据</span><br>rospy.loginfo(<span class="hljs-string">&quot;Publish turtle velocity command![%d]&quot;</span>, pubCommand)<br><br><span class="hljs-comment"># 反馈数据</span><br><span class="hljs-keyword">return</span> TriggerResponse(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Change turtle command state!&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">turtle_command_server</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;turtle_command_server&#x27;</span>)<br><br><span class="hljs-comment"># 创建一个名为/turtle_command的server，注册回调函数commandCallback</span><br>    s = rospy.Service(<span class="hljs-string">&#x27;/turtle_command&#x27;</span>, Trigger, commandCallback)<br><br><span class="hljs-comment"># 循环等待回调函数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Ready to receive turtle command.&quot;</span>) <br><br>    thread.start_new_thread(command_thread, ())<br>    rospy.spin()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    turtle_command_server()<br></code></pre></td></tr></table></figure><ul><li><code>C++</code>中的<code>ros::spinOnce()</code>在<code>Python</code>中是没有实现的，只有<code>rospy.spin()</code>。所以要通过多线程机制，来实现<code>ros::spinOnce()</code>同样的功能。</li><li>如果使用的是<code>Python3</code>，需要将<code>thread</code>改成<code>_thread</code></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br> scripts/turtle_spawn.py scripts/turtle_command_server.py<br>DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure><ul><li>上面脚本在后面跟着写即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">roscore<br>rosrun turtlesim turtlesim_node<br>rosrun learning_service turtle_command_server<br>rosservice call /turtle_command <span class="hljs-string">&quot;&#123;&#125;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="服务数据">服务数据</h2><h3 id="自定义服务数据">自定义服务数据</h3><ul><li><p>在<code>learning_service</code>文件夹下创建创建文件夹<code>srv</code>来管理所有自定义服务数据</p></li><li><p>在<code>srv</code>文件夹下创建文件<code>Person.srv</code>，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs srv">string name<br>uint8  age<br>uint8  sex<br><br>uint8 unknown = 0<br>uint8 male    = 1<br>uint8 female  = 2<br>---<br>string result<br></code></pre></td></tr></table></figure><ul><li><code>---</code>上面是请求的格式，下面是应答的格式</li></ul></li><li><p>在<code>package.xml</code>中添加功能包依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>message_generation<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exec_depend</span>&gt;</span>message_runtime<span class="hljs-tag">&lt;/<span class="hljs-name">exec_depend</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在功能包中的<code>CMakeLists.txt</code>中添加编译选项</p><ul><li><p>在<code>find_package</code>中添加功能包<code>message_generation</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">add_service_files(FILES Person.srv)<br>generate_messages(DEPENDENCIES std_msgs)<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_package(<br><span class="hljs-comment">#  INCLUDE_DIRS include</span><br><span class="hljs-comment">#  LIBRARIES learning_topic</span><br>   CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime<br><span class="hljs-comment">#  DEPENDS system_lib</span><br>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>重新编译，之后在<code>/home/bjx/catkin_ws/devel/include/learning_service</code>中可以看到编译生成的三个头文件</p></li></ul><h3 id="c-版本-5">C++ 版本</h3><h4 id="客户端">客户端</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将请求/show_person服务，服务数据类型learning_service::Person</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;learning_service/Person.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化ROS节点</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;person_client&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>ros::NodeHandle node;<br><br>    <span class="hljs-comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;/show_person&quot;</span>);<br>ros::ServiceClient person_client = node.<span class="hljs-built_in">serviceClient</span>&lt;learning_service::Person&gt;(<span class="hljs-string">&quot;/show_person&quot;</span>);<br><br>    <span class="hljs-comment">// 初始化learning_service::Person的请求数据</span><br>learning_service::Person srv;<br>srv.request.name = <span class="hljs-string">&quot;Tom&quot;</span>;<br>srv.request.age  = <span class="hljs-number">20</span>;<br>srv.request.sex  = learning_service::Person::Request::male;<br><br>    <span class="hljs-comment">// 请求服务调用</span><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Call service to show person[name:%s, age:%d, sex:%d]&quot;</span>, <br> srv.request.name.<span class="hljs-built_in">c_str</span>(), srv.request.age, srv.request.sex);<br><br>person_client.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-comment">// 显示服务调用结果</span><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Show person result : %s&quot;</span>, srv.response.result.<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(person_client src/person_client.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(person_client <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">add_dependencies</span>(person_client <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)<br></code></pre></td></tr></table></figure><h4 id="服务端">服务端</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程将执行/show_person服务，服务数据类型learning_service::Person</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;learning_service/Person.h&quot;</span></span><br><br><span class="hljs-comment">// service回调函数，输入参数req，输出参数res</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">personCallback</span><span class="hljs-params">(learning_service::Person::Request  &amp;req,</span></span><br><span class="hljs-params"><span class="hljs-function">         learning_service::Person::Response &amp;res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 显示请求数据</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name.<span class="hljs-built_in">c_str</span>(), req.age, req.sex);<br><br><span class="hljs-comment">// 设置反馈数据</span><br>res.result = <span class="hljs-string">&quot;OK&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ROS节点初始化</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;person_server&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 创建一个名为/show_person的server，注册回调函数personCallback</span><br>    ros::ServiceServer person_service = n.<span class="hljs-built_in">advertiseService</span>(<span class="hljs-string">&quot;/show_person&quot;</span>, personCallback);<br><br>    <span class="hljs-comment">// 循环等待回调函数</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Ready to show person informtion.&quot;</span>);<br>    ros::<span class="hljs-built_in">spin</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(person_server src/person_server.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(person_server <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">add_dependencies</span>(person_server <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)<br></code></pre></td></tr></table></figure><h3 id="python-版本-5">Python 版本</h3><h4 id="客户端-1">客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将请求/show_person服务，服务数据类型learning_service::Person</span><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> learning_service.srv <span class="hljs-keyword">import</span> Person, PersonRequest<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person_client</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;person_client&#x27;</span>)<br><br><span class="hljs-comment"># 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span><br>    rospy.wait_for_service(<span class="hljs-string">&#x27;/show_person&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        person_client = rospy.ServiceProxy(<span class="hljs-string">&#x27;/show_person&#x27;</span>, Person)<br><br><span class="hljs-comment"># 请求服务调用，输入请求数据</span><br>        response = person_client(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">20</span>, PersonRequest.male)<br>        <span class="hljs-keyword">return</span> response.result<br>    <span class="hljs-keyword">except</span> rospy.ServiceException <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Service call failed: %s&quot;</span>%e) <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-comment">#服务调用并显示调用结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Show person result : %s&quot;</span> %(person_client()))<br></code></pre></td></tr></table></figure><ul><li>在<code>catkin_install_python</code>中加入该文件</li></ul><h4 id="服务端-1">服务端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将执行/show_person服务，服务数据类型learning_service::Person</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> learning_service.srv <span class="hljs-keyword">import</span> Person, PersonResponse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">personCallback</span>(<span class="hljs-params">req</span>):<br><span class="hljs-comment"># 显示请求数据</span><br>    rospy.loginfo(<span class="hljs-string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name, req.age, req.sex)<br><br><span class="hljs-comment"># 反馈数据</span><br>    <span class="hljs-keyword">return</span> PersonResponse(<span class="hljs-string">&quot;OK&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person_server</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;person_server&#x27;</span>)<br><br><span class="hljs-comment"># 创建一个名为/show_person的server，注册回调函数personCallback</span><br>    s = rospy.Service(<span class="hljs-string">&#x27;/show_person&#x27;</span>, Person, personCallback)<br><br><span class="hljs-comment"># 循环等待回调函数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Ready to show person informtion.&quot;</span>) <br>    rospy.spin()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    person_server()<br></code></pre></td></tr></table></figure><p>在<code>catkin_install_python</code>中加入该文件</p><h2 id="参数">参数</h2><ul><li><p>在 ROS Master 中有一个参数服务器 ParameterServer，是一个全局字典，用于保存各个节点之间的配置参数。</p></li><li><p>创建功能包<code>learning_parameter</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws/src<br>catkin_create_pkg learning_parameter roscpp rospy std_srvs<br></code></pre></td></tr></table></figure></li></ul><h3 id="参数命令行使用">参数命令行使用</h3><ul><li><p>列出当前所有参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam list<br></code></pre></td></tr></table></figure></li><li><p>显示某个参数值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam get param_key<br></code></pre></td></tr></table></figure></li><li><p>设置某个参数值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam <span class="hljs-built_in">set</span> param_key param_value<br></code></pre></td></tr></table></figure><ul><li>在设置小海龟的背景颜色案例中，设置完颜色，还有请求一下服务，运行命令<code>rosservice call /clear '&#123;&#125;'</code>，背景颜色方才改变。</li></ul></li><li><p>保存参数到文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam dump file_name<br></code></pre></td></tr></table></figure></li><li><p>从文件读取参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam load file_name<br></code></pre></td></tr></table></figure></li><li><p>删除参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam delete param_key<br></code></pre></td></tr></table></figure></li><li><p>在 ROS 中，如果参数比较多，会用到 YAML 参数文件，格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">rosdistro:</span> <span class="hljs-string">&#x27;noetic</span><br><span class="hljs-string"></span><br><span class="hljs-string">  &#x27;</span><br><span class="hljs-attr">roslaunch:</span><br>  <span class="hljs-attr">uris:</span><br>    <span class="hljs-attr">host_bjx__44977:</span> <span class="hljs-string">http://bjx:44977/</span><br><span class="hljs-attr">rosversion:</span> <span class="hljs-string">&#x27;1.16.0</span><br><span class="hljs-string"></span><br><span class="hljs-string">  &#x27;</span><br><span class="hljs-attr">run_id:</span> <span class="hljs-string">c713a7d4-753e-11ee-84ae-234d4d1e8e05</span><br><span class="hljs-attr">turtlesim:</span><br>  <span class="hljs-attr">background_b:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">background_g:</span> <span class="hljs-number">86</span><br>  <span class="hljs-attr">background_r:</span> <span class="hljs-number">69</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="编程方法">编程方法</h3><h4 id="c-版本-6">C++ 版本</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程设置/读取海龟例程中的参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;std_srvs/Empty.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> red, green, blue;<br><br>    <span class="hljs-comment">// ROS节点初始化</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;parameter_config&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>    ros::NodeHandle node;<br><br>    <span class="hljs-comment">// 读取背景颜色参数</span><br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_r&quot;</span>, red);<br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_g&quot;</span>, green);<br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_b&quot;</span>, blue);<br><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);<br><br><span class="hljs-comment">// 设置背景颜色参数</span><br>ros::param::<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;/turtlesim/background_r&quot;</span>, <span class="hljs-number">255</span>);<br>ros::param::<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;/turtlesim/background_g&quot;</span>, <span class="hljs-number">255</span>);<br>ros::param::<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;/turtlesim/background_b&quot;</span>, <span class="hljs-number">255</span>);<br><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>);<br><br>    <span class="hljs-comment">// 读取背景颜色参数</span><br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_r&quot;</span>, red);<br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_g&quot;</span>, green);<br>ros::param::<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/turtlesim/background_b&quot;</span>, blue);<br><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;Re-get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);<br><br><span class="hljs-comment">// 调用服务，刷新背景颜色</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;/clear&quot;</span>);<br>ros::ServiceClient clear_background = node.<span class="hljs-built_in">serviceClient</span>&lt;std_srvs::Empty&gt;(<span class="hljs-string">&quot;/clear&quot;</span>);<br>std_srvs::Empty srv;<br>clear_background.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(parameter_config src/parameter_config.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(parameter_config <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><ul><li>一定要注意参数名是否正确</li><li>上面的get和set并不是唯一的获取参数的值的方法，还有其他方法，具体参考<ahref="http://wiki.ros.org/Parameter%20Server">http://wiki.ros.org/ParameterServer</a></li></ul><h4 id="python-版本-6">Python 版本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程设置/读取海龟例程中的参数</span><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> std_srvs.srv <span class="hljs-keyword">import</span> Empty<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parameter_config</span>():<br><span class="hljs-comment"># ROS节点初始化</span><br>    rospy.init_node(<span class="hljs-string">&#x27;parameter_config&#x27;</span>, anonymous=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 读取背景颜色参数</span><br>    red   = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_r&#x27;</span>)<br>    green = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_g&#x27;</span>)<br>    blue  = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_b&#x27;</span>)<br><br>    rospy.loginfo(<span class="hljs-string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue)<br><br><span class="hljs-comment"># 设置背景颜色参数</span><br>    rospy.set_param(<span class="hljs-string">&quot;/turtlesim/background_r&quot;</span>, <span class="hljs-number">255</span>)<br>    rospy.set_param(<span class="hljs-string">&quot;/turtlesim/background_g&quot;</span>, <span class="hljs-number">255</span>)<br>    rospy.set_param(<span class="hljs-string">&quot;/turtlesim/background_b&quot;</span>, <span class="hljs-number">255</span>)<br><br>    rospy.loginfo(<span class="hljs-string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>)<br><br><span class="hljs-comment"># 读取背景颜色参数</span><br>    red   = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_r&#x27;</span>)<br>    green = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_g&#x27;</span>)<br>    blue  = rospy.get_param(<span class="hljs-string">&#x27;/turtlesim/background_b&#x27;</span>)<br><br>    rospy.loginfo(<span class="hljs-string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue)<br><br><span class="hljs-comment"># 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span><br>    rospy.wait_for_service(<span class="hljs-string">&#x27;/clear&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        clear_background = rospy.ServiceProxy(<span class="hljs-string">&#x27;/clear&#x27;</span>, Empty)<br><br><span class="hljs-comment"># 请求服务调用，输入请求数据</span><br>        response = clear_background()<br>        <span class="hljs-keyword">return</span> response<br>    <span class="hljs-keyword">except</span> rospy.ServiceException <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Service call failed: %s&quot;</span>%e) <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    parameter_config()<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br>scripts/parameter_config.py<br>DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure><h2 id="坐标系管理">坐标系管理</h2><ul><li>ROS 中的坐标系管理系统 TF (TransForm)</li><li>任意两个三维坐标的坐标变换，都可以通过一个四阶矩阵来表示</li><li>TF 默认记录10秒钟之内所有坐标系之间的位置关系</li><li>TF 坐标变换的实现<ul><li>广播 TF 变换</li><li>监听 TF 变换</li></ul></li></ul><h3 id="使用方法">使用方法</h3><ul><li><p>下载小海龟的 tf 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install ros-noetic-turtle-tf<br></code></pre></td></tr></table></figure></li><li><p>运行 launch 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">roslaunch turtle_tf turtle_tf_demo.launch<br></code></pre></td></tr></table></figure></li><li><p>运行键盘控制程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun turtlesim turtle_teleop_key<br></code></pre></td></tr></table></figure></li><li><p>view_frames 是一个图形化的调试工具，并且可以输出当前的tf关系到pdf 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun tf view_frames<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>【问题解决】：</p><ol type="1"><li>如果在运行launch的过程中，出现rospkg的报错，很有可能是由于系统中存在多个Python，解决方案：http://t.csdnimg.cn/iRmvW</li><li>如果在运行tf的过程中，报错，需要修改代码，解决方案：https://www.cnblogs.com/QMark/p/15098334.html</li></ol></blockquote><ul><li><p>把特定坐标系之间的平移旋转关系打印到终端控制台上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun tf tf_echo turtle1 turtle2<br></code></pre></td></tr></table></figure><ul><li><p>以上命令可以直观的将 turtle2 坐标系到 turtle1坐标系的坐标变换矩阵展示出来</p></li><li><p>输出结果为：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">At time 1698634776.960<br>- Translation: [0.000, 0.000, 0.000]<br>- Rotation: in Quaternion [<span class="hljs-string">-0</span>.000, <span class="hljs-string">-0</span>.000, 0.640, 0.769]<br>            in RPY (radian) [<span class="hljs-string">-0</span>.000, <span class="hljs-string">-0</span>.000, 1.388]<br>            in RPY (degree) [<span class="hljs-string">-0</span>.000, <span class="hljs-string">-0</span>.000, 79.536]<br></code></pre></td></tr></table></figure></li></ul></li><li><p>更加可视化的工具 rviz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosrun rviz rviz -d <span class="hljs-string">&#x27;rospack find turtle_tf&#x27;</span> /rviz/turtle_rviz.rviz<br></code></pre></td></tr></table></figure></li></ul><h3 id="坐标系广播和监听的编程实现">坐标系广播和监听的编程实现</h3><ul><li><p>创建功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws/src<br>catkin_create_pkg learning_tf roscpp rospy tf turtlesim<br></code></pre></td></tr></table></figure></li></ul><h4 id="c-版本-7">C++ 版本</h4><h5 id="tf-广播器代码">tf 广播器代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tf/transform_listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/Twist.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;turtlesim/Spawn.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 初始化ROS节点</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;my_tf_listener&quot;</span>);<br><br>    <span class="hljs-comment">// 创建节点句柄</span><br>ros::NodeHandle node;<br><br><span class="hljs-comment">// 请求产生turtle2</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;/spawn&quot;</span>);<br>ros::ServiceClient add_turtle = node.<span class="hljs-built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="hljs-string">&quot;/spawn&quot;</span>);<br>turtlesim::Spawn srv;<br>add_turtle.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-comment">// 创建发布turtle2速度控制指令的发布者</span><br>ros::Publisher turtle_vel = node.<span class="hljs-built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建tf的监听器</span><br>tf::TransformListener listener;<br><br><span class="hljs-function">ros::Rate <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-number">10.0</span>)</span></span>;<br><span class="hljs-keyword">while</span> (node.<span class="hljs-built_in">ok</span>())<br>&#123;<br><span class="hljs-comment">// 获取turtle1与turtle2坐标系之间的tf数据</span><br>tf::StampedTransform transform;<br><span class="hljs-keyword">try</span><br>&#123;<br>listener.<span class="hljs-built_in">waitForTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">3.0</span>));<br>listener.<span class="hljs-built_in">lookupTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), transform);<br>&#125;<br><span class="hljs-built_in">catch</span> (tf::TransformException &amp;ex) <br>&#123;<br><span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>,ex.<span class="hljs-built_in">what</span>());<br>ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">1.0</span>).<span class="hljs-built_in">sleep</span>();<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span><br>geometry_msgs::Twist vel_msg;<br>vel_msg.angular.z = <span class="hljs-number">4.0</span> * <span class="hljs-built_in">atan2</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(),<br>                        transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>());<br>vel_msg.linear.x = <span class="hljs-number">0.5</span> * <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>(), <span class="hljs-number">2</span>) +<br>                      <span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(), <span class="hljs-number">2</span>));<br>turtle_vel.<span class="hljs-built_in">publish</span>(vel_msg);<br><br>rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>步骤：<ol type="1"><li>定义 TF 广播器</li><li>创建坐标变换值</li><li>发布坐标变换</li></ol></li></ul><h5 id="tf-监听器代码">tf 监听器代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tf/transform_listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/Twist.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;turtlesim/Spawn.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 初始化ROS节点</span><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;my_tf_listener&quot;</span>);<br><br><span class="hljs-comment">// 创建节点句柄</span><br>ros::NodeHandle node;<br><br><span class="hljs-comment">// 请求产生turtle2</span><br>ros::service::<span class="hljs-built_in">waitForService</span>(<span class="hljs-string">&quot;/spawn&quot;</span>);<br>ros::ServiceClient add_turtle = node.<span class="hljs-built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="hljs-string">&quot;/spawn&quot;</span>);<br>turtlesim::Spawn srv;<br>add_turtle.<span class="hljs-built_in">call</span>(srv);<br><br><span class="hljs-comment">// 创建发布turtle2速度控制指令的发布者</span><br>ros::Publisher turtle_vel = node.<span class="hljs-built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="hljs-string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建tf的监听器</span><br>tf::TransformListener listener;<br><br><span class="hljs-function">ros::Rate <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-number">10.0</span>)</span></span>;<br><span class="hljs-keyword">while</span> (node.<span class="hljs-built_in">ok</span>())<br>&#123;<br><span class="hljs-comment">// 获取turtle1与turtle2坐标系之间的tf数据</span><br>tf::StampedTransform transform;<br><span class="hljs-keyword">try</span><br>&#123;<br>listener.<span class="hljs-built_in">waitForTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">3.0</span>));<br>listener.<span class="hljs-built_in">lookupTransform</span>(<span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>), transform);<br>&#125;<br><span class="hljs-built_in">catch</span> (tf::TransformException &amp;ex)<br>&#123;<br><span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>, ex.<span class="hljs-built_in">what</span>());<br>ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">1.0</span>).<span class="hljs-built_in">sleep</span>();<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span><br>geometry_msgs::Twist vel_msg;<br>vel_msg.angular.z = <span class="hljs-number">4.0</span> * <span class="hljs-built_in">atan2</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(), transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>());<br>vel_msg.linear.x = <span class="hljs-number">0.5</span> * <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">x</span>(), <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(transform.<span class="hljs-built_in">getOrigin</span>().<span class="hljs-built_in">y</span>(), <span class="hljs-number">2</span>));<br>turtle_vel.<span class="hljs-built_in">publish</span>(vel_msg);<br><br>rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)<br><span class="hljs-keyword">add_executable</span>(turtle_tf_listener src/turtle_tf_listener.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(turtle_tf_broadcaster <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(turtle_tf_broadcaster <span class="hljs-variable">$&#123;catkin_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws<br>catkin_make<br><span class="hljs-built_in">source</span> devel/setup.bash<br>roscore<br>rosrun turtlesim turtlesim_node<br>rosrun learning_tf turtle_tf_broadcaster __name:=turtle1_tf_broadcaster /turtle1<br>rosrun learning_tf turtle_tf_broadcaster __name:=turtle2_tf_broadcaster /turtle2<br>rosrun learning_tf turtle_tf_listener<br>rosrun turtlesim turtle_teleop_key<br></code></pre></td></tr></table></figure><ul><li>上面第6行中，<code>/turtle1</code>是输入参数，<code>__name:=turtle1_tf_broadcaster</code>是重映射</li></ul><h4 id="python-版本-7">Python 版本</h4><h5 id="tf-广播器代码-1">tf 广播器代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将请求/show_person服务，服务数据类型learning_service::Person</span><br><br><span class="hljs-keyword">import</span> roslib<br><br>roslib.load_manifest(<span class="hljs-string">&quot;learning_tf&quot;</span>)<br><span class="hljs-keyword">import</span> rospy<br><br><span class="hljs-keyword">import</span> tf<br><span class="hljs-keyword">import</span> turtlesim.msg<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_turtle_pose</span>(<span class="hljs-params">msg, turtlename</span>):<br>    br = tf.TransformBroadcaster()<br>    br.sendTransform(<br>        (msg.x, msg.y, <span class="hljs-number">0</span>),<br>        tf.transformations.quaternion_from_euler(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, msg.theta),<br>        rospy.Time.now(),<br>        turtlename,<br>        <span class="hljs-string">&quot;world&quot;</span>,<br>    )<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    rospy.init_node(<span class="hljs-string">&quot;turtle_tf_broadcaster&quot;</span>)<br>    turtlename = rospy.get_param(<span class="hljs-string">&quot;~turtle&quot;</span>)<br>    rospy.Subscriber(<br>        <span class="hljs-string">&quot;/%s/pose&quot;</span> % turtlename, turtlesim.msg.Pose, handle_turtle_pose, turtlename<br>    )<br>    rospy.spin()<br></code></pre></td></tr></table></figure><h5 id="tf-监听器代码-1">tf 监听器代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-comment"># 该例程将请求/show_person服务，服务数据类型learning_service::Person</span><br><br><span class="hljs-keyword">import</span> roslib<br><br>roslib.load_manifest(<span class="hljs-string">&quot;learning_tf&quot;</span>)<br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> tf<br><span class="hljs-keyword">import</span> geometry_msgs.msg<br><span class="hljs-keyword">import</span> turtlesim.srv<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    rospy.init_node(<span class="hljs-string">&quot;turtle_tf_listener&quot;</span>)<br><br>    listener = tf.TransformListener()<br><br>    rospy.wait_for_service(<span class="hljs-string">&quot;spawn&quot;</span>)<br>    spawner = rospy.ServiceProxy(<span class="hljs-string">&quot;spawn&quot;</span>, turtlesim.srv.Spawn)<br>    spawner(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;turtle2&quot;</span>)<br><br>    turtle_vel = rospy.Publisher(<br>        <span class="hljs-string">&quot;turtle2/cmd_vel&quot;</span>, geometry_msgs.msg.Twist, queue_size=<span class="hljs-number">1</span><br>    )<br><br>    rate = rospy.Rate(<span class="hljs-number">10.0</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():<br>        <span class="hljs-keyword">try</span>:<br>            (trans, rot) = listener.lookupTransform(<br>                <span class="hljs-string">&quot;/turtle2&quot;</span>, <span class="hljs-string">&quot;/turtle1&quot;</span>, rospy.Time(<span class="hljs-number">0</span>)<br>            )<br>        <span class="hljs-keyword">except</span> (<br>            tf.LookupException,<br>            tf.ConnectivityException,<br>            tf.ExtrapolationException,<br>        ):<br>            <span class="hljs-keyword">continue</span><br><br>        angular = <span class="hljs-number">4</span> * math.atan2(trans[<span class="hljs-number">1</span>], trans[<span class="hljs-number">0</span>])<br>        linear = <span class="hljs-number">0.5</span> * math.sqrt(trans[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + trans[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span>)<br>        cmd = geometry_msgs.msg.Twist()<br>        cmd.linear.x = linear<br>        cmd.angular.z = angular<br>        turtle_vel.publish(cmd)<br><br>        rate.sleep()<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake">catkin_install_python(PROGRAMS<br>scripts/turtle_tf_broadcaster.py<br>DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br><br>catkin_install_python(PROGRAMS<br>scripts/turtle_tf_listener.py<br>DESTINATION <span class="hljs-variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws<br>catkin_make<br><span class="hljs-built_in">source</span> devel/setup.bash<br>roscore<br>rosrun turtlesim turtlesim_node<br>rosrun learning_tf turtle_tf_broadcaster.py __name:=turtle1_tf_broadcaster _turtle:=turtle1<br>rosrun learning_tf turtle_tf_broadcaster.py __name:=turtle2_tf_broadcaster _turtle:=turtle2<br>rosrun learning_tf turtle_tf_listener<br>rosrun turtlesim turtle_teleop_key<br></code></pre></td></tr></table></figure><h2 id="launch-启动文件">launch 启动文件</h2><h3 id="介绍">介绍</h3><ul><li><p>Launch 文件：通过 XML 文件实现多节点的配置和启动（可自动启动 ROSMaster）</p></li><li><p>launch 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;launch&gt;</code>为文件的根元素</li><li><code>&lt;node&gt;</code>为启动节点<ul><li><code>pkg</code>：节点所在功能包名称</li><li><code>type</code>：节点的可执行文件名称</li><li><code>name</code>：节点运行时的名称</li><li><code>output</code>：控制节点是否要将控制信息打印到当前终端</li><li><code>respawn</code>：控制节点挂掉后，是否进行重启</li><li><code>required</code>：是否在launch文件，该结点一定要启动起来</li><li><code>ns</code>：namespace 命名空间</li><li><code>args</code>：结点的输入参数</li><li>前三个属性是必须属性，后面的属性为可选属性</li></ul></li><li><code>&lt;param name="output_frame" value="odom" /&gt;</code><ul><li>设置 ROS 系统运行中的参数，存储在参数服务器中</li><li><code>name</code>：参数名</li><li><code>value</code>：参数值</li></ul></li><li><code>&lt;rosparam file="params.yaml" command="load" ns="params" /&gt;</code><ul><li>加载参数文件中多个参数</li></ul></li><li><code>&lt;arg name="arg-name" default="arg-value" /&gt;</code><ul><li>launch 文件内部的局部变量，仅限于 launch 文件使用</li><li><code>name</code>：参数名</li><li><code>value</code>：参数值</li><li>调用方法：<ul><li><code>&lt;param name="foo" value="$(arg arg-name)" /&gt;</code></li><li><code>&lt;node name="node" pkg="package" type="type" args="$(arg arg-name)" /&gt;</code></li></ul></li></ul></li><li><code>&lt;remap from="/turtlebot/cmd_vel" to="/cmd_vel" /&gt;</code><ul><li>重映射 ROS 计算图资源的命名</li><li><code>from</code>：原命名</li><li><code>to</code>：映射之后的命名</li></ul></li><li><code>&lt;include file="$(dirname)/other.launch" /&gt;</code><ul><li>包含其他 launch 文件，类似 C 语言中的头文件包含</li><li><code>file</code>：包含的其他 launc 文件路径</li><li>包含的文件会运行一遍</li></ul></li><li>其他详见：<ahref="https://wiki.ros.org/roslaunch/xml">https://wiki.ros.org/roslaunch/xml</a></li></ul></li></ul><h3 id="代码实现">代码实现</h3><ul><li><p>创建<code>learning_launch</code>功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_create_pkg learning_launch<br></code></pre></td></tr></table></figure><ul><li>不需要任何依赖</li></ul></li><li><p>在<code>learning_launch</code>功能包下创建文件夹<code>launch</code></p></li><li><p>创建文件<code>simple.launch</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;person_subscriber&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;talker&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;person_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;listener&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>编译：<code>catkin_make</code></li><li>启动：<code>roslaunch learning_launch simple.launch</code></li></ul></li><li><p>创建文件<code>turtlesim_parameter_config.launch</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;/turtle_number&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle_name1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Tom&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle_name2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Jerry&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">rosparam</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;$(find learning_launch)/config/param.yaml&quot;</span> <span class="hljs-attr">command</span>=<span class="hljs-string">&quot;load&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>创建文件夹：<code>catkin_ws/src/learning_launch/config</code></p></li><li><p>创建文件：<code>param.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">A:</span> <span class="hljs-number">123</span><br><span class="hljs-attr">B:</span> <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-attr">group:</span><br>  <span class="hljs-attr">C:</span> <span class="hljs-number">456</span><br>  <span class="hljs-attr">D:</span> <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><ul><li>其中<code>group</code>是命名空间</li></ul></li><li><p>启动：<code>roslaunch learning_launch turtlesim_parameter_config.launch</code></p></li><li><p>查看参数：<code>rosparam list</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/turtle_number<br>/turtlesim_node/A<br>/turtlesim_node/B<br>/turtlesim_node/group/C<br>/turtlesim_node/group/D<br>/turtlesim_node/turtle_name1<br>/turtlesim_node/turtle_name2<br></code></pre></td></tr></table></figure><ul><li>以上为运行的<code>launch</code>文件中设置的参数</li></ul></li></ul></li><li><p>创建文件<code>start_tf_demo_c++.launch</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Turtlesim Node--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teleop&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;/turtle1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle1_tf_broadcaster&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;/turtle2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle2_tf_broadcaster&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_listener&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;listener&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">roslaunch learning_launch start_tf_demo_c++.launch<br></code></pre></td></tr></table></figure></li><li><p>创建文件<code>start_tf_demo_py.launch</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Turtlesim Node--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teleop&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle1_tf_broadcaster&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster.py&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;turtle1&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle2_tf_broadcaster&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_broadcaster.py&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtle&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;turtle2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;learning_tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtle_tf_listener.py&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;listener&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">roslaunch learning_launch start_tf_demo_py.launch<br></code></pre></td></tr></table></figure></li><li><p>创建<code>turtlesim_remap.launch</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;$(find learning_launch)/launch/simple.launch&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">remap</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&quot;/turtle1/cmd_vel&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/cmd_vel&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="可视化工具">可视化工具</h1><ul><li><p>Qt 工具箱：</p><ul><li>rqt_console：日志输出工具</li><li>rqt_graph：计算图可视化工具</li><li>rqt_plot：数据绘图工具</li><li>rqt_image_view：图像渲染工具</li><li>rqt：命令行直接输入该命令，会打开所有qt工具箱的集合窗口</li></ul></li><li><p>Rviz：</p><ul><li><p>三维可视化工具</p></li><li><p>可以使用XML对机器人、周围物理等任何实物进行尺寸、质量、位置、材质、关节等属性的描述，并且在界面中呈现出来</p></li><li><p>可以通过图形化的方式，实时显示机器人传感器的信息、机器人的运动状态、周围环境的变化等信息</p></li><li><p>rviz通过机器人模型参数、机器人发布的传感信息等数据，为用户进行所有可检测信息的图形化显示。用户和开发者也可以在rviz的控制界面下，通过按钮、滑动条、数值等方式，控制机器人的行为</p></li><li><p>启动方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">roscore<br>rosrun rviz rviz<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Gazebo：</p><ul><li>强大的三维物理仿真平台</li><li>强大的物理引擎、高质量的图形渲染、方便的编程与图形接口、开源免费</li><li>应用场景：<ul><li>测试机器人算法</li><li>机器人的设计</li><li>现实场景下的回溯测试</li></ul></li></ul></li></ul><h1 id="其他学习资料">其他学习资料</h1><p><a href="http://www.autolabor.com.cn/book/ROSTutorials/">Introduction· Autolabor-ROS机器人入门课程《ROS理论与实践》零基础教程</a></p>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ROS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker指北</title>
    <link href="/2023/10/16/Docker%E6%8C%87%E5%8C%97/"/>
    <url>/2023/10/16/Docker%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="docker">Docker</h1><h2 id="快速上手">快速上手</h2><ul><li>docker镜像交流社区：<ahref="https://hub.docker.com/">https://hub.docker.com/</a></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-d</span> \<br>  <span class="hljs-literal">--name</span> mysql \<br>  <span class="hljs-literal">-p</span> <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> \<br>  <span class="hljs-literal">-e</span> TZ=Asia/Shanghai \<br>  <span class="hljs-literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="hljs-number">123</span> \<br>  mysql<br></code></pre></td></tr></table></figure><ul><li><p><code>docker run -d</code>：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</p></li><li><p><code>--name mysql</code> :给容器起个名字叫<code>mysql</code>，你可以叫别的</p></li><li><p><code>-p 3306:3306</code> : 设置端口映射。</p><ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将宿主机端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式：<code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><p><code>-e TZ=Asia/Shanghai</code> :配置容器内进程运行时的一些参数</p><ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><p><code>mysql</code> :设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像</p><ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li><li><p>官方文档：<ahref="https://docs.docker.com/">https://docs.docker.com/</a></p></li><li><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;"><strong>命令</strong></th><th style="text-align: center;"><strong>说明</strong></th><th style="text-align: center;"><strong>文档地址</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">docker pull</td><td style="text-align: center;">拉取镜像</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/pull/">dockerpull</a></td></tr><tr class="even"><td style="text-align: center;">docker push</td><td style="text-align: center;">推送镜像到DockerRegistry</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/push/">dockerpush</a></td></tr><tr class="odd"><td style="text-align: center;">docker images</td><td style="text-align: center;">查看本地镜像</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/images/">dockerimages</a></td></tr><tr class="even"><td style="text-align: center;">docker rmi</td><td style="text-align: center;">删除本地镜像</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/rmi/">dockerrmi</a></td></tr><tr class="odd"><td style="text-align: center;">docker run</td><td style="text-align: center;">创建并运行容器（不能重复创建）</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/run/">dockerrun</a></td></tr><tr class="even"><td style="text-align: center;">docker stop</td><td style="text-align: center;">停止指定容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/stop/">dockerstop</a></td></tr><tr class="odd"><td style="text-align: center;">docker start</td><td style="text-align: center;">启动指定容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/start/">dockerstart</a></td></tr><tr class="even"><td style="text-align: center;">docker restart</td><td style="text-align: center;">重新启动容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/restart/">dockerrestart</a></td></tr><tr class="odd"><td style="text-align: center;">docker rm</td><td style="text-align: center;">删除指定容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr class="even"><td style="text-align: center;">docker ps</td><td style="text-align: center;">查看容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/ps/">dockerps</a></td></tr><tr class="odd"><td style="text-align: center;">docker logs</td><td style="text-align: center;">查看容器运行日志</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/logs/">dockerlogs</a></td></tr><tr class="even"><td style="text-align: center;">docker exec</td><td style="text-align: center;">进入容器</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/exec/">dockerexec</a></td></tr><tr class="odd"><td style="text-align: center;">docker save</td><td style="text-align: center;">保存镜像到本地压缩文件</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/save/">dockersave</a></td></tr><tr class="even"><td style="text-align: center;">docker load</td><td style="text-align: center;">加载本地压缩文件到镜像</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/load/">dockerload</a></td></tr><tr class="odd"><td style="text-align: center;">docker inspect</td><td style="text-align: center;">查看容器详细信息</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/inspect/">dockerinspect</a></td></tr></tbody></table></li><li><p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-comment"># Docker开机自启</span><br>systemctl enable docker<br><br><span class="hljs-comment"># Docker容器开机自启</span><br>docker update <span class="hljs-literal">--restart</span>=always [容器名/容器<span class="hljs-type">id</span>]<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sudo docker exec <span class="hljs-literal">-it</span> nginx bash<br></code></pre></td></tr></table></figure></li></ul><h2 id="深入了解">深入了解</h2><ul><li><p>容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong>。</p></li><li><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机目录</strong>之间映射的桥梁。</p></li><li><p><img src="数据卷.png" alt="数据卷" /></p></li><li><p>将容器中的目录与宿主机目录关联起来，称为<strong>挂载</strong>。此时，操作宿主机中的对应文件目录，就是操作容器内的对应文件目录</p><ul><li><code>/var/lib/docker/volumes</code>这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为<code>/数据卷名/_data</code>。</li></ul></li><li><table><thead><tr class="header"><th style="text-align: center;"><strong>命令</strong></th><th style="text-align: center;"><strong>说明</strong></th><th style="text-align: center;"><strong>文档地址</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">docker volume create</td><td style="text-align: center;">创建数据卷</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/volume_create/">dockervolume create</a></td></tr><tr class="even"><td style="text-align: center;">docker volume ls</td><td style="text-align: center;">查看所有数据卷</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr class="odd"><td style="text-align: center;">docker volume rm</td><td style="text-align: center;">删除指定数据卷</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr class="even"><td style="text-align: center;">docker volume inspect</td><td style="text-align: center;">查看某个数据卷的详情</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr class="odd"><td style="text-align: center;">docker volume prune</td><td style="text-align: center;">清除数据卷</td><td style="text-align: center;"><ahref="https://docs.docker.com/engine/reference/commandline/volume_prune/">dockervolume prune</a></td></tr></tbody></table></li><li><p>如果容器已经创建了，是没有办法再去挂载的，所以要在容器创建的时候就指明挂载。</p></li><li><p>创建容器的过程中，数据卷会自动创建。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-d</span> <span class="hljs-literal">--name</span> nginx <span class="hljs-literal">-p</span> <span class="hljs-number">80</span>:<span class="hljs-number">80</span> <span class="hljs-literal">-v</span> html:/usr/share/nginx/html nginx<br></code></pre></td></tr></table></figure></li></ul><p>给Docker配置代理服务器https://ruohai.wang/202406/docker-config-to-use-proxy-server/</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机指南</title>
    <link href="/2023/10/13/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E5%8D%97/"/>
    <url>/2023/10/13/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机各类问题解决方案">虚拟机各类问题解决方案</h1><ul><li><ahref="https://blog.csdn.net/KRISNAT/article/details/124107032">完美解决VMware安装后没有VMnet1和VMnet8的问题_虚拟机没有vmnet1和vmnet8-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/518319836">Ubuntu22.04vm虚拟机使用宿主机Clash for Windows - 知乎 (zhihu.com)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu指南</title>
    <link href="/2023/08/01/Ubuntu%E6%8C%87%E5%8D%97/"/>
    <url>/2023/08/01/Ubuntu%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<ul><li>更换国内镜像：<ahref="https://blog.csdn.net/Dr_Myst/article/details/125041187?ops_request_misc=%7B%22request%5Fid%22%3A%22169087103016800182159331%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169087103016800182159331&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125041187-null-null.142%5Ev91%5Econtrol_2,239%5Ev12%5Econtrol2&amp;utm_term=ubuntu20.04更换国内源&amp;spm=1018.2226.3001.4187">Ubuntu20.04更换国内镜像源（阿里、网易163、清华、中科大）_ubuntu国内镜像源_MidoQ的博客-CSDN博客</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式数据库总结</title>
    <link href="/2023/05/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <url>/2023/05/30/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第12章-绪论分布式数据库系统设计-总结">第1、2章绪论&amp;分布式数据库系统设计 总结</h1><ol type="1"><li><p>数据库根据其数据模型，可分为<code>关系型数据库(RDBMS)</code>和<code>非关系型数据库(NOSQL)</code>。根据部署架构，可分为<code>集中式数据库</code>和<code>分布式数据库</code>。</p></li><li><p><spanclass="math inline">\(E-R\)</span>模型主要包括<code>实体、属性、联系、连接</code>。</p></li><li><p>在关系<span class="math inline">\(R\)</span>中选择操作记做：<spanclass="math inline">\(\sigma_F(R)=\{r|r\in R\wedgeF(r=&#39;真&#39;)\}\)</span></p></li><li><p>已知两个关系<span class="math inline">\(R\)</span>和<spanclass="math inline">\(S\)</span>如图所示，求关系<spanclass="math inline">\(R\)</span>和<spanclass="math inline">\(S\)</span>的广义笛卡尔积。</p></li><li><p>分布式数据库物理上分散而逻辑上集中的内涵是：<code>指站点之间不是互不相关的，它们是一个逻辑整体，并由一个统一的分布式数据库管理系统进行管理。</code></p></li><li><p>分布式数据库数据分布透明性的内涵是：<code>是指用户不必关心数据是如何被逻辑分片的(数据分片透明性)，不必关心数据及其片段是否被复制及复制副本的个数（数据复制透明性）,也不必关心数据及其片段的物理位置分布的细节(数据位置造明性)，同时也不必关心局部场地上数据库支持哪种数据模型（局部数据模型透明性）。</code></p></li><li><p>数据分片有三种基本方法：<code>水平分片、垂直分片和混合分片。</code></p></li><li><p>闸述数据分片要遵守的原则：</p><ul><li><code>完备性原则</code>：要把全局关系的所有数据映射到各个片段中绝不允许有属于全局关系的数据却不属于它的任何一个片段。</li><li><code>可重构原则</code>：保证能够由同一个全局关系的各个片段来重建该全局关系，对于水平分片可用并操作重构全局关系，对于垂直分片可用连接操作重构全局关系。</li><li><code>不相交原则</code>：一个全局关系被分割后所得的各数据片段互不重叠(对水平分片) 或只包含主键重叠(对垂直分片)。</li></ul></li><li><p>数据分布的含义和方式是：<code>数据分布指分布式数据库中的数据根据需要将数据划分成逻辑片段，按某种策略把数据分片所得的逻辑片段分散地存储在各个站点上。</code>数据分布有<code>集中式、分割式、复制式和混合式。</code></p></li><li><p>数据库系统通常采用三级模式结构，是数据库系统内部系统结构，三级模式分别为：<code>外模式、概念模式、内模式。</code></p></li><li><p>分布式数据库模式结构包括：<code>全局外模式、全局概念模式、分片模式、分配模式、局部概念模式和局部内模式。</code></p></li><li><p>一个分布式数据库管理系统一般应包括四个基本功能模块分别是，<code>查询处理模块、完整性处理模块、调度处理模块和可靠性处理模块。</code></p></li><li><p>分布式数据库的数据分布独立性的含义是：<code>指用户或用户程序使用分布式数据库如同使用集中式数据库那样，不必关心全局数据的分布情况，包括全局数据的逻辑分片情况、逻辑片段的站点位置分配情况，以及各站点上数据库的数据模型等。也就是说，全局数据的逻辑分片、片段的物理位置分配、各站点数据库的数据模型等情况对用户和用户程序透明。</code></p></li><li><p>分布式数据库的分片透明性是指：<code>用户编写应用程序只对全局关系进行操作，不必考虑数据的逻辑分片，当分片模式改变时，只要改变全局概念模式到分片模式之间的映像，就不会影响用户程序，从而实现了数据分片透明性。</code></p></li><li><p>分布式数据库的位置透明性含义是：<code>位置透明性包含两种情形：一种是各片段被复制情况也称复制透明性或数据冗余透明性；另一种是片段及其各副本的站点位置分配情况。当分布式数据库具有位置透明性时，用户编写应用程序要了解全局数据的数据分片情况，但不必了解各逻辑片段的复制副本情况，也不必关心各片段及其副本的站点位置分配情况。</code></p></li><li><p>考全局关系 <span class="math inline">\(SUPPLIER(SNO, SNAME,CITY)\)</span> 被划分为两个逻辑片段<spanclass="math inline">\(S_1\)</span>和<spanclass="math inline">\(S_2\)</span>，若片段<spanclass="math inline">\(S_1\)</span>存放在站点<spanclass="math inline">\(L_1\)</span>上，而片段<spanclass="math inline">\(S_2\)</span>有一个副本，分别存放在站点<spanclass="math inline">\(L_2\)</span>和站点<spanclass="math inline">\(L_3\)</span>上。现在编写一个名为 SUPQUIRY的简单查询应用程序，它将从终端接收一个供应商号，查询该供应商号相应的供应商名，并将它显示在屏幕上。将分析这个应用在逐步减低分布透明性的不同层次上，如何来编写访问此数据库的程序。</p><ul><li><p>分片透明性：只需要考虑全局数据模型，不必考虑数据的如何分片<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">Read(terminal, $SNO);<br><span class="hljs-keyword">Select</span> SNAME <span class="hljs-keyword">into</span> $SNAME<br><span class="hljs-keyword">FROM</span> SUPPLIER<br><span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span>$SNO;<br>WRITE(terminal, $SNAME);<br></code></pre></td></tr></table></figure></p></li><li><p>位置透明性：需要考虑数据的分片，不需要考虑数据的分配<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">Read(terminal, $SNO);<br><span class="hljs-keyword">Select</span> SNAME <span class="hljs-keyword">into</span> $SNAME<br><span class="hljs-keyword">FROM</span> SUPPLIER1<br><span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span>$SNO;<br>if <span class="hljs-keyword">not</span> # FOUND <span class="hljs-keyword">then</span><br><span class="hljs-keyword">Select</span> SNAME <span class="hljs-keyword">into</span> $SNAME<br><span class="hljs-keyword">FROM</span> SUPPLIER2<br><span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span>$SNO;<br>WRITE(terminal, $SNAME);<br></code></pre></td></tr></table></figure></p></li><li><p>本地映射透明性：需要考虑数据的分配，不需要考虑本地的存储位置<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">Read(terminal, $SNO);<br><span class="hljs-keyword">Select</span> SNAME <span class="hljs-keyword">into</span> $SNAME<br><span class="hljs-keyword">FROM</span> SUPPLIER1 <span class="hljs-keyword">AT</span> SITE1<br><span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span>$SNO;<br>if <span class="hljs-keyword">not</span> # FOUND <span class="hljs-keyword">then</span><br><span class="hljs-keyword">Select</span> SNAME <span class="hljs-keyword">into</span> $SNAME<br><span class="hljs-keyword">FROM</span> SUPPLIER2 <span class="hljs-keyword">AT</span> SITE3<br><span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span>$SNO;<br>WRITE(terminal, $SNAME);<br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>分布式数据库的优点有哪些：<code>良好的可靠性和可用性</code>，<code>提高系统效率，降低通信费用</code>，<code>较大的灵活性和可伸缩性</code>，<code>经济性和保护投资</code>，<code>适应组织的分布式管理和控制</code>，<code>数据分布具有透明性和站点具有较好的自治性</code>（良、提、较、经、适、数）。</p></li><li><p>分布式数据库系统设计的两种方法分别是：<code>组合法</code>和<code>重构法</code></p></li><li><p>自顶向下设计分布式数据库的主要步骤包括：<code>需求分析、概念设计、逻辑设计、分布设计和物理设计。</code></p></li><li><p>基本水平分片是指：<code>以关系自身的属性性质为基础，执行“选择”操作，将关系分割成若干个不相交的片段。</code></p></li><li><p>导出水平分片是指：<code>从另一个关系的属性性质或水平分片推导出来。</code></p></li><li><p>垂直分片问题和垂直群集问题的区别是：<code>垂直分片的组必须只在某个键属性上重叠，其他属性不可重叠，而垂直群集的组在其他属性上也可以重叠。</code></p></li><li><p>已知<span class="math inline">\(EMP(E\)</span>#<spanclass="math inline">\(, NAME, SAL, TEL, MAGNUM, DEPT)\)</span>，假定Key：<span class="math inline">\(E\)</span>#，主要用<spanclass="math inline">\(Sa\)</span>站点查询<spanclass="math inline">\(NAME,SAL,TEL\)</span>;<spanclass="math inline">\(Sc\)</span>站点查询<spanclass="math inline">\(NAME,MAGNUM,DEPT\)</span>。给出了一个垂直分片和垂直群集。</p><ul><li>垂直分片：<span class="math inline">\(EMP1(E\)</span>#<spanclass="math inline">\(,NAME,SAL,TEL)\)</span>，<spanclass="math inline">\(EMP2(E\)</span>#<spanclass="math inline">\(,MAGNUM,DEPT)\)</span></li><li>垂直群集：<span class="math inline">\(EMP1(E\)</span>#<spanclass="math inline">\(,NAME,SAL,TEL)\)</span>，<spanclass="math inline">\(EMP2(E\)</span>#<spanclass="math inline">\(,NAME,MAGNUM,DEPT)\)</span></li></ul></li><li><p>针对分布式数据库的数据分配的方法</p><ul><li>非冗余：<code>最佳适应法</code></li><li>冗余分配的设计可选用以下两种方法的一种：<code>所有得益站点法</code>和<code>附加复制法</code>。</li></ul></li><li><p>数据库设计的步骤：</p><ul><li>自顶向下设计分布式数据库步骤：<code>需求分析、概念设计、逻辑设计、分布设计、物理设计</code></li><li>DATA-D设计步骤：<code>需求分析、概念设计、分布要求设计、全局逻辑设计、分布设计、局部逻辑设计、局部物理设计</code></li></ul></li></ol><h1id="第34章-分布式数据库的查询处理和优化分布式数据库中事务管理和恢复">第3、4章分布式数据库的查询处理和优化&amp;分布式数据库中事务管理和恢复</h1><ol type="1"><li><p>在关系代数操作中，五种基本操作为：<code>并</code>、<code>交</code>、<code>笛卡尔积</code>、<code>选择</code>、<code>投影</code></p></li><li><p>设关系R和S如下图所示，求关系R和S的连接：<spanclass="math inline">\(R\infty_{C&lt;E}S\)</span>：</p></li></ol><p><span class="math display">\[R=\\begin{array}{|c|c|c|}\hline A&amp;B&amp;C\\\hline a1&amp;b1&amp;5\\\hline a1&amp;b2&amp;6\\\hline a2&amp;b3&amp;8\\\hline a2&amp;b4&amp;12\\\hline\end{array}\ \ \ \S=\\begin{array}{|c|c|c|}\hline B&amp;E\\\hline b1&amp;3\\\hline b2&amp;7\\\hline b3&amp;10\\\hline b3&amp;2\\\hline b5&amp;2\\\hline\end{array}\\R\infty_{C&lt;E}S=\begin{array}{|c|c|c|}\hline A&amp;R.B&amp;C&amp;R.B&amp;E\\\hline a1&amp;b1&amp;5&amp;b2&amp;7\\\hline a1&amp;b1&amp;5&amp;b3&amp;10\\\hline a1&amp;b2&amp;6&amp;b2&amp;7\\\hline a1&amp;b2&amp;6&amp;b3&amp;10\\\hline a2&amp;b3&amp;8&amp;b3&amp;10\\\hline\end{array}\]</span></p><blockquote><p>各种连接操作合集：</p><ul><li>笛卡尔积：R（m个元组，n个属性），S（a个元组，b个属性），笛卡尔积结果有（a* m个元组，n + b个属性）</li><li>连接运算（<spanclass="math inline">\(\theta\)</span>连接）：从两个关系的笛卡尔积中选取属性间满足一定条件的元组，涉及到两个关系中的属性的比较。</li><li>等值连接：<spanclass="math inline">\(\theta\)</span>为“=”的连接操作</li><li>自然连接：是一种特殊的等值连接，要求两个关系中进行比较的分量必须是相同的属性组，并且要在结果中把重复的属性去掉。<ul><li>【重点】注意是去掉重复的属性，即相同属性名的属性只出现一次，而等值连接中是重复属性重复出现</li></ul></li><li>半连接：自然连接后，仅保留左关系中的属性</li></ul></blockquote><ol start="3" type="1"><li>教学数据库中，有三个全局关系：学生信息<spanclass="math inline">\(S(S\#,SNAME,AGE,SEX)\)</span>，课程设置关系<spanclass="math inline">\(C(C\#,CNAME,TEACHER)\)</span>，选课关系<spanclass="math inline">\(SC(S\#,C\#,GRADE)\)</span>，查询选修课程号为<spanclass="math inline">\(C03\)</span>的学生姓名。请写出该查询要求的其中一种的关系代数表达式，并画出对应的查询树<ul><li>关系代数表达式：<spanclass="math inline">\(\pi_{SNAME}(\sigma_{S.S\#=SC.S\# \wedgeSC.C\#=&#39;C03&#39;}(S\times SC))\)</span></li><li>查询树：<img src="image-20230530201619560.png" /></li></ul></li><li>设关系R和S如下图所示，求关系R和S的等值连接<spanclass="math inline">\(R\infty_{R.B=S.B}S\)</span></li></ol><p><span class="math display">\[R=\\begin{array}{|c|c|c|}\hline A&amp;B&amp;C\\\hline a1&amp;b1&amp;5\\\hline a1&amp;b2&amp;6\\\hline a2&amp;b3&amp;8\\\hline a2&amp;b4&amp;12\\\hline\end{array}\ \ \ \S=\\begin{array}{|c|c|c|}\hline B&amp;E\\\hline b1&amp;3\\\hline b2&amp;7\\\hline b3&amp;10\\\hline b3&amp;2\\\hline b5&amp;2\\\hline\end{array}\\R\infty_{R.B=S.B}S=\begin{array}{|c|c|c|}\hline A&amp;R.B&amp;C&amp;R.B&amp;E\\\hline a1&amp;b1&amp;5&amp;b1&amp;3\\\hline a2&amp;b2&amp;6&amp;b2&amp;7\\\hline a2&amp;b3&amp;8&amp;b3&amp;10\\\hline a2&amp;b3&amp;8&amp;b3&amp;2\\\hline\end{array}\]</span></p><ol start="5" type="1"><li>设关系R和S如下图所示，求关系R和S的半连接<spanclass="math inline">\(R\propto S\)</span></li></ol><p><span class="math display">\[R=\\begin{array}{|c|c|c|}\hline A&amp;B&amp;C\\\hline a1&amp;b1&amp;5\\\hline a1&amp;b2&amp;6\\\hline a2&amp;b3&amp;8\\\hline a2&amp;b4&amp;12\\\hline\end{array}\ \ \ \S=\\begin{array}{|c|c|c|}\hline B&amp;E\\\hline b1&amp;3\\\hline b2&amp;7\\\hline b3&amp;10\\\hline b3&amp;2\\\hline b5&amp;2\\\hline\end{array}\\R\propto S=\begin{array}{|c|c|c|}\hline A&amp;B&amp;C\\\hline a1&amp;b1&amp;5\\\hline a1&amp;b2&amp;6\\\hline a2&amp;b3&amp;8\\\hline\end{array}\]</span></p><ol start="6" type="1"><li><p>查询代价公式：</p><ul><li><p>集中式：<span class="math inline">\(QC=I/O代价 +CPU代价\)</span></p></li><li><p>分布式：<span class="math inline">\(QC=I/O代价 + CPU代价 +通信代价\)</span></p><ul><li>通信代价：<span class="math inline">\(TC(X)=C_0+C_1\timesX\)</span></li></ul></li></ul></li><li><p>分布式环境下的查询可分为三种类型：<code>局部查询</code>、<code>远程查询</code>、<code>全局查询</code></p></li><li><p>分布式查询处理的层次结构：<code>查询分解</code>（转换为关系代数表达式）、<code>数据本地化</code>（将全局关系代数表达式转换为局部的关系代数表达式）、<code>全局优化</code>（找出分片查询的最佳操纵次序，使得代价函数最小）、<code>局部优化</code>（进行局部数据查询优化）</p></li><li><p>阐述基于关系代数等价变换优化算法的基本原理：</p><ul><li><code>把查询问题转变为关系代数表达式，分析得到查询树（语法树），进行从全局到片段的变换得到基于片段上的查询树，然后利用关系代数式等价变换规则的优化算法，尽可能先执行选择和投影操作。这样，一方面可以减少其后操作的操作量，另一方面可以减少操作次数。对该查询树进行优化，从而达到查询优化的目的。</code></li></ul></li><li><p>关系代数等价变换规则</p><ul><li><img src="关系代数等价变换规则.png" alt="事务状态转换图" style="zoom: 50%;" /></li></ul></li><li><p>阐述水平分片关系优化的基本思想：</p><ul><li><code>首先，尽可能把选择条件下移到分片的限定关系处（分片条件），再把分片的限定关系与选择条件进行比较，去掉它们之间存在矛盾的相应片段，如果最后剩下一个水平片段，则重构全局关系的操作中，就可去掉“并”操作 (至少可减少“并”操作的次数)。</code></li></ul></li><li><p>阐述垂直分片关系优化的基本思想：</p><ul><li><code>把垂直分片所用到的属性集，与查询条件（查询表达式）中的投影操作所涉及的属性集相比较，去掉无关的垂直片段。如果只剩下一个垂直片段与查询有关时，去掉重构全局关系的“连接”操作 （至少可减少“连接”操作的次数）。</code></li></ul></li><li><p>请利用半连接方法来表示连接操作</p><ul><li><spanclass="math inline">\(R\infty_{A=B}S=(R\propto_{A=B}S)\infty_{A=B}S=(R\infty_{A=B}(\pi_B(S))\infty_{A=B}S)\)</span></li></ul></li><li><p>阐述采用半连接算法优化连接操作的基本思想：</p><ul><li>采用半连接操作的分布式查询处理的本质是在从一个站点传送关系到另一个站点做连接之前，先除去那些与连接无关的数据，减少做连接操作的关系中的数据量，从而减少传输的代价。因此，基于半连接算法优化连接查询，其基本原理是经半连接操作，可减少操作关系的数据量，从而减少站点间数据的传输量。所以，如果只需要一个关系中的一小部分元组参与和另一个关系连接的话,这是一个使数据传输量最小化的非常有效的方案,此时有<spanclass="math inline">\(T_{半}&lt;T_{全}\)</span>，采用半连接方案是合适的。</li></ul></li><li><p>阐述数据库中事务的概念</p><ul><li><code>事务是访问或更新各种数据项的最小逻辑工作单位；</code></li><li><code>它是一个操作序列；</code></li><li><code>它可以使数据库从一个一致状态到另外一个一致状态；</code></li><li><code>事务必须保证数据库的一致性；</code></li><li><code>事务执行期间数据库可能不一致。</code></li><li>单位、序列、状态、一致性、不一致</li></ul></li><li><p>阐述事务的ACID特性</p><ul><li><code>原子性 Atomicity：事务的操作要么全部执行，要门全部不执行，保证数据库一致性状态。</code></li><li><code>一致性 Consistency：事务的正确性、串行性。</code></li><li><code>隔离性 Isolation：单个事务的执行不应该感知其他事务的存在，因此事务执行的中间结果应该对其他事务隐藏</code></li><li><code>持久性 Durability：当事务提交后，其操作的结果将永久化</code></li></ul></li><li><p>列举分布式事务的状态</p><ul><li><code>活动：从事务开始执行的初始状态开始，事务执行中保持该状态</code></li><li><code>部分提交：事务的最后一个语句执行后进入该状态</code></li><li><code>失败：一旦发现事务不能正常执行时进入该状态</code></li><li><code>夭折：当事务被回滚后，数据库恢复到事务开始执行前的状态。事务夭折后有两种选择</code><ul><li><code>重启动 redo：仅当没有内部错误逻辑时</code></li><li><code>杀死 undo</code></li></ul></li><li><code>提交：当事务成功执行后</code></li><li><img src="事务状态转换图.png" alt="事务状态转换图" style="zoom: 50%;" /></li></ul></li><li><p>分布式事务管理器的功能有哪些</p><ul><li><code>保证分布式事务ACID特性</code></li><li><code>负责协调由该站点发出的所有分布式事务的执行</code></li><li><code>支持分布式事务执行位置透明性</code></li></ul></li><li><p>本地事务管理器 LTM 的功能</p><ul><li><code>保证本地事务 ACID 特性</code></li><li><code>维护日志</code></li><li><code>参与适当的并发控制</code></li></ul></li><li><p>分布式事务执行的控制模型有哪些</p><ul><li><code>主从模型：主、从控制器，LTM之间无通信</code><ul><li><img src="主从控制模型.png" /></li></ul></li><li><code>三角模型：LTM之间可以传递数据，避免了主从之间不必要的传输</code><ul><li><img src="三角控制模型.png" alt="三角控制模型" style="zoom: 67%;" /></li></ul></li><li><code>层次控制模型：LTM还可创建Agent，控制其他LTM执行，比前两种复杂</code><ul><li><img src="层次控制模型.png" alt="层次控制模型" style="zoom: 67%;" /></li></ul></li></ul></li><li><p>什么时候达到事务的提交点</p><ul><li><code>当事务T所有的站点数据库存取操作都已成功执行，所有操作对数据库的影响都已记录在日志中，到达提交点。</code></li></ul></li><li><p>如图所示的故障时刻和提交点的位置，以及每个事务的执行时间区间，请问那些事务需要redo，那些事务需要 undo</p><ul><li><img src="image-20230530205049811.png" alt="image-20230530205049811" style="zoom: 67%;" /></li><li>事务<span class="math inline">\(T_2\)</span>和事务<spanclass="math inline">\(T_3\)</span>需要 redo，事务<spanclass="math inline">\(T_4\)</span>需要 undo</li><li>有逻辑错误的 undo，在上一个检查点到下一个检查点之间的提交的事务redo</li></ul></li><li><p>故障类型：</p><ul><li>事务故障</li><li>系统故障</li><li>介质故障<ul><li>前三种称为站点故障</li></ul></li><li>通讯故障</li></ul></li><li><p>两阶段提交协议包括哪两个阶段</p><ul><li><code>第一阶段：表决阶段</code></li><li><code>第二阶段：执行阶段</code></li></ul></li><li><p>阐述两阶段提交协议：<code>（应该会考）</code></p><ul><li><code>表决阶段：首先，协调者给所有参与者发送“准备”消息，进入等待状态。其次，参与者收到“准备”消息后，检查是否能够提交本地事务，如能，给协调者发送“建议提交”消息，进入就绪状态；如不能，给协调者发送“建议撤销”消息，可以单方面撤销。第三，协调者收到所有参与者的消息后，他就做出是否提交事务的决定，只要有一个参与者投了反对票,就决定撤销整个事务，发送“全局撤销”消息给所有参与者，进入撒销状态，否则，就决定提交整个事务，发送“全局提交”消息给所有参与者，进入提交状态。</code></li><li><code>执行阶段：实现表决阶段的决定，提交或者撤销。</code></li></ul></li><li><p>阐述主文本更新法的思想：</p><ul><li><code>指定主副本，修改只对主副本进行，修改辅助副本时，也按在主副本上执行的更新顺序执行。</code></li></ul></li></ol><h1 id="第56章-分布式数据库中的并发控制分布式数据库中的可靠性">第5、6章分布式数据库中的并发控制&amp;分布式数据库中的可靠性</h1><ol type="1"><li>分布式数据库并发控制的作用<ul><li><code>解决多个分布式事务对数据并发执行的正确性</code></li><li><code>保证数据库的完整性和一致性</code></li></ul></li><li>什么是可串行化调度<ul><li><code>如果一个调度等价于某个串行调度，则该调度称为可串行化调度。也就是说，该调度可以通过一系列非冲突动作的交换操作使其成为可串行化调度</code></li></ul></li><li>优先图的画法</li><li>调度<span class="math inline">\(S\)</span>的可串行化的条件是<ul><li><code>当且仅当优先图中没有闭环时，调度$S$是可串行化的</code></li></ul></li><li>并发控制算法：<ul><li><code>悲观法</code><ul><li><code>加锁法</code><ul><li><code>集中式加锁</code></li><li><code>主副本加锁</code></li><li><code>分布式加锁</code></li></ul></li><li><code>时标排序法</code><ul><li><code>基本时标排序</code></li><li><code>多版本时标排序</code></li><li><code>保守时标排序</code></li></ul></li><li><code>混合法</code></li></ul></li><li><code>乐观法</code><ul><li><code>加锁法</code></li><li><code>时标排序法</code></li></ul></li></ul></li><li>分布式数据库系统并发控制机制的封锁技术中，锁的类型有哪几种？<ul><li><code>共享锁：Share 锁、S 锁或者读锁</code></li><li><code>排他锁：eXclusive 锁，X锁，拒绝锁或写锁</code></li><li><code>更新锁：Update 锁、U 锁</code></li></ul></li><li>两阶段封锁协议的两阶段指的是哪两个阶段<ul><li><code>上升阶段（成长阶段）：获取 Lock 阶段（只能获取锁）</code></li><li><code>收缩阶段（衰退阶段）：释放 Lock 阶段（只能解锁）</code></li></ul></li><li>保守两阶段封锁协议：<ul><li><code>事务在开始执行前就持有所有锁</code></li><li><code>要预先定义读集和写集</code></li></ul></li><li>严格两阶段封锁协议的特点：<ul><li><code>事务在提交或者撤销之前，绝对不释放任何一个写锁。</code></li><li><code>事务结束时（提交或者撤销），同时释放所有锁。</code></li></ul></li><li>严酷两阶段封锁协议的特点：</li></ol><ul><li><code>事务在提交或者撤销之前，绝对不释放任何一个锁。</code></li><li><code>事务结束时（提交或者撤销），同时释放所有锁。</code></li></ul><ol start="11" type="1"><li>保守和严酷的区别<ul><li><code>保守一开始就处在收缩阶段</code></li><li><code>严酷一直处于扩张阶段</code></li></ul></li><li>意向锁的类型：<ul><li><code>意向共享锁（IS）：指示在其后代节点上将会请求共享锁，即如果对某个对象加 IS 锁，表示它的后代结点拟加共享锁。</code></li><li><code>意向排他锁（IX）：指示在其后代节点上将会请求排他锁，即如果对某个对象加 IX 锁，表示它的后代结点拟加排他锁。</code></li><li><code>共享意向排他锁（SIX）：指示当前节点处在共享方式的封锁中，但是在它的某些后代节点中将会请求排他锁。即如果对一个数据对象加 SIX 锁，表示对它加共享锁，再加 IX 锁（SIX = S + IX）。例如：对某个表加 SIX 锁，则表示该事务要读整个表（加 S 锁），同时会更新个别元组（加 IX 锁）。</code></li></ul></li><li>有死锁危险时，事务退出已占有的资源，有两种方法<ul><li><code>等待-死亡（Wait-Die）：总是重启较年轻的事务（非占先权）</code><ul><li><code>老的等待、新的死亡</code></li></ul></li><li><code>受伤-等待（Wound-Wait）：年轻的等待年老的，较年轻的重启，而重启事务并不一定是目前正申请的事务（占先权）</code><ul><li><code>老的受伤（阻塞）、新的等待</code></li></ul></li></ul></li><li>保守时标法的思想是什么<ul><li><code>一种消除重启动的方法，通过缓冲年轻的操作。直至年长的操作执行完成，因此操作不会被拒绝，事务也绝不被重启动。</code></li></ul></li><li>MTTR、MTTF、MTBF、MTBR</li><li>三阶段提交协议比两阶段提交协议在协调者和参与者增加了什么状态<ul><li><code>准备提交状态</code></li></ul></li><li>分布式可靠性协议有哪些协议组成<ul><li><code>提交协议、终结协议、恢复协议</code></li></ul></li><li>提交协议的作用<ul><li><code>详细说明提交命令是如何执行的</code></li></ul></li><li>分布式系统的终结协议的作用是什么<ul><li><code>在执行一个分布式事务时，若一个站点出现故障，可以调用终止协议使得其他站点也停止该事务</code></li></ul></li><li>恢复协议：<ul><li><code>详细说明恢复命令是如何执行的</code></li></ul></li><li>阐述事务阻断的含义<ul><li><code>某个站点上本来可以终结（提交或撤销）的子事务，由于分布式数据库系统出现故障，必须等待到故障恢复（其占有的资源不释放）</code></li></ul></li><li>用自己的语言阐述三阶段提交协议<ul><li><img src="三阶段提交协议.png" alt="image-20230530205049811" style="zoom: 67%;" /></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>分布式数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典神经网络-Inception</title>
    <link href="/2023/05/26/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-Inception/"/>
    <url>/2023/05/26/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-Inception/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>Inception 是一种经典的神经网络架构，由斯坦福大学的研究团队于 2014年提出。它的设计灵感来自人类视觉系统的分层处理方式。</p><p>Inception 网络的主要创新是引入了 Inception模块，这是一种并行结构，它同时进行多种不同大小的卷积操作，并通过最大池化和平均池化来融合不同尺度的特征图。这种并行操作能够有效地捕捉不同层次的视觉特征，使网络能够在不同尺度和层次上进行信息提取。</p><p>Inception 网络的整体结构是一个深度卷积神经网络，包含多个堆叠的Inception模块和全局平均池化层。它通过多层卷积和池化操作来逐步提取和组合图像的特征，最后通过全连接层进行分类或回归任务。</p><p>Inception网络在图像分类、目标检测和图像分割等计算机视觉任务中取得了很好的效果。它的创新之处在于通过并行操作和多尺度特征融合，提高了网络对于不同尺度和层次的特征的感知能力，使得网络在处理复杂图像时更加有效和准确。</p><p>Inception 网络的成功也启发了后续的神经网络设计，例如 InceptionV2、Inception V3 等版本的网络，它们进一步优化了 Inception模块的结构和参数设置，提高了网络的性能和效率。Inception网络的创新思想对于神经网络的发展和应用具有重要的影响。</p><p>inception 是盗梦空间的英文名，最初论文的参考文献1就写了该电影</p><h1 id="inception-v1">Inception V1</h1><p>Inception V1，也被称为 GoogLeNet，是第一个采用 Inception模块的神经网络架构。它的设计目标是解决传统深度神经网络在参数数量和计算复杂度上的问题。InceptionV1 采用了多个并行的 Inception模块，其中包含了不同尺度的卷积操作和池化操作。通过多个并行分支的组合，网络能够在不同尺度上提取图像特征，并通过适当的参数共享来减少网络的参数量。此外，InceptionV1 还引入了<spanclass="math inline">\(1\times1\)</span>的卷积操作，用于减少通道维度的计算负担，并提高特征的表达能力。</p><p>GoogLeNet 在 2014 年的 ImageNet图像分类挑战中获得了优异的成绩，表明了 Inception架构在深度神经网络中的有效性和实用性。它的创新思想影响了后续的神经网络设计，并成为了许多重要模型的基础。</p><p>GoogLeNet 中最后五个字母是为了致敬 LeNet 网络</p><p>用不同大小的卷积核对图像进行卷积，把卷积得到的结果concatenate结合在一起</p><p>inception模块</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>conda指南</title>
    <link href="/2023/05/25/conda%E6%8C%87%E5%8D%97/"/>
    <url>/2023/05/25/conda%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="conda-使用教程">Conda 使用教程</h1><h2 id="扫盲">扫盲</h2><p>安装教程：https://zhuanlan.zhihu.com/p/459601766</p><p>Anaconda 是专注于数据分析的 Python 发行版本，包含了 conda、Python 等190 多个科学包及其依赖项。</p><h2 id="命令">命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">conda list<span class="hljs-comment"># 查看环境中的所有包</span><br>conda install XXX<span class="hljs-comment"># 安装 XXX 包</span><br>conda remove XXX<span class="hljs-comment"># 删除 XXX 包</span><br>conda env list<span class="hljs-comment"># 列出所有环境</span><br>conda create <span class="hljs-literal">-n</span> XXX<span class="hljs-comment"># 创建名为 XXX 的环境，-n 为 -name</span><br>conda create <span class="hljs-literal">-n</span> env_name jupyter notebook<span class="hljs-comment"># 创建虚拟环境，同时将jupyter notebook加入环境中</span><br>activate noti / source activate noti<span class="hljs-comment"># 启用/激活环境</span><br>conda env remove <span class="hljs-literal">--name</span> noti<span class="hljs-comment"># 删除指定环境</span><br>deactivate / source deactivate<span class="hljs-comment"># 退出环境</span><br>jupyter notebook<span class="hljs-comment"># 打开Jupyter Notebook</span><br>conda config <span class="hljs-literal">--remove-key</span> channels<span class="hljs-comment"># 换回默认源</span><br></code></pre></td></tr></table></figure><h2 id="配置清华镜像">配置清华镜像</h2><p>https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch快速入门</title>
    <link href="/2023/05/13/Pytorch%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2023/05/13/Pytorch%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>Pytorch官方教程：<a href="https://pytorch.org/tutorials/">Welcome toPyTorch Tutorials — PyTorch Tutorials 2.0.1+cu117 documentation</a></p><h1 id="张量-tensors">张量 TENSORS</h1><p>张量是一种特殊的数据结构，与数组和矩阵非常相似。在 PyTorch中，我们使用张量对模型的输入和输出以及模型的参数进行编码。</p><p>张量类似于NumPy 的ndarrays，不同之处在于张量可以在 GPU或其他硬件加速器上运行。事实上，张量和 NumPy数组通常可以共享相同的底层内存，从而无需复制数据。张量也针对自动微分进行了优化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><h2 id="初始化张量">初始化张量</h2><h3 id="直接来自数据">直接来自数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">data = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br>x_data = torch.tensor(data)<br></code></pre></td></tr></table></figure><h3 id="来自-numpy-数组">来自 NumPy 数组</h3><p>可以从NumPy数据创建张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np_array = np.array(data)<br>x_np = torch.from_numpy(np_array)<br></code></pre></td></tr></table></figure><h3 id="从另一个张量">从另一个张量</h3><p>除非明确覆盖，否则新张量保留参数张量的属性（形状、数据类型）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x_ones = torch.ones_like(x_data) <span class="hljs-comment"># retains the properties of x_data</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Ones Tensor: \n <span class="hljs-subst">&#123;x_ones&#125;</span> \n&quot;</span>)<br><br>x_rand = torch.rand_like(x_data, dtype=torch.<span class="hljs-built_in">float</span>) <span class="hljs-comment"># overrides the datatype of x_data</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Random Tensor: \n <span class="hljs-subst">&#123;x_rand&#125;</span> \n&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="使用随机值或常数值">使用随机值或常数值</h3><p><code>shape</code>是张量维度的元组。在下面的函数中，它决定了输出张量的维数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">shape = (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,)<br>rand_tensor = torch.rand(shape)<br>ones_tensor = torch.ones(shape)<br>zeros_tensor = torch.zeros(shape)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Random Tensor: \n <span class="hljs-subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Ones Tensor: \n <span class="hljs-subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Zeros Tensor: \n <span class="hljs-subst">&#123;zeros_tensor&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="张量的属性">张量的属性</h2><p>张量属性描述了它们的形状、数据类型和存储它们的设备。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.rand(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Shape of tensor: <span class="hljs-subst">&#123;tensor.shape&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Datatype of tensor: <span class="hljs-subst">&#123;tensor.dtype&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Device tensor is stored on: <span class="hljs-subst">&#123;tensor.device&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>tensor.device</code>：说明该张量存储在哪个设备上，有cpu等</p><h2 id="张量运算">张量运算</h2><p>具体运算：https://pytorch.org/docs/stable/torch.html</p><p>此处仅简要了解</p><p>以上张量运算的每一步都可以再GPU上运行（速度通常高于CPU）、</p><p>默认情况下，张量是在 CPU 上创建的。我们需要使用方法将张量显式移动到GPU <code>.to</code>（在检查 GPU可用性之后）。请记住，跨设备复制大型张量在时间和内存方面可能会很昂贵！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将 tensor 移动到GPU，如果GPU可用的话</span><br><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>    tensor = tensor.to(<span class="hljs-string">&quot;cuda&quot;</span>)<br></code></pre></td></tr></table></figure><p>类似于 numpy 的索引和切片操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.ones(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;First row: <span class="hljs-subst">&#123;tensor[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;First column: <span class="hljs-subst">&#123;tensor[:, <span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Last column: <span class="hljs-subst">&#123;tensor[..., -<span class="hljs-number">1</span>]&#125;</span>&quot;</span>)<br>tensor[:,<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(tensor)<br></code></pre></td></tr></table></figure><p>连接张量，可以使用torch.cat沿着给定维度连接一系列张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = torch.cat([tensor, tensor, tensor], dim=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(t1)<br></code></pre></td></tr></table></figure><h3 id="算术运算">算术运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以下 y1, y2, y3 有相同的值</span><br>y1 = tensor @ tensor.T<br>y2 = tensor.matmul(tensor.T)<br><br>y3 = torch.rand_like(y1)<br>torch.matmul(tensor, tensor.T, out=y3)<br><br><br><span class="hljs-comment"># 以下 z1, z2, z3 有相同的值</span><br>z1 = tensor * tensor<br>z2 = tensor.mul(tensor)<br><br>z3 = torch.rand_like(tensor)<br>torch.mul(tensor, tensor, out=z3)<br></code></pre></td></tr></table></figure><p>对于单元素张量，可以取其值并转化为 python 中的基本元素类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">agg = tensor.<span class="hljs-built_in">sum</span>()<br>agg_item = agg.item()<br><span class="hljs-built_in">print</span>(agg_item, <span class="hljs-built_in">type</span>(agg_item))<br></code></pre></td></tr></table></figure><h3 id="就地操作">就地操作</h3><p>如果需要将运算结果存储其中一个操作数中，则在运算后加上下划线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;tensor&#125;</span> \n&quot;</span>)<br>tensor.add_(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(tensor)<br></code></pre></td></tr></table></figure><blockquote><p>就地操作可以节省一些内存，但在计算导数时可能会出现问题，因为会立即丢失历史记录。因此，不鼓励使用它们。</p></blockquote><h2 id="桥接-numpy">桥接 NumPy</h2><p>CPU 和 NumPy数组上的张量可以共享它们的底层内存位置，改变一个就会改变另一个。</p><h3 id="张量到-numpy-数组">张量到 NumPy 数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">t = torch.ones(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t: <span class="hljs-subst">&#123;t&#125;</span>&quot;</span>)<br>n = t.numpy()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n: <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>对张量进行操作，即对 Numpy 数组进行操作</p><h3 id="numpy-数组到-tensor">NumPy 数组到 Tensor</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">n = np.ones(<span class="hljs-number">5</span>)<br>t = torch.from_numpy(n)<br></code></pre></td></tr></table></figure><h1 id="数据集和数据加载器">数据集和数据加载器</h1><p>处理数据样本的代码可能会变得混乱且难以维护；理想情况下，我们希望数据集代码与模型训练代码分离，以提高可读性和模块化。PyTorch提供了两种数据原语：<code>torch.utils.data.DataLoader</code>和<code>torch.utils.data.Dataset</code>允许使用预加载的数据集以及自己的数据。<code>Dataset</code>存储样本及其相应的标签，<code>DataLoader</code>将一个迭代器包装在<code>Dataset</code> 周围，以便轻松访问样本。</p><p>PyTorch 域库提供了许多预加载的数据集（例如 FashionMNIST），它们是<code>torch.utils.data.Dataset</code>的子类，并实现特定数据的特定功能。它们可用于对模型进行原型设计和基准测试。您可以在这里找到它们：<ahref="https://pytorch.org/vision/stable/datasets.html">图像数据集</a>、<a href="https://pytorch.org/text/stable/datasets.html">文本数据集</a>和<ahref="https://pytorch.org/audio/stable/datasets.html">音频数据集</a></p><h2 id="加载数据集">加载数据集</h2><p>下面是一个如何从 <code>TorchVision</code> 加载<ahref="https://research.zalando.com/project/fashion_mnist/fashion_mnist/">Fashion-MNIST</a>数据集的示例。Fashion-MNIST是 Zalando 的文章图像数据集，由 60000 个训练示例和 10000个测试示例组成。每个示例包含一个 28×28 的灰度图像和来自 10个类别之一的关联标签。</p><p>我们使用以下参数加载<ahref="https://pytorch.org/vision/stable/datasets.html#fashion-mnist">FashionMNIST数据集：</a></p><ul><li><code>root</code>是存储训练/测试数据的路径，</li><li><code>train</code>指定训练或测试数据集，</li><li><code>download=True</code>如果在<code>root</code>处不可用，则从Internet 下载数据。</li><li><code>transform</code>并<code>target_transform</code>指定特征和标签转换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> torchvision.transforms <span class="hljs-keyword">import</span> ToTensor<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>training_data = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">True</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor()<br>)<br><br>test_data = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">False</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor()<br>)<br></code></pre></td></tr></table></figure><h2 id="迭代和可视化数据集">迭代和可视化数据集</h2><p>我们可以像列表一样手动索引<code>Datasets</code>：<code>training_data[index]</code>。我们使用<code>matplotlib</code>可视化训练数据中的一些样本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">figure = plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br>cols, rows = <span class="hljs-number">3</span>, <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, cols * rows + <span class="hljs-number">1</span>):<br>    <span class="hljs-comment"># torch.randint()函数中，size参数不可省略，并且生成一维数组时，需要在后面加上逗号，否则会报错。</span><br>    sample_idx = torch.randint(<span class="hljs-built_in">len</span>(training_data), size=(<span class="hljs-number">1</span>,)).item()<br>    img, label = training_data[sample_idx]<br>    figure.add_subplot(rows, cols, i)<br>    plt.title(labels_map[label])<br>    <span class="hljs-comment"># 关闭坐标轴</span><br>    plt.axis(<span class="hljs-string">&quot;off&quot;</span>)<br>    <span class="hljs-comment"># img.squeeze() 去掉维数为 1 的维度</span><br>    plt.imshow(img.squeeze(), cmap=<span class="hljs-string">&quot;gray&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="创建自定义-dataset">创建自定义 Dataset</h2><p>自定义的数据集类必须实现三个函数：<em>__int__</em>,<em>__len__</em>,<em>__getitem__</em>，看看这个实现；FashionMNIST 图像存储在目录 img_dir 中，它们的标签分别存储在 CSV 文件annotations_file 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> torchvision.io <span class="hljs-keyword">import</span> read_image<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomImageDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-comment"># __init__ 函数在实例化 Dataset 对象时运行一次。 我们初始化包含图像、注释文件和两个转换的目录（下一节将详细介绍）。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, annotations_file, img_dir, transform=<span class="hljs-literal">None</span>, target_transform=<span class="hljs-literal">None</span></span>):<br>        self.img_labels = pd.read_csv(annotations_file)<br>        self.img_dir = img_dir<br>        self.transform = transform<br>        self.target_transform = target_transform<br><span class="hljs-comment"># __len__ 函数返回数据集中的样本数。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.img_labels)<br><span class="hljs-comment"># __getitem__ 函数从给定索引 idx 的数据集中加载并返回样本。 根据索引，它识别图像在磁盘上的位置，使用 read_image 将其转换为张量，从 self.img_labels 中的 csv 数据中检索相应的标签，调用它们的转换函数（如果适用），并返回张量图像和元组中的相应标签。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, <span class="hljs-number">0</span>])<br>        image = read_image(img_path)<br>        label = self.img_labels.iloc[idx, <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> self.transform:<br>            image = self.transform(image)<br>        <span class="hljs-keyword">if</span> self.target_transform:<br>            label = self.target_transform(label)<br>        <span class="hljs-keyword">return</span> image, label<br></code></pre></td></tr></table></figure><h2 id="准备数据以使用-dataloaders-进行训练">准备数据以使用 DataLoaders进行训练</h2><p>数据集检索我们数据集的特征并一次标记一个样本。在训练模型时，我们通常希望以“小批量”传递样本，在每个时期重新调整数据以减少模型过度拟合，并使用Python 的多处理来加速数据检索。</p><p>DataLoader 是一个可迭代对象，它通过一个简单的 API为我们抽象了这种复杂性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br>train_dataloader = DataLoader(training_data, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)<br>test_dataloader = DataLoader(test_data, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="遍历-dataloader">遍历 DataLoader</h2><p>我们已经将该数据集加载到 DataLoader 中，并且可以根据需要迭代数据集。下面的每次迭代都会返回一批 train_features 和 train_labels（分别包含batch_size=64 个特征和标签）。 因为我们指定了shuffle=True，所以在我们遍历所有批次之后，数据将被打乱（为了更细粒度地控制数据加载顺序，请查看采样器）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 展示 image 和 label.</span><br><span class="hljs-comment"># 将 train_dataloader 转换成迭代器，然后取第一个值</span><br>train_features, train_labels = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(train_dataloader))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Feature batch shape: <span class="hljs-subst">&#123;train_features.size()&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Labels batch shape: <span class="hljs-subst">&#123;train_labels.size()&#125;</span>&quot;</span>)<br>img = train_features[<span class="hljs-number">0</span>].squeeze()<br>label = train_labels[<span class="hljs-number">0</span>]<br>plt.imshow(img, cmap=<span class="hljs-string">&quot;gray&quot;</span>)<br>plt.show()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Label: <span class="hljs-subst">&#123;label&#125;</span>&quot;</span>)<br><span class="hljs-comment"># output：</span><br><span class="hljs-comment"># Feature batch shape: torch.Size([64, 1, 28, 28])</span><br><span class="hljs-comment"># Labels batch shape: torch.Size([64])</span><br><span class="hljs-comment"># Label: 7</span><br></code></pre></td></tr></table></figure><h1 id="转换-transform">转换 TRANSFORM</h1><p>数据并不总是以训练机器学习算法所需的最终处理形式出现。 我们使用转换transforms 对数据进行一些操作，使其适合训练。</p><p>所有 TorchVision 数据集都有两个参数 -transform 修改特征和target_transform 修改标签 - 接受包含转换逻辑的可调用文件。torchvision.transforms 模块提供了几种开箱即用的常用转换。</p><p>FashionMNIST 特征是 PIL 图像格式，标签是整数。对于训练，我们需要将特征作为归一化张量，并将标签作为 One-Hot 编码张量。为了进行这些转换，我们使用了 ToTensor 和 Lambda。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> torchvision.transforms <span class="hljs-keyword">import</span> ToTensor, Lambda<br><br>ds = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">True</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor(),<br>    target_transform=Lambda(<span class="hljs-keyword">lambda</span> y: torch.zeros(<span class="hljs-number">10</span>, dtype=torch.<span class="hljs-built_in">float</span>).scatter_(<span class="hljs-number">0</span>, torch.tensor(y), <span class="hljs-number">1</span>))<br>)<br></code></pre></td></tr></table></figure><h2 id="totensor">ToTensor()</h2><p>ToTensor 将 PIL 图像或 NumPy ndarray 转换为 FloatTensor。 并在 [0.,1.] 范围内缩放图像的像素强度值</p><h2 id="lambda-transforms">Lambda Transforms</h2><p>Lambda 转换应用任何用户定义的 lambda 函数。在这里，我们定义了一个函数来将整数转换为单热编码张量。它首先创建一个大小为 10 的零张量（我们数据集中标签的数量）并调用scatter_，它在标签 y 给定的索引上分配一个 value=1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target_transform=Lambda(<span class="hljs-keyword">lambda</span> y: torch.zeros(<span class="hljs-number">10</span>, dtype=torch.<span class="hljs-built_in">float</span>).scatter_(<span class="hljs-number">0</span>, torch.tensor(y), <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h1 id="构建神经网络">构建神经网络</h1><p>神经网络由对数据执行操作的 <code>层/模块</code> 组成。 torch.nn命名空间提供了构建自己的神经网络所需的所有构建块。 PyTorch中的每个模块都是 nn.Module 的子类。神经网络本身就是一个由其他模块（层）组成的模块。这种嵌套结构允许轻松构建和管理复杂的体系结构。</p><p>在接下来的部分中，我们将构建一个神经网络来对 FashionMNIST数据集中的图像进行分类。</p><p>首先我们导入如下库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets, transforms<br></code></pre></td></tr></table></figure><h2 id="获取训练设备">获取训练设备</h2><p>如果可用，我们希望能够在 GPU 或 MPS 等硬件加速器上训练我们的模型。让我们检查一下 torch.cuda 或 torch.backends.mps 是否可用，否则我们使用CPU。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">device = (<br>    <span class="hljs-string">&quot;cuda&quot;</span><br>    <span class="hljs-keyword">if</span> torch.cuda.is_available()<br>    <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;mps&quot;</span><br>    <span class="hljs-keyword">if</span> torch.backends.mps.is_available()<br>    <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span><br>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Using <span class="hljs-subst">&#123;device&#125;</span> device&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="定义类">定义类</h2><p>我们通过子类化 <code>nn.Module</code> 来定义我们的神经网络，并在<code>__init__</code> 中初始化神经网络层。 每个 nn.Module 子类都在forward 方法中实现对输入数据的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NeuralNetwork</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 将数据连续的维度范围展成张量，torch.nn.Flatten(start_dim=1, end_dim=-1)，注意维度从0开始，0维度是各样本值</span><br>        self.flatten = nn.Flatten()<br>        <br>        self.linear_relu_stack = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">28</span>*<span class="hljs-number">28</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">10</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.flatten(x)<br>        logits = self.linear_relu_stack(x)<br>        <span class="hljs-keyword">return</span> logits<br></code></pre></td></tr></table></figure><p>我们创建一个 <code>NeuralNetwork</code>的实例，并将其移动到<code>device</code>上，并打印其结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">model = NeuralNetwork().to(device)<br><span class="hljs-built_in">print</span>(model)<br><br><span class="hljs-comment"># output：</span><br><span class="hljs-comment"># NeuralNetwork(</span><br><span class="hljs-comment">#   (flatten): Flatten(start_dim=1, end_dim=-1)</span><br><span class="hljs-comment">#   (linear_relu_stack): Sequential(</span><br><span class="hljs-comment">#     (0): Linear(in_features=784, out_features=512, bias=True)</span><br><span class="hljs-comment">#     (1): ReLU()</span><br><span class="hljs-comment">#     (2): Linear(in_features=512, out_features=512, bias=True)</span><br><span class="hljs-comment">#     (3): ReLU()</span><br><span class="hljs-comment">#     (4): Linear(in_features=512, out_features=10, bias=True)</span><br><span class="hljs-comment">#   )</span><br><span class="hljs-comment"># )</span><br></code></pre></td></tr></table></figure><blockquote><p>要使用该模型，我们将输入数据传递给它。这将执行模型的<code>forward</code>以及一些后台操作。 不要直接调用<code>model.forward()</code> ！</p></blockquote><p>在输入上调用模型会返回一个二维张量，其中 dim=0 对应于每个类别的 10个原始预测值的每个输出，dim=1 对应于每个输出的各个值。 我们通过nn.Softmax 模块的实例传递它来获得预测概率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X = torch.rand(<span class="hljs-number">1</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, device=device)<br>logits = model(X)<br>pred_probab = nn.Softmax(dim=<span class="hljs-number">1</span>)(logits)<br>y_pred = pred_probab.argmax(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Predicted class: <span class="hljs-subst">&#123;y_pred&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="model-layers">Model Layers</h2><p>让我们分解 FashionMNIST 模型中的层。 为了说明这一点，我们将取一个包含3 张大小为 28x28的图像的小批量样本，看看当我们将它传递给网络时会发生什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">input_image = torch.rand(<span class="hljs-number">3</span>,<span class="hljs-number">28</span>,<span class="hljs-number">28</span>)<br><span class="hljs-built_in">print</span>(input_image.size())<br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># torch.Size([3, 28, 28])</span><br></code></pre></td></tr></table></figure><h3 id="nn.flatten">nn.Flatten</h3><p>我们初始化 <code>nn.Flatten</code> 层以将每个 2D 28x28 图像转换为 784个像素值的连续数组（保持小批量维度（dim=0））。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">flatten = nn.Flatten()<br>flat_image = flatten(input_image)<br><span class="hljs-built_in">print</span>(flat_image.size())<br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># torch.Size([3, 784])</span><br></code></pre></td></tr></table></figure><h3 id="nn.linear">nn.Linear</h3><p>线性层是一个模块，它使用其存储的权重和偏差对输入应用线性变换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">layer1 = nn.Linear(in_features=<span class="hljs-number">28</span>*<span class="hljs-number">28</span>, out_features=<span class="hljs-number">20</span>)<br>hidden1 = layer1(flat_image)<br><span class="hljs-built_in">print</span>(hidden1.size())<br><span class="hljs-comment"># output：</span><br><span class="hljs-comment"># torch.Size([3, 20])</span><br></code></pre></td></tr></table></figure><h3 id="nn.relu">nn.ReLU</h3><p>非线性激活是在模型的输入和输出之间创建复杂映射的原因。它们在线性变换之后应用以引入非线性，帮助神经网络学习各种各样的现象。</p><p>在此模型中，我们在线性层之间使用nn.ReLU，但还有其他激活在您的模型中引入非线性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Before ReLU: <span class="hljs-subst">&#123;hidden1&#125;</span>\n\n&quot;</span>)<br>hidden1 = nn.ReLU()(hidden1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;After ReLU: <span class="hljs-subst">&#123;hidden1&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="nn.sequential">nn.Sequential</h3><p>nn.Sequential 是一个有序的模块容器。数据按照定义的相同顺序通过所有模块。 你可以使用顺序容器来组合一个像<code>seq_modules</code> 这样的快速网络。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">seq_modules = nn.Sequential(<br>    flatten,<br>    layer1,<br>    nn.ReLU(),<br>    nn.Linear(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>)<br>)<br>input_image = torch.rand(<span class="hljs-number">3</span>,<span class="hljs-number">28</span>,<span class="hljs-number">28</span>)<br>logits = seq_modules(input_image)<br></code></pre></td></tr></table></figure><h3 id="nn.softmax">nn.Softmax</h3><p>神经网络的最后一个线性层返回 logits - [-infty, infty] 中的原始值 -传递给 nn.Softmax 模块。 logits 被缩放为值 [0,1]，表示模型对每个类别的预测概率。 dim 参数表示值必须总和为 1的维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">softmax = nn.Softmax(dim=<span class="hljs-number">1</span>)<br>pred_probab = softmax(logits)<br></code></pre></td></tr></table></figure><h2 id="模型参数">模型参数</h2><p>神经网络中的许多层都是参数化的，即具有在训练期间优化的相关权重和偏差。子类化 nn.Module 会自动跟踪模型对象中定义的所有字段，并使用模型的parameters() 或 named_parameters() 方法使所有参数可访问。</p><p>在此示例中，我们遍历每个参数，并打印其大小和值的预览。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Model structure: <span class="hljs-subst">&#123;model&#125;</span>\n\n&quot;</span>)<br><br><span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> model.named_parameters():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Layer: <span class="hljs-subst">&#123;name&#125;</span> | Size: <span class="hljs-subst">&#123;param.size()&#125;</span> | Values : <span class="hljs-subst">&#123;param[:<span class="hljs-number">2</span>]&#125;</span> \n&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="使用torch.autograd自动微分">使用TORCH.AUTOGRAD自动微分</h1><p>在训练神经网络时，最常用的算法是反向传播。在该算法中，参数（模型权重）根据损失函数相对于给定参数的梯度进行调整。</p><p>为了计算这些梯度，PyTorch 有一个名为 torch.autograd 的内置微分引擎。它支持自动计算任何计算图的梯度。</p><p>考虑最简单的一层神经网络，具有输入 x、参数 w 和 b，以及一些损失函数。它可以通过以下方式在 PyTorch 中定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br>x = torch.ones(<span class="hljs-number">5</span>)  <span class="hljs-comment"># input tensor</span><br>y = torch.zeros(<span class="hljs-number">3</span>)  <span class="hljs-comment"># expected output</span><br>w = torch.randn(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.randn(<span class="hljs-number">3</span>, requires_grad=<span class="hljs-literal">True</span>)<br>z = torch.matmul(x, w) + b<br>loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)<br></code></pre></td></tr></table></figure><h2 id="张量函数计算图">张量、函数、计算图</h2><p>以上代码定义了如下计算图：</p><figure><img src="https://pytorch.org/tutorials/_images/comp-graph.png"alt="计算图" /><figcaption aria-hidden="true">计算图</figcaption></figure><p>在这个网络中，w 和 b 是我们需要优化的参数。因此，我们需要能够计算关于这些变量的损失函数的梯度。为此，我们设置了这些张量的requires_grad 属性。</p><blockquote><p>NOTE：</p><p>您可以在创建张量时设置 requires_grad 的值，或者稍后使用x.requires_grad_(True) 方法。</p></blockquote><p>我们应用于张量以构造计算图的函数实际上是 Function 类的对象。该对象知道如何在正向计算函数，以及如何在反向传播步骤中计算其导数。对反向传播函数的引用存储在张量的 grad_fn 属性中。您可以在文档中找到有关功能的更多信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Gradient function for z = <span class="hljs-subst">&#123;z.grad_fn&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Gradient function for loss = <span class="hljs-subst">&#123;loss.grad_fn&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="计算导数">计算导数</h2><p>为了优化神经网络中参数的权重，我们需要计算损失函数关于参数的导数，即，我们需要在一些固定值x和y下计算<spanclass="math inline">\(\frac{\partial{loss}}{\partial{w}}\)</span>和<spanclass="math inline">\(\frac{\partial loss}{\partialb}\)</span>。为了计算这些导数，我们调用 loss.backward()，然后从 w.grad和 b.grad 中检索值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">loss.backward()<br><span class="hljs-built_in">print</span>(w.grad)<br><span class="hljs-built_in">print</span>(b.grad)<br></code></pre></td></tr></table></figure><blockquote><p>NOTE：</p><ul><li><p>我们只能获取计算图的叶节点的 grad 属性，这些节点的 requires_grad属性设置为 True。 对于我们图表中的所有其他节点，梯度将不可用。</p></li><li><p>出于性能原因，我们只能在给定的图上使用一次反向执行梯度计算。如果我们需要对同一个图进行多次反向调用，我们需要将 retain_graph=True传递给反向调用。</p></li></ul></blockquote><h2 id="禁用梯度跟踪">禁用梯度跟踪</h2><p>默认情况下，所有具有 requires_grad=True的张量都在跟踪它们的计算历史并支持梯度计算。然而，有些情况下我们不需要这样做，例如，当我们已经训练了模型并且只想将其应用于一些输入数据时，即我们只想通过网络进行前向计算。我们可以通过用 torch.no_grad() 块包围我们的计算代码来停止跟踪计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">z = torch.matmul(x, w)+b<br><span class="hljs-built_in">print</span>(z.requires_grad)<br><span class="hljs-comment"># True</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    z = torch.matmul(x, w)+b<br><span class="hljs-built_in">print</span>(z.requires_grad)<br><span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><p>实现相同结果的另一种方法是在张量上使用 detach() 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">z = torch.matmul(x, w)+b<br>z_det = z.detach()<br><span class="hljs-built_in">print</span>(z_det.requires_grad)<br><span class="hljs-comment"># Fasle</span><br></code></pre></td></tr></table></figure><p>您可能想要禁用梯度跟踪的原因有：</p><ul><li>将神经网络中的某些参数标记为冻结参数。</li><li>在只进行前向传递时加快计算速度，因为对不跟踪梯度的张量进行计算会更有效率。</li></ul><h2 id="有关计算图的更多信息">有关计算图的更多信息</h2><p>从概念上讲，autograd 在由 Function 对象组成的有向无环图 (DAG)中记录数据（张量）和所有执行的操作（以及生成的新张量）。 在这个 DAG中，叶子是输入张量，根是输出张量。通过从根到叶跟踪此图，您可以使用链式法则自动计算梯度。</p><p>在一个正向传递中，autograd 同时做了两件事情</p><ul><li>运行请求的操作来计算结果张量</li><li>在 DAG 中维护操作的梯度函数。</li></ul><p>当在 DAG 根上调用<code>.backward()</code>时，后向传递开始。</p><ul><li>计算每个<code>.grad_fn</code>的梯度</li><li>将它们积累在各自张量的<code>.grad</code>属性中</li><li>使用链式法则，一直传播至叶张量</li></ul><blockquote><p>NOTE：</p><p>PyTorch 中的 DAG 是动态的 在每次 .backward() 调用之后，autograd开始填充一个新图。 这正是允许您在模型中使用控制流语句的原因；如果需要，您可以在每次迭代时更改形状、大小和操作。</p></blockquote><h2 id="选读张量梯度和雅克比积">选读：张量梯度和雅克比积</h2><p>在许多情况下，我们有一个标量损失函数，我们需要计算关于某些参数的梯度。但是，有些情况下输出函数是任意张量。 在这种情况下，PyTorch允许您计算所谓的雅可比积，而不是实际的梯度。</p><p>对于一个向量函数<spanclass="math inline">\(\vec{y}=f(\vec{x})\)</span>，其中<spanclass="math inline">\(\vec{x}=&lt;x_1,\cdots,x_n&gt;\)</span>并且<spanclass="math inline">\(\vec{y}=&lt;y_1,\cdots,y_m&gt;\)</span>，<spanclass="math inline">\(\vec{y}\)</span>关于<spanclass="math inline">\(\vec{x}\)</span>的梯度为以下雅克比矩阵： <spanclass="math display">\[J=\left \{\begin{matrix}\frac{\partial y_1}{\partial x_1}&amp;\cdots&amp;\frac{\partialy_1}{\partial x_n}\\\vdots&amp;\ddots&amp;\vdots\\\frac{\partial y_m}{\partial x_1}&amp;\cdots&amp;\frac{\partialy_m}{\partial x_n}\end{matrix}\right \}\]</span> PyTorch 允许计算<spanclass="math inline">\(Jacobian\_Product\_v^T\)</span>，而不是其本身。</p><p><span class="math inline">\(J\)</span>对于给定输入向量<spanclass="math inline">\(v=(v_1,\dots,v_m)\)</span>，这是通过以<spanclass="math inline">\(v\)</span>作为参数调用<code>backward</code>来实现的。<spanclass="math inline">\(v\)</span>的大小应该与我们要计算乘积的原始张量的大小相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">inp = torch.eye(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, requires_grad=<span class="hljs-literal">True</span>)<br>out = (inp+<span class="hljs-number">1</span>).<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).t()<br>out.backward(torch.ones_like(out), retain_graph=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;First call\n<span class="hljs-subst">&#123;inp.grad&#125;</span>&quot;</span>)<br>out.backward(torch.ones_like(out), retain_graph=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nSecond call\n<span class="hljs-subst">&#123;inp.grad&#125;</span>&quot;</span>)<br>inp.grad.zero_()<br>out.backward(torch.ones_like(out), retain_graph=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nCall after zeroing gradients\n<span class="hljs-subst">&#123;inp.grad&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">First call<br>tensor([[<span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>]])<br><br>Second call<br>tensor([[<span class="hljs-number">8.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>],<br>        [<span class="hljs-number">4.</span>, <span class="hljs-number">8.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>],<br>        [<span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">8.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>],<br>        [<span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">8.</span>, <span class="hljs-number">4.</span>]])<br><br>Call after zeroing gradients<br>tensor([[<span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],<br>        [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">2.</span>]])<br></code></pre></td></tr></table></figure><p>请注意，当我们使用相同的参数第二次调用<code>backward</code>时，梯度的值是不同的。发生这种情况是因为在进行反向传播时，PyTorch会累积梯度，即将计算出的梯度值添加到计算图所有叶节点的 grad 属性中。如果你想计算合适的梯度，你需要先将 grad 属性清零。在现实生活中的训练中，优化器可以帮助我们做到这一点。</p><blockquote><p>NOTE:</p><p>以前我们调用不带参数的 <code>backward()</code> 函数。这本质上等同于调用<code>backward(torch.tensor(1.0))</code>，这是在标量值函数的情况下计算梯度的有用方法，例如神经网络训练期间的损失。</p></blockquote><h1 id="优化模型参数">优化模型参数</h1><p>现在我们有了模型和数据，是时候通过优化我们的数据参数来训练、验证和测试我们的模型了。训练模型是一个迭代过程；在每次迭代中，模型对输出进行猜测，计算其猜测中的误差（损失），收集关于其参数的误差的导数（如我们在上一节中看到的），并使用梯度下降优化这些参数. 有关此过程的更详细演练，请观看 3Blue1Brown 的有关反向传播的视频。</p><h2 id="先决条件代码">先决条件代码</h2><p>我们从前面关于数据集和数据加载器和构建模型的部分加载代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> torchvision.transforms <span class="hljs-keyword">import</span> ToTensor<br><br>training_data = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">True</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor()<br>)<br><br>test_data = datasets.FashionMNIST(<br>    root=<span class="hljs-string">&quot;data&quot;</span>,<br>    train=<span class="hljs-literal">False</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=ToTensor()<br>)<br><br>train_dataloader = DataLoader(training_data, batch_size=<span class="hljs-number">64</span>)<br>test_dataloader = DataLoader(test_data, batch_size=<span class="hljs-number">64</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NeuralNetwork</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(NeuralNetwork, self).__init__()<br>        self.flatten = nn.Flatten()<br>        self.linear_relu_stack = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">28</span> * <span class="hljs-number">28</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">10</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.flatten(x)<br>        logits = self.linear_relu_stack(x)<br>        <span class="hljs-keyword">return</span> logits<br><br>    <br>model = NeuralNetwork()<br></code></pre></td></tr></table></figure><h2 id="超参数">超参数</h2><p>超参数是可调整的参数，可让您控制模型优化过程。不同的超参数值会影响模型训练和收敛速度（阅读有关超参数调整的更多信息）</p><p>我们定义了以下用于训练的超参数：</p><ul><li>Number of Epochs：迭代数据集的次数</li><li>Batch Size：参数更新前通过网络传播的数据样本数量</li><li>Learning Rate：每个批次/时期更新模型参数的量。较小的值会产生较慢的学习速度，而较大的值可能会导致训练期间出现不可预测的行为。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">learning_rate = <span class="hljs-number">1e-3</span><br>batch_size = <span class="hljs-number">64</span><br>epochs = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="优化循环">优化循环</h2><p>一旦我们设置了超参数，我们就可以使用优化循环来训练和优化我们的模型。优化循环的每次迭代称为一个<strong>epoch</strong>。</p><p>每个<code>epoch</code>由两个主要部分组成：</p><ul><li>Train Loop：迭代训练数据集并尝试收敛到最佳参数。</li><li>Validation/TestLoop：遍历测试数据集以检查模型性能是否正在提高。</li></ul><p>让我们简要地熟悉一下训练循环中使用的一些概念。向前跳转以查看优化循环的完整实现。</p><h3 id="loss-function">Loss Function</h3><p>当提供一些训练数据时，我们未经训练的网络可能不会给出正确的答案。损失函数衡量的是得到的结果与目标值的相异程度，是我们在训练时想要最小化的损失函数。为了计算损失，我们使用给定数据样本的输入进行预测，并将其与真实数据标签值进行比较。</p><p>常见的损失函数包括用于回归任务的<code>nn.MSELoss</code>（均方误差）和用于分类的<code>nn.NLLLoss</code>（负对数似然）。 <code>nn.CrossEntropyLoss</code>结合了 nn.LogSoftmax 和 nn.NLLLoss。</p><p>我们将模型的输出 logits 传递给<code>nn.CrossEntropyLoss</code>，它将规范化 logits 并计算预测误差。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Initialize the loss function</span><br><span class="hljs-attr">loss_fn</span> = nn.CrossEntropyLoss()<br></code></pre></td></tr></table></figure><h3 id="优化器">优化器</h3><p>优化是在每个训练步骤中调整模型参数以减少模型误差的过程。优化算法定义了这个过程是如何执行的（在这个例子中我们使用随机梯度下降）。所有优化逻辑都封装在优化器对象中。 在这里，我们使用 SGD 优化器；此外，PyTorch 中有许多不同的优化器可用，例如 ADAM 和RMSProp，它们可以更好地处理不同类型的模型和数据。</p><p>我们通过注册需要训练的模型参数并传入学习率超参数来初始化优化器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)<br></code></pre></td></tr></table></figure><p>在训练循环中，优化分三步进行：</p><ul><li>调用 <code>optimizer.zero_grad()</code> 重置模型参数的梯度。默认情况下渐变相加；为了防止重复计算，我们在每次迭代时明确地将它们归零。</li><li>通过调用 <code>loss.backward()</code> 反向传播预测损失。 PyTorch存储每个参数的损失梯度。</li><li>一旦我们有了梯度，我们就会调用 <code>optimizer.step()</code>来通过在反向传递中收集的梯度来调整参数。</li></ul><h2 id="完整实现">完整实现</h2><p>我们定义了循环优化代码的train_loop，以及根据我们的测试数据评估模型性能的 test_loop。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_loop</span>(<span class="hljs-params">dataloader, model, loss_fn, optimizer</span>):<br>    size = <span class="hljs-built_in">len</span>(dataloader.dataset)<br>    <span class="hljs-keyword">for</span> batch, (X, y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dataloader):<br>        <span class="hljs-comment"># Compute prediction and loss</span><br>        pred = model(X)<br>        loss = loss_fn(pred, y)<br><br>        <span class="hljs-comment"># Backpropagation</span><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br><br>        <span class="hljs-keyword">if</span> batch % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            loss, current = loss.item(), (batch + <span class="hljs-number">1</span>) * <span class="hljs-built_in">len</span>(X)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;loss: <span class="hljs-subst">&#123;loss:&gt;7f&#125;</span>  [<span class="hljs-subst">&#123;current:&gt;5d&#125;</span>/<span class="hljs-subst">&#123;size:&gt;5d&#125;</span>]&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_loop</span>(<span class="hljs-params">dataloader, model, loss_fn</span>):<br>    size = <span class="hljs-built_in">len</span>(dataloader.dataset)<br>    num_batches = <span class="hljs-built_in">len</span>(dataloader)<br>    test_loss, correct = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> dataloader:<br>            pred = model(X)<br>            test_loss += loss_fn(pred, y).item()<br>            correct += (pred.argmax(<span class="hljs-number">1</span>) == y).<span class="hljs-built_in">type</span>(torch.<span class="hljs-built_in">float</span>).<span class="hljs-built_in">sum</span>().item()<br><br>    test_loss /= num_batches<br>    correct /= size<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test Error: \n Accuracy: <span class="hljs-subst">&#123;(<span class="hljs-number">100</span> * correct):&gt;<span class="hljs-number">0.1</span>f&#125;</span>%, Avg loss: <span class="hljs-subst">&#123;test_loss:&gt;8f&#125;</span> \n&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们初始化损失函数和优化器，并将其传递给 train_loop 和 test_loop。随意增加 epoch 的数量来跟踪模型的改进性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">loss_fn = nn.CrossEntropyLoss()<br>optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)<br><br>epochs = <span class="hljs-number">10</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;t+<span class="hljs-number">1</span>&#125;</span>\n-------------------------------&quot;</span>)<br>    train_loop(train_dataloader, model, loss_fn, optimizer)<br>    test_loop(test_dataloader, model, loss_fn)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done!&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="保存并加载模型">保存并加载模型</h1><p>在本节中，我们将了解如何通过保存、加载和运行模型预测来保持模型状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision.models <span class="hljs-keyword">as</span> models<br></code></pre></td></tr></table></figure><h2 id="保存和加载模型权重">保存和加载模型权重</h2><p>PyTorch 模型将学习到的参数存储在一个名为 state_dict的内部状态字典中。 这些可以通过 <code>torch.save</code> 方法保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model = models.vgg16(weights=<span class="hljs-string">&#x27;IMAGENET1K_V1&#x27;</span>)<br>torch.save(model.state_dict(), <span class="hljs-string">&#x27;model_weights.pth&#x27;</span>)<br></code></pre></td></tr></table></figure><p>要加载模型权重，您需要先创建相同模型的实例，然后使用load_state_dict() 方法加载参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">model = models.vgg16() <span class="hljs-comment"># we do not specify ``weights``, i.e. create untrained model</span><br>model.load_state_dict(torch.load(<span class="hljs-string">&#x27;model_weights.pth&#x27;</span>))<br>model.<span class="hljs-built_in">eval</span>()<br></code></pre></td></tr></table></figure><blockquote><p>NOTE：</p><p>一定要在推理之前调用 model.eval() 方法，将 dropout 和 batchnormalization 层设置为评估模式。如果不这样做，将产生不一致的推理结果。</p></blockquote><h2 id="使用形状保存和加载模型">使用形状保存和加载模型</h2><p>在加载模型权重时，我们需要先实例化模型类，因为该类定义了网络的结构。我们可能希望将此类的结构与模型一起保存，在这种情况下，我们可以将模型（而不是model.state_dict()）传递给保存函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.save(model, <span class="hljs-string">&#x27;model.pth&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后我们可以像这样加载模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model = torch.load(<span class="hljs-string">&#x27;model.pth&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>NOTE：</p><p>这种方法在序列化模型时使用 Python pickle模块，因此它依赖于加载模型时可用的实际类定义。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神经网络参数更新</title>
    <link href="/2023/05/10/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/05/10/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p>此处以双层神经网络的参数更新作为推导，向量均为列向量，样本数为1。（样本数为m时，只需要对偏置b进行相关处理即可，即对样本的b进行求均值？）</p><p>神经网络运算公式： <span class="math display">\[z_1=W_1^TX+b_1\\a_1=f_1(z_1)\\z_2=W^T_2a_1+b_2\\a_2=f_2(z_2)\]</span> 损失函数： <span class="math display">\[loss=\frac{1}{2}\sum_{i=1}^n(y_i-a_{2i})^2\]</span> <span class="math inline">\(W_2^T\)</span>： <spanclass="math display">\[\frac{\partial loss}{\partial a_2}=y-a_2\\\frac{\partial a_2}{\partial W_2^T}=\frac{\partial a_2}{\partialz_2}\cdot a_1^T\\\frac{\partial a_2}{\partial a_1}=(W_2^T)^T\cdot \frac{\partiala_2}{\partial z_2}\]</span></p><blockquote><p>规律：对哪个位置求导就将上一步的导数放在该位置然后与剩余部分的转置做向量积运算</p></blockquote><p><span class="math inline">\(W_1^T\)</span>： <spanclass="math display">\[\frac{\partial a_2}{W_1^T}=\frac{\partial a_2}{\partial a_1}\times\frac{\partial a_1}{W_1^T}\\\frac{\partial a_1}{\partial W_1^T}=\frac{\partial a_1}{\partialz_1}\cdot X^T\]</span></p><blockquote><p>在开始计算每一层之前，先算出到该层激活前的输出的偏导数值，记为一个标识符，然后就不用管之前的运算变量了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MNIST</title>
    <link href="/2023/04/23/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B-MNIST/"/>
    <url>/2023/04/23/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B-MNIST/</url>
    
    <content type="html"><![CDATA[<h1 id="手工实现">手工实现</h1><p>现如今，已经有很多成熟的框架用于神经网络的训练，但是对于其中的基本原理，并不能很好的体会。本节采用<code>Numpy</code>手动搭建一个两层神经网络，希望对神经网络的搭建和学习过程有更加深刻的体会，有助于今后的学习。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-string">&quot;&quot;&quot; 在本次实验中，矩阵运算的关系式为：XW+b &quot;&quot;&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">onehot</span>(<span class="hljs-params">targets, num</span>):<br>    result = np.zeros((num, <span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>        result[i][targets[i]] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> result<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;激活函数 sigmoid &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Dsigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> sigmoid(x) * (<span class="hljs-number">1</span> - sigmoid(x))<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NeuralNetwork</span>():<br>    <span class="hljs-comment"># 初始化神经网络</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_nodes, hidden_nodes, output_nodes, learning_rate, batch_size</span>):<br>        self.a2 = <span class="hljs-literal">None</span><br>        self.z2 = <span class="hljs-literal">None</span><br>        self.y = <span class="hljs-literal">None</span><br>        self.g = <span class="hljs-literal">None</span><br>        self.a1 = <span class="hljs-literal">None</span><br>        self.z1 = <span class="hljs-literal">None</span><br>        self.X = <span class="hljs-literal">None</span><br>        self.hidden_output = <span class="hljs-literal">None</span><br>        self.i_nodes = input_nodes<br>        self.h_nodes = hidden_nodes<br>        self.o_nodes = output_nodes<br>        self.lr = learning_rate<br>        self.batch_size = batch_size<br>        self.W1 = np.random.randn(self.i_nodes, self.h_nodes) * <span class="hljs-number">0.01</span><br>        self.W2 = np.random.randn(self.h_nodes, self.o_nodes) * <span class="hljs-number">0.01</span><br>        self.b1 = np.random.randn(self.h_nodes) * <span class="hljs-number">0.01</span><br>        self.b2 = np.random.randn(self.o_nodes) * <span class="hljs-number">0.01</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X, y</span>):<br>        <span class="hljs-comment"># todo 使用自实现的 sigmoid 激活函数有溢出的情况，所以换成以下 sigmoid 函数，就解决了问题，未来查找研究一下</span><br><br>        <span class="hljs-comment"># hidden layer</span><br>        self.X = X<br>        self.y = y<br><br>        self.z1 = np.dot(X, self.W1) + self.b1<br>        self.a1 = sigmoid(self.z1)<br><br>        <span class="hljs-comment"># output layer</span><br>        self.z2 = np.dot(self.a1, self.W2) + self.b2<br>        self.a2 = sigmoid(self.z2)<br><br>        loss = np.<span class="hljs-built_in">sum</span>((self.a2 - y) * (self.a2 - y)) / self.batch_size<br><br>        <span class="hljs-comment"># 用于反向传播参数，就是书中的 g</span><br>        self.g = (self.a2 - y) * Dsigmoid(self.z2)<br><br>        <span class="hljs-keyword">return</span> loss<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self</span>):<br>        dW2 = np.dot(self.a1.T, self.g) / self.batch_size<br>        db2 = np.<span class="hljs-built_in">sum</span>(self.g, axis=<span class="hljs-number">0</span>) / self.batch_size<br><br>        <span class="hljs-comment"># 就是书中的 e</span><br>        e = np.dot(self.g, self.W2.T) * Dsigmoid(self.z1)<br>        dW1 = np.dot(self.X.T, e) / self.batch_size<br><br>        db1 = np.<span class="hljs-built_in">sum</span>(e, axis=<span class="hljs-number">0</span>) / self.batch_size<br><br>        self.W2 = self.W2 - self.lr * dW2<br>        self.b2 = self.b2 - self.lr * db2<br>        self.W1 = self.W1 - self.lr * dW1<br>        self.b1 = self.b1 - self.lr * db1<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy</span>(<span class="hljs-params">y, predict_y</span>):<br>    hit = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(y.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">if</span> np.argmax(y[i]) == np.argmax(predict_y[i]):<br>            hit = hit + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;accuracy&#x27;</span>, hit / y.shape[<span class="hljs-number">0</span>])<br><br><br>loss_list = []<br>precision_list = []<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">X, y, batch_size, epochs, test_X, test_y</span>):<br>    nn = NeuralNetwork(<span class="hljs-number">784</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0.1</span>, batch_size)<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----------------------epoch: %d--------------------&quot;</span> % epoch)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">60000</span>, batch_size):<br>            X = train_images[i: i + batch_size]<br>            Y = train_labels[i: i + batch_size]<br>            loss = nn.forward(X, Y)<br>            loss_list.append(loss)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;epoch:&#x27;</span>, epoch, <span class="hljs-string">&#x27;-&#x27;</span>, i, <span class="hljs-string">&#x27;:&#x27;</span>, loss)<br>            nn.backward()<br>        np.savez(<span class="hljs-string">&quot;main.npz&quot;</span>, w1=nn.W1, b1=nn.b1, w2=nn.W2, b2=nn.b2)<br>        test(test_X, test_y, batch_size)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">test_X, test_Y, batch_size</span>):<br>    nn = NeuralNetwork(<span class="hljs-number">784</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0.1</span>, batch_size)<br>    r = np.load(<span class="hljs-string">&quot;main.npz&quot;</span>)<br>    nn.W1 = r[<span class="hljs-string">&quot;w1&quot;</span>]<br>    nn.b1 = r[<span class="hljs-string">&quot;b1&quot;</span>]<br>    nn.W2 = r[<span class="hljs-string">&quot;w2&quot;</span>]<br>    nn.b2 = r[<span class="hljs-string">&quot;b2&quot;</span>]<br>    nn.forward(test_X, test_Y)<br>    result = nn.a2<br>    result = np.argmax(result, axis=<span class="hljs-number">1</span>)<br>    y = np.argmax(test_Y, axis=<span class="hljs-number">1</span>)<br>    precision = np.<span class="hljs-built_in">sum</span>(result == y) / y.shape[<span class="hljs-number">0</span>]<br>    precision_list.append(precision)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Precision:&quot;</span>, precision)<br><br>    <span class="hljs-comment"># for i in range(10):</span><br>    <span class="hljs-comment">#     plt.figure(figsize=(28, 28))</span><br>    <span class="hljs-comment">#     plt.imshow(np.reshape(test_X[i], (28, 28)))</span><br>    <span class="hljs-comment">#     print(result[i])</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;为了方便，我们使用 tensorflow 来进行数据的获取&#x27;&#x27;&#x27;</span><br>    (train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.mnist.load_data()<br>    <span class="hljs-comment"># print(train_images.shape)</span><br>    <span class="hljs-comment"># print(train_labels.shape)</span><br>    <span class="hljs-comment"># print(test_images.shape)</span><br>    <span class="hljs-comment"># print(test_labels.shape)</span><br>    <span class="hljs-comment"># (60000, 28, 28)</span><br>    <span class="hljs-comment"># (60000,)</span><br>    <span class="hljs-comment"># (10000, 28, 28)</span><br>    <span class="hljs-comment"># (10000,)</span><br><br>    <span class="hljs-string">&#x27;&#x27;&#x27;对数据进行处理，图像进行降维，数字进行 one-hot 编码&#x27;&#x27;&#x27;</span><br>    train_images = train_images.reshape(train_images.shape[<span class="hljs-number">0</span>], train_images.shape[<span class="hljs-number">1</span>] * train_images.shape[<span class="hljs-number">1</span>])<br>    test_images = test_images.reshape(test_images.shape[<span class="hljs-number">0</span>], test_images.shape[<span class="hljs-number">1</span>] * test_images.shape[<span class="hljs-number">1</span>])<br>    train_labels = onehot(train_labels, <span class="hljs-number">60000</span>)<br>    test_labels = onehot(test_labels, <span class="hljs-number">10000</span>)<br><br>    batch_size = <span class="hljs-number">100</span><br>    epochs = <span class="hljs-number">10000</span><br><br>    <span class="hljs-comment"># train(train_images, train_labels, batch_size, epochs, test_images, test_labels)</span><br>    test(test_images, test_labels, batch_size)<br><br>    <span class="hljs-comment"># 绘制 loss 变化曲线</span><br>    <span class="hljs-comment"># x_ = list(range(1, len(loss_list) + 1))</span><br>    <span class="hljs-comment"># plt.plot(x_, loss_list)</span><br>    <span class="hljs-comment"># plt.show()</span><br><br>    <span class="hljs-comment"># 绘制 precision 变化曲线</span><br>    <span class="hljs-comment"># x_ = list(range(1, len(precision_list) + 1))</span><br>    <span class="hljs-comment"># plt.plot(x_, precision_list)</span><br>    <span class="hljs-comment"># plt.show()</span><br></code></pre></td></tr></table></figure><h1 id="pytorch实现">Pytorch实现</h1><p>采用10层CNN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">import</span> torchvision.datasets <span class="hljs-keyword">as</span> datasets<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br><br>input_size = <span class="hljs-number">28</span> * <span class="hljs-number">28</span><br>num_classes = <span class="hljs-number">10</span><br>num_epochs = <span class="hljs-number">10</span><br>batch_size = <span class="hljs-number">100</span><br>learning_rate = <span class="hljs-number">1e-3</span><br><br>train_data = datasets.MNIST(root=<span class="hljs-string">&#x27;./dataset&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br>test_data = datasets.MNIST(root=<span class="hljs-string">&#x27;./dataset&#x27;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br>num_train_samples = <span class="hljs-built_in">len</span>(train_data)<br><br>train_loader = DataLoader(dataset=train_data, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br>test_loader = DataLoader(dataset=test_data, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CNN</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_outputs</span>):<br>        <span class="hljs-built_in">super</span>(CNN, self).__init__()<br><br>        <span class="hljs-comment"># 1*28*28</span><br>        self.conv1 = nn.Conv2d(in_channels=<span class="hljs-number">1</span>, out_channels=<span class="hljs-number">32</span>, kernel_size=(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), padding=<span class="hljs-number">2</span>)<br>        self.relu1 = nn.ReLU()<br>        self.pool1 = nn.MaxPool2d(kernel_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), stride=<span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># 32*14*14</span><br>        self.conv2 = nn.Conv2d(in_channels=<span class="hljs-number">32</span>, out_channels=<span class="hljs-number">64</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), padding=<span class="hljs-number">1</span>)<br>        self.relu2 = nn.ReLU()<br>        self.pool2 = nn.MaxPool2d(kernel_size=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), stride=<span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># 64*7*7</span><br>        self.conv3 = nn.Conv2d(in_channels=<span class="hljs-number">64</span>, out_channels=<span class="hljs-number">128</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), padding=<span class="hljs-number">1</span>)<br>        self.relu3 = nn.ReLU()<br><br>        <span class="hljs-comment"># 128*7*7 =&gt; 6272</span><br>        self.flatten = nn.Flatten()<br>        self.linear4 = nn.Linear(<span class="hljs-number">6272</span>, <span class="hljs-number">128</span>)<br>        self.relu4 = nn.ReLU()<br><br>        self.linear5 = nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">64</span>)<br>        self.relu5 = nn.ReLU()<br><br>        self.linear6 = nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">32</span>)<br>        self.relu6 = nn.ReLU()<br><br>        self.linear7 = nn.Linear(<span class="hljs-number">32</span>, <span class="hljs-number">16</span>)<br>        self.relu7 = nn.ReLU()<br><br>        self.linear8 = nn.Linear(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>)<br>        self.relu8 = nn.ReLU()<br><br>        self.linear9 = nn.Linear(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>)<br>        self.relu9 = nn.ReLU()<br><br>        self.linear10 = nn.Linear(<span class="hljs-number">16</span>, num_outputs)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, inputs</span>):<br>        outputs = self.conv1(inputs)<br>        outputs = self.relu1(outputs)<br>        outputs = self.pool1(outputs)<br><br>        outputs = self.conv2(outputs)<br>        outputs = self.relu2(outputs)<br>        outputs = self.pool2(outputs)<br><br>        outputs = self.conv3(outputs)<br>        outputs = self.relu3(outputs)<br><br>        outputs = self.flatten(outputs)<br>        outputs = self.linear4(outputs)<br>        outputs = self.relu4(outputs)<br><br>        outputs = self.linear5(outputs)<br>        outputs = self.relu5(outputs)<br><br>        outputs = self.linear6(outputs)<br>        outputs = self.relu6(outputs)<br><br>        outputs = self.linear7(outputs)<br>        outputs = self.relu7(outputs)<br><br>        outputs = self.linear8(outputs)<br>        outputs = self.relu8(outputs)<br><br>        outputs = self.linear9(outputs)<br>        outputs = self.relu9(outputs)<br><br>        outputs = self.linear10(outputs)<br>        <span class="hljs-keyword">return</span> outputs<br><br><br>model = CNN(num_classes)<br>loss_fn = nn.CrossEntropyLoss()<br>optimizer = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">0.01</span>)<br><br><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;e + <span class="hljs-number">1</span>&#125;</span>/<span class="hljs-subst">&#123;num_epochs&#125;</span>\n-------------------------------&quot;</span>)<br>    size = <span class="hljs-built_in">len</span>(train_loader.dataset)<br>    <span class="hljs-keyword">for</span> batch, (x, labels) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        one_hot = torch.nn.functional.one_hot(labels, num_classes).<span class="hljs-built_in">type</span>(torch.float32)<br><br>        <span class="hljs-comment"># 计算预测和损失</span><br>        pred = model(x)<br>        loss = loss_fn(pred, one_hot)<br><br>        <span class="hljs-comment"># 反向传递</span><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br><br>        <span class="hljs-keyword">if</span> batch % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            loss, current = loss.item(), (batch + <span class="hljs-number">1</span>) * <span class="hljs-built_in">len</span>(x)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;loss: <span class="hljs-subst">&#123;loss:&gt;7f&#125;</span>  [<span class="hljs-subst">&#123;current:&gt;5d&#125;</span>/<span class="hljs-subst">&#123;size:&gt;5d&#125;</span>]&quot;</span>)<br><br>size = <span class="hljs-built_in">len</span>(test_loader.dataset)<br>num_batches = <span class="hljs-built_in">len</span>(test_loader)<br>test_loss, correct = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> test_loader:<br>        pred = model(x)<br>        labels = labels.<span class="hljs-built_in">float</span>()<br>        one_hot = torch.nn.functional.one_hot(y, num_classes).<span class="hljs-built_in">type</span>(torch.float32)<br>        test_loss += loss_fn(pred, one_hot).item()<br>        correct += (pred.argmax(<span class="hljs-number">1</span>) == y).<span class="hljs-built_in">type</span>(torch.<span class="hljs-built_in">float</span>).<span class="hljs-built_in">sum</span>().item()<br><br>test_loss /= num_batches<br>correct /= size<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test Error: \n Accuracy: <span class="hljs-subst">&#123;(<span class="hljs-number">100</span> * correct):&gt;<span class="hljs-number">0.1</span>f&#125;</span>%, Avg loss: <span class="hljs-subst">&#123;test_loss:&gt;8f&#125;</span> \n&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>机器学习</tag>
      
      <tag>神经网络</tag>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch-GPU机器学习配置</title>
    <link href="/2023/04/16/Pytorch-GPU%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/04/16/Pytorch-GPU%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一更新显卡驱动">一、更新显卡驱动</h1><p><ahref="https://blog.csdn.net/qq_41764621/article/details/126465278?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126465278%22%2C%22source%22%3A%22qq_41764621%22%7D">(169条消息)如何在windows上 安装&amp;更新显卡的驱动_windows安装显卡驱动_chuanauc的博客-CSDN博客</a></p><p><a href="https://www.nvidia.cn/Download/index.aspx?lang=cn">官方驱动| NVIDIA</a></p><p>更新完成后，在命令行中输入：<code>nvidia-smi</code>，即可查看支持最新的<code>CUDA Version</code>版本</p><h1 id="二安装-cuda-运行版本">二、安装 CUDA 运行版本</h1><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDAToolkit Archive | NVIDIA Developer</a></p><p>在该网页下载对应版本，自定义安装，选择cuda即可</p><p>下载完成后，在命令行中输入：<code>nvcc --version</code>，有相关信息输出，即代表完成</p><h1 id="三安装-cudnn">三、安装 cuDNN</h1><p><a href="https://developer.nvidia.com/rdp/cudnn-download">cuDNNDownload | NVIDIA Developer</a></p><p>解压后，将对应文件夹的文件复制进CUDA对应文件夹中。【注意不是替换文件夹，而是复制文件夹中的文件】</p><h1 id="四安装-pytorch">四、安装 Pytorch</h1><p><a href="https://pytorch.org/get-started/locally/">Start Locally |PyTorch</a></p><p>选择相关配置，执行命令</p><h1 id="五验证是否安装成功">五、验证是否安装成功</h1><p>在命令行进入 Python 代码执行，输入代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>torch.cuda.is_available()<br></code></pre></td></tr></table></figure><p>输出结果为 True，则配置完成。</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
      <tag>Pytorch</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第6章-支持向量机</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC6%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC6%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第-6-章-支持向量机">第 6 章 支持向量机</h1><h2 id="间隔与支持向量">6.1 间隔与支持向量</h2><ul><li><p>分类学习最基本的想法就是基于训练集<spanclass="math inline">\(D\)</span>在样本空间中找到一个<strong>划分超平面</strong>，将不同类别的样本分开。</p></li><li><p>划分超平面可以通过如下线性方程来描述：</p><ul><li><p><span class="math display">\[w^Tx+b=0\]</span></p></li><li><p><spanclass="math inline">\(w=(w_1;w_2;\cdots;w_d)\)</span>为法向量，决定了超平面的方向</p></li><li><p><spanclass="math inline">\(b\)</span>为位移项，决定了超平面与原点之间的距离</p></li></ul></li><li><p>样本空间中任意点<spanclass="math inline">\(x\)</span>到超平面<spanclass="math inline">\((w,b)\)</span>的距离可以写作：</p><ul><li><span class="math display">\[r=\frac{|w^Tx+b|}{||w||}(点到平面距离公式)\]</span></li></ul></li><li><p>若超平面能够将训练样本正确分类，对于<spanclass="math inline">\(y_i=+1\)</span>，带入超平面方程大于等于+1；对于<spanclass="math inline">\(y_i=-1\)</span>，带入超平面方程小于等于-1；</p></li><li><p>距离超平面最近的几个训练样本使得以上等号成立，被称为“支持向量”support vector，两个异类支持向量到超平面的距离之和为：<spanclass="math inline">\(\gamma=\frac{2}{||w||}\)</span>，被称为间隔margin。</p></li><li><p>要找到具有最大间隔的划分超平面，即找到能够上式，使得<spanclass="math inline">\(\gamma\)</span>最大。显然仅需<spanclass="math inline">\(||w||^{-1}\)</span>最大，等价于最小化<spanclass="math inline">\(||w||^2\)</span></p></li><li><p>我们可以写出如下式子：</p><ul><li><p><span class="math display">\[min_{w,b}\ \frac{1}{2}||w||^2\\s.t.\ y_i(w^Tx_i+b)\geq 1, i=1,2,\cdots,m\]</span></p></li><li><p>以上就是支持向量机的基本型 Support Vector Machine，SVM</p></li></ul></li></ul><h2 id="对偶问题">6.2 对偶问题</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第5章-神经网络</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC5%E7%AB%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC5%E7%AB%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="第-5-章-神经网络">第 5 章 神经网络</h1><h2 id="神经元模型">5.1 神经元模型</h2><p>神经网络中最基本的成分是神经元 neuron / unit模型，当神经元的电位超过一个阈值，就会被激活，向其他神经元发送化学物质</p><p>M-P 神经元模型：</p><p><img src="第5章 神经网络.assets/image-20230403195540918.png" alt="image-20230403195540918" style="zoom: 50%;" /></p><p>理想的激活函数：</p><p><img src="第5章 神经网络.assets/image-20230403195835152.png" alt="image-20230403195835152" style="zoom: 50%;" /></p><p>但是，阶跃函数具有不连续，不光滑的性质。因此，常使用 Sigmoid函数：</p><p><img src="第5章 神经网络.assets/image-20230403200123887.png" alt="image-20230403200123887" style="zoom:50%;" /></p><p>把许多这样的神经元按一定的层次结构连接起来，就得到了神经网络</p><blockquote><p>引入激活函数的作用：</p><ol type="1"><li>给模型引入非线性关系</li><li>表示该神经元是否被激活，即该神经元接收到的信息是否有用，该留下或者抛弃</li></ol></blockquote><h2 id="感知机与多层网络">5.2 感知机与多层网络</h2><ul><li>感知机 Perceptron 由两层神经元组成：</li></ul><p><img src="第5章 神经网络.assets/image-20230403201104867.png" alt="image-20230403201104867" style="zoom:67%;" /></p><ul><li><p>神经网络就是为了学习出权重和阈值，而阈值可以看作一个固定输入为-1.0的哑结点dummy node 所对应的连接权重<spanclass="math inline">\(w_{n+1}\)</span>，这样权重和阈值的学习可以统一为权重的学习。</p></li><li><p>感知机的学习规则：</p><ul><li><p>对于训练样例<spanclass="math inline">\((x,y)\)</span>，若当前感知机的输出为<spanclass="math inline">\(\hat{y}\)</span>，则感知机权重进行如下调整：</p></li><li><p><span class="math inline">\(w_i\leftarrow w_i+\Deltaw_i\)</span></p></li><li><p><span class="math inline">\(\Deltaw_i=\eta(y-\hat{y})x_i\)</span></p></li><li><p>其中<span class="math inline">\(\eta\in(0,1)\)</span>称为学习率(learning rate)</p></li><li><p><ahref="https://zhuanlan.zhihu.com/p/46762820">算法——感知机详解（推导+证明）- 知乎 (zhihu.com)</a></p></li></ul></li><li><p>感知机只有输出层神经元进行激活函数处理，只拥有一层功能神经元functional neuron，学习能力有限</p></li><li><p>两层感知机</p><ul><li><img src="第5章 神经网络.assets/image-20230403202259504.png" alt="image-20230403202259504" style="zoom:50%;" /></li><li>其中有隐层 / 隐含层 hiddenlayer，隐含层和输出层神经元都是拥有激活函数的功能神经元</li></ul></li><li><p>多层前馈神经网络 multi-layer feedforward neural networks：</p><ul><li><img src="第5章 神经网络.assets/image-20230403202459424.png" alt="image-20230403202459424" style="zoom:67%;" /></li><li>前馈指的是网络拓扑结构上不存在环或回路</li></ul></li><li><p>神经网络的学习过程，就是根据训练数据来调整神经元之间的“连接权”（connectionweight）以及每个功能神经元之间的阈值</p></li></ul><h2 id="误差逆传播算法">5.3 误差逆传播算法</h2><ul><li>为了训练多层网络，就需要更加强大的学习算法。误差逆传播 errorBackPropagation，简称 BP 算法，是其中的代表。</li><li></li></ul><h2 id="全局最小与局部极小">5.4 全局最小与局部极小</h2><ul><li>神经网络的训练过程可看作一个参数寻优过程，即在参数空间中，寻找一组最优参数使得<spanclass="math inline">\(E\)</span>最小</li><li>最优：<ul><li>局部极小 local minimum</li><li>全局最小 global minimum</li></ul></li><li>基于梯度下降的搜索是使用最为广泛的参数寻优方法</li><li>为了防止陷入局部极小，而不能保证找到全局最小，我们可以采用以下操作：<ul><li>以多组不同参数值初始化多个网络，取其中误差最小解作为最终参数</li><li>使用“模拟退火”技术（simulatedannealing）：在每一步都以一定的概率接受比当前解更差的结果，从而有助于“跳出”局部极小。在每步迭代过程中，接受“次优解”的概率要随着时间的推移而逐渐降低，从而保证算法稳定。</li><li>使用随机梯度下降：与标准梯度下降法精确计算梯度不同，随机梯度下降法在计算梯度时加入了随机因素。于是，即便陷入局部极小点，它计算出的梯度仍可能不为零，这样就有机会跳出局部极小继续搜索。</li><li>遗传算法 genetic algorithm也常用来训练神经网络以更好地逼近全局最小。</li><li>上述用于跳出局部极小的的技术大多是启发式，理论缺乏保障。</li></ul></li></ul><h2 id="其他常见神经网络">5.5 其他常见神经网络</h2><ul><li>RBF 网络</li><li>ART 网络</li><li>SOM 网络</li><li>级联相关网络</li><li>Elman 网络</li><li>Boltzmann 机</li></ul><h2 id="深度学习">5.6 深度学习</h2><ul><li>增加隐层数目比增加隐层神经元更能提高模型的复杂度</li><li>多隐层神经网络往往难以直接用经典算法进行训练，由于误差在多隐层内逆传播时，往往会发散diverge，而不能收敛到稳定状态</li><li>无监督逐层训练 unsupervised layer-wise training是多隐层网络训练的有效手段，基本思想：<ul><li>每次训练一层隐结点，训练时将上一层隐结点的输出作为输入，本层隐结点的输出作为下一层隐结点的输入。预训练pre-training</li><li>预训练全部完成后，对整个网络进行微调 fine-tuning 训练</li></ul></li><li>另一种节省训练开销的策略是“权共享” weightsharing，让一组神经元使用相同的连接权。<ul><li>该策略在卷积神经网络中发挥了重要作用</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第4章-决策树</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC4%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC4%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="第-4-章-决策树">第 4 章 决策树</h1><h2 id="基本流程">4.1 基本流程</h2><ul><li><p><strong>决策树 decision tree</strong>是一类常见的机器学习方法，有时也叫<strong>判定树</strong>。决策树是基于树结构来进行决策的</p></li><li><p>一棵决策树包含一个根结点、若干个内部结点和若干个叶结点。叶结点对应于决策结果，其他每个结点则对应于一个<strong>属性测试</strong>；根据属性测试的结果将其包含的样本集合划分到子结点中；根结点包含样本全集；<strong>从根节点到叶结点的路径对应了一个判定测试序列</strong>；决策树学习的目的是产生一棵<strong>泛化能力强</strong>的决策树，其基本流程遵循简单直观的<strong>“分而治之”</strong>策略。</p><ul><li><img src="第4章 决策树.assets/image-20230310164532787.png" alt="image-20230310164532787" style="zoom: 50%;" /></li><li>2-4：无需划分</li><li>5-6：无法划分</li><li>11-12：不能划分</li></ul></li><li><p>决策树的生成是一个<strong>递归过程</strong>。</p></li><li><p>在决策树基本算法中，有三种情形会导致递归返回：</p><ol type="1"><li>当前结点包含的样本全属于同一类别，无需划分；</li><li>当前属性集为空，或是所有样本在所有属性上取值相同，无法划分；</li><li>当前结点包含的样本集合为空，不能划分；</li></ol><ul><li>在第 2种情形下，我们把当前结点标记为叶结点，并将其类别设定为该结点所含样本最多的类别；</li><li>在第 3种情形下，同样把当前结点标记为叶结点，但将其类别设定为其父结点所含样本最多的类别；</li><li>注意这两种情形的处理实质不同：情形 2是在利用当前结点的后验分布，而情形 3则是把父结点的样本分布作为当前结点的先验分布.</li></ul></li></ul><h2 id="划分选择">4.2 划分选择</h2><ul><li>如何选择最优划分属性，是决策树学习算法的关键</li></ul><h3 id="信息增益">4.2.1 信息增益</h3><ul><li>信息熵 informationentropy：度量样本集合纯度的一种之指标。若当前样本集合<spanclass="math inline">\(D\)</span>中第<spanclass="math inline">\(k\)</span>类样本所占的比例为<spanclass="math inline">\(p_k(k=1,2,\dots,|y|)\)</span>，则<spanclass="math inline">\(D\)</span>的信息熵定义为： <spanclass="math display">\[Ent(D)=-\sum_{k=1}^{|y|}p_klog_2p_k\]</span> <span class="math inline">\(Ent(D)\)</span>的值越小，<spanclass="math inline">\(D\)</span>的纯度越高</li></ul><blockquote><p>公式理解：</p><p>信息的信息量与发生概率成反比，<spanclass="math inline">\(p_klog_2\frac{1}{p_k}\)</span>，取对数是为了缩小数量级，再乘以<spanclass="math inline">\(p_k\)</span>求和意味着取期望</p><p>纯度越高，可能获取的信息值越小，信息熵越小</p></blockquote><ul><li>信息增益 information gain</li></ul><p><span class="math display">\[Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{|D^v|}{D}Ent(D^v)\]</span></p><blockquote><p>公式理解：</p><p>信息增益 = 划分前的信息熵 - 划分后的信息熵</p><p>划分后的信息熵 = 划分的各分支的信息熵乘以权重再求和</p><p>权重 = 某一属性的样本总数 / 未划分的总样本数</p></blockquote><h3 id="增益率">4.2.2 增益率</h3><ul><li><p>信息增益准则对可取值数目较多的属性有所偏好，为了减少这种不利影响。<spanclass="math inline">\(C4.5\)</span>决策树算法采用增益率，而不是信息增益，来作为选择最优划分属性的准则。</p></li><li><p>增益率 gain ratio <span class="math display">\[Gain\_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}\\\]</span> 其中 <span class="math display">\[IV(a)=-\sum_{v=1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}\]</span> 称为属性<span class="math inline">\(a\)</span>的固有值</p><ul><li>增益率准则对可取值数目较少的属性有所偏好，所以<spanclass="math inline">\(C4.5\)</span>算法先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的。</li></ul></li></ul><blockquote><p>公式理解：</p><p>由于信息增益偏向于属性值多的属性，那么我们对属性值多的属性进行惩罚，越多惩罚力度越大</p><p><spanclass="math inline">\(IV(a)\)</span>公式类似于信息熵公式，属性值越多，则该值越大，则整体分数变小</p></blockquote><h3 id="基尼指数">4.2.3 基尼指数</h3><ul><li><p><spanclass="math inline">\(CART\)</span>决策树使用基尼指数来选择划分属性</p></li><li><p>基尼值： <span class="math display">\[Gini(D)=\sum_{k=1}^{|y|}\sum_{k\prime\neq k}p_kp_k\prime=1-\sum_{k=1}^{|y|}p_k^2\]</span></p></li><li><p><spanclass="math inline">\(Gini(D)\)</span>反映了从数据集中随机抽取两个样本，其类别标记不一致的概率。该值越小，数据集纯度越高</p></li><li><p>属性<span class="math inline">\(a\)</span>的基尼指数： <spanclass="math display">\[Gini\_index(D,a)=\sum_{v=1}^V\frac{D^v}{D}Gini(D^v)\]</span></p></li></ul><blockquote><p>公式理解：</p><p>属性<span class="math inline">\(a\)</span>的基尼指数 =划分后各分支的基尼值 * 权重 再求和</p></blockquote><ul><li>选择划分后基尼指数最小的属性作为最优划分属性，即<spanclass="math inline">\(a_*=arg_{a\in A}\ min\Gini\_index(D,a)\)</span></li></ul><h2 id="剪枝处理">4.3 剪枝处理</h2><ul><li>剪枝 pruning 是决策树学习算法对付“过拟合”的主要手段。</li><li>决策树剪枝的基本策略有“预剪枝”（prepruning）和“后剪枝”（postpruning）<ul><li>prepruning：在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。</li><li>postpruning：从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。</li></ul></li><li>判断决策树泛化性能，可以使用 2.2节中提到的留出法，即预留一部分数据用作“验证集”以进行评估。</li></ul><h2 id="连续与缺失值">4.4 连续与缺失值</h2><ul><li>以上讨论的都是基于离散属性生成决策树，现在我们讨论如何对连续属性进行处理，使用连续属性离散化技术。</li><li>最简单的连续属性离散化策略是“二分法”，即<spanclass="math inline">\(C4.5\)</span>中使用的方法。</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第3章-线性模型</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC3%E7%AB%A0-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第-3-章-线性模型">第 3 章 线性模型</h1><h2 id="基本形式">3.1 基本形式</h2><p>对于由<span class="math inline">\(d\)</span>个属性描述的示例<spanclass="math inline">\(x=(x_1;x_2;\dots;x_d)\)</span>，线性模型 linearmodel 试图学得一个通过属性的线性组合来进行预测的函数，即<spanclass="math inline">\(f(x)=w^Tx+b\)</span>，<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>学得之后，模型就得以确定。</p><p>线性模型是许多非线性模型 nonlinear model的基础，且线性模型具有很好的可解释性 comprehensibility。</p><h2 id="线性回归">3.2 线性回归</h2><blockquote><p>分类问题：预测值为分类型变量，即离散的</p><p>回归问题：预测值为连续性变量</p><p>逻辑回归问题：</p></blockquote><p>线性回归：使用线性模型，来学习预测</p><p><strong>对于离散的属性，若属性值间存在序 order关系，通过连续化转化为连续值。若属性值间不存在序关系，假定有<spanclass="math inline">\(k\)</span>个属性值，通常转化为<spanclass="math inline">\(k\)</span>维向量。</strong>例如属性“瓜类”取值有“西瓜”，“南瓜”，“黄瓜”，可转化为<spanclass="math inline">\((0,0,1),(0,1,0),(1,0,0)\)</span></p><p>均方误差是回归任务中最常用的性能度量</p><p><strong>基于均方误差最小化来进行模型求解的方法称为“最小二乘法” leastsquaremethod</strong>。就是试图抓到一条直线，使所有样本到直线上的欧式距离之和最小。<span class="math display">\[\begin{split}E_{(w,b)}=\sum_{i=1}^m(y_i-wx_i-b)^2\ 均方误差\\\frac{\partial E_{(w,b)}}{\partialw}=2(w\sum_{i=1}^mx^2_i-\sum_{i=1}^m(y_i-b)x_i)\\\frac{\partial E_{(w,b)}}{\partial b}=2(mb-\sum_{i=1}^m(y_i-wx_i))\end{split}\]</span> 令上式分别为0，可得到<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>最优解的闭式 closed-form 解</p><blockquote><p>闭式解：解析解，不同于数值解，是通过公式计算推导而来</p></blockquote><p>求解<span class="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>使均方误差最小化的过程，称为线性回归模型的最小二乘“参数估计”parameter estimation</p><p>当<spanclass="math inline">\(x\)</span>为一属性向量时，则称为多元线性回归</p><hr /><p>对于矩阵形式来说，我们把<span class="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>吸收入向量形式<spanclass="math inline">\(\hat{w}=(w;b)\)</span>。同样，把数据集 <spanclass="math inline">\(D\)</span> 表示为一个<spanclass="math inline">\(m\times(d+1)\)</span>大小的矩阵<spanclass="math inline">\(X，\)</span>矩阵的每一行对应一个示例，前<spanclass="math inline">\(d\)</span>个元素对应示例中的<spanclass="math inline">\(d\)</span>​个属性值，最后一个元素恒置为1，即：<span class="math display">\[X=\begin{pmatrix}x_{11}&amp;x_{12}&amp;\cdots&amp;x_{1d}&amp;1\\x_{21}&amp;x_{22}&amp;\cdots&amp;x_{2d}&amp;1\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\x_{m1}&amp;x_{m2}&amp;\cdots&amp;x_{md}&amp;1\end{pmatrix}=\begin{pmatrix}x_1^T &amp; 1 \\x_2^T &amp; 1 \\\vdots &amp; \vdots \\x_m^T &amp; 1 \\\end{pmatrix}\]</span> 要求的参数<spanclass="math inline">\(\hat{w}^*=arg_\hat{w}min(y-X\hat{w})(y-X\hat{w})\)</span>，就是将各样本的误差求均方和</p><p>其中，<span class="math inline">\(E_{\hatw}=(y-X\hat{w})^T(y-X\hat{w})\)</span>，对<spanclass="math inline">\(\hat{w}\)</span>求导，得： <spanclass="math display">\[\frac{\partial E_{\hat{w}}}{\partial{\hat{w}}}=2X^T(X\hat{w}-y)\]</span> 令上式为零，即可求出<spanclass="math inline">\(\hat{w}\)</span>最优的闭式解</p><p>若能解出多个解时，选择哪一个解作为输出，将由学习算法的归纳偏好决定，常见的做法是引入正则化regularization 项</p><h2 id="对数几率回归">3.3 对数几率回归</h2><ul><li><p>线性模型的预测值为连续值，如果想要将线性模型应用到分类问题中，就需要找到一个映射函数，将预测值转化为分类值。并且该函数还需要具有单调可微性</p></li><li><p>考虑二分类问题，输出<spanclass="math inline">\(y\in\{0,1\}\)</span>，我们需要将线性回归的预测值<spanclass="math inline">\(y\in R\)</span>转换为<spanclass="math inline">\(\{0,1\}\)</span>，最理想的即为“单位阶跃函数”：</p><ul><li><p><span class="math display">\[y=\begin{cases}0, &amp; z&lt;0;\\0.5, &amp; z=0;\\1, &amp; z&gt;0,\end{cases}\]</span></p></li><li><p>但是由于我们还需要在运算过程中涉及，求导等操作，需要保证映射函数单调可微，所以我们转而寻求可以近似单位阶跃函数的替代函数，对数几率函数就是一种常用的替代函数</p></li><li><p><span class="math display">\[y=\frac{1}{1+e^{-z}}\]</span></p></li></ul></li><li><p>从而，分类问题的式子变为<spanclass="math inline">\(y=\frac{1}{1+e^{-(w^Tx+b)}}\)</span>。可以看出，该式子使用线性回归模型的预测值结果去逼近真实标记的对数几率，因此，该模型称为“对数几率回归”（有时也称为，逻辑回归）</p><ul><li>可以看出，虽然名字叫回归，其实解决的是一个分类问题</li></ul></li></ul><h2 id="线性判别分析">3.4 线性判别分析</h2><ul><li>线性判别分析（Linear DiscriminantAnalysis，LDA）是一种经典的线性学习方法，在二分类问题上最早提出，也称为“Fisher判别分析”</li><li>LDA的思想：给定训练集，将样例投影到直线上，使同类样例的投影点尽可能接近，异类样例的投影点尽可能远离。在对新样例进行分类时，将其投影到同样的直线上，根据投影点的位置来确定新样本的类别。</li></ul><h2 id="多分类学习">3.5 多分类学习</h2><ul><li>在多分类任务中，有些二分类方法可以直接推广到多分类中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第2章-模型评估与选择</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC2%E7%AB%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC2%E7%AB%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="第-2-章-模型评估与选择">第 2 章 模型评估与选择</h1><h2 id="经验误差与过拟合">2.1 经验误差与过拟合</h2><p>错误率 error rate：分类错误的样本数占样本总数的比例</p><p>精度 accuracy：<span class="math inline">\(精度=1-错误率\)</span></p><p>误差 error：学习器的实际预测输出与样本的真实输出之间的差异</p><p>训练误差 training error / 经验误差 empiricalerror：学习器在训练集上的误差</p><p>泛化误差 generalization error：学习器在新样本上的误差</p><p><strong>我们的目的是获得一个泛化误差小的学习器</strong></p><p>过拟合overfitting：将训练集中样本自身的特点当做所有潜在样本都会具有的一般性质，导致泛化性能下降。学习器的学习能力过于强大</p><p>欠拟合underfitting：对训练样本的一般性质尚未学好。学习器的学习能力低下</p><p>欠拟合可以通过在决策树学习中扩展分支、在神经网络学习中增加训练轮数等方法解决</p><p>过拟合是机器学习面临的关键障碍，过拟合问题是无法避免的，只能缓解或是减小风险</p><h2 id="评估方法">2.2 评估方法</h2><p>我们通常使用测试集 testing set来测试学习器对新样本的辨别能力，用测试集中的测试误差 testing error作为泛化误差的近似。</p><p>我们假设测试样本是从样本真实分布中独立同分布采样而得，并且测试集应该尽可能与训练集互斥。</p><hr /><p><strong>训练集和测试集划分的方法：</strong></p><h3 id="留出法">2.2.1 留出法</h3><p>留出法 hold-out：将数据集 D 划分为两个互斥的集合。</p><p>训练 /测试集的划分要尽可能保持数据分布的一致性，避免数据划分过程引入额外的偏差而对最终结果产生影响。</p><p>分层采样</p><p>单次使用留出法不够稳定可靠，一般要采用若干次随机划分，重复进行实验评估后取平均值作为留出法的评估结果。即多次进行实验，然后将各实验的平均值作为最终实验结果。</p><p>常见做法是将<spanclass="math inline">\(2/3\sim4/5\)</span>的样本用于训练，剩余样本用于测试</p><h3 id="交叉验证法">2.2.2 交叉验证法</h3><p>交叉验证法 cross validation：将数据集划分为<spanclass="math inline">\(k\)</span>个互斥子集，每个子集尽可能保持数据分布的一致性，即从D中分层采样得到。</p><p>每次使用<spanclass="math inline">\(k-1\)</span>个子集的并集作为训练集，剩下的子集作为测试集。得到<spanclass="math inline">\(k\)</span>个测试结果，其均值最为最终结果。</p><p>交叉验证法评估结果的稳定性和保真行在很大程度上取决于<spanclass="math inline">\(k\)</span>的取值，因此，通常称为<spanclass="math inline">\(k\)</span>折交叉验证</p><p><span class="math inline">\(k\)</span>的最常取值为<spanclass="math inline">\(10\)</span>，其他常用数字为<spanclass="math inline">\(5,20\)</span>等</p><p>为了减小因样本划分不同而引入的差别，通常要随机使用不同的划分重复<spanclass="math inline">\(p\)</span>次，最终结果是这<spanclass="math inline">\(p\)</span>次<spanclass="math inline">\(k\)</span>折交叉验证结果的均值。例如：<spanclass="math inline">\(10\)</span>次<spanclass="math inline">\(10\)</span>折交叉验证</p><h3 id="自助法">2.2.3 自助法</h3><p>自助法 bootstrapping：以自主采样法 bootstrap sampling为基础，即放回抽样。</p><p>样本在<spanclass="math inline">\(m\)</span>次采样中始终不被猜到的概率是<spanclass="math inline">\((1-\frac{1}{m})^m\)</span>，取极限得<spanclass="math inline">\(\displaystyle\lim_{m\rightarrow\infty}(1-\frac{1}{m})\rightarrow\frac{1}{e}\approx0.368\)</span></p><h3 id="调参与最终模型">2.2.4 调参与最终模型</h3><p>学习算法都有些参数 parameter 需要设定</p><p>有时，我们把学得模型在实际使用中遇到的数据称为<strong>测试数据</strong>，为了加以区分，模型评估与选择中用于评估测试的数据集常称为<strong>验证集validation set</strong></p><p>用测试集上的判别效果来估计模型在实际使用时的泛化能力，而把训练数据另外划分为<strong>训练集</strong>和<strong>验证集</strong>，基于验证上的性能来进行模型选择和调参</p><h2 id="性能度量">2.3 性能度量</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书-第1章-绪论</title>
    <link href="/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/04/15/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-绪论">第1章 绪论</h1><ul><li><p>learning algorithm：从数据中产生模型的算法</p></li><li><p>机器学习算法被认为是一种从数据中学习的算法。所谓“学习”有一个定义：‘‘对于某类任务T 和性能度量 P，一个计算机程序被认为可以从经验 E 中学习是指，通过经验 E改进后，它在任务 T 上由性能度量 P 衡量的性能有所提升。”</p></li><li><p>数据集</p></li><li><p>属性 / 特征</p></li><li><p>属性值</p></li><li><p>属性空间 / 样本空间 / 输入空间</p></li><li><p>特征向量 feature vector</p></li><li><p>假设 hypothesis</p></li><li><p>真相 / 真实 ground-truth</p></li><li><p>学习器 learner</p></li><li><p>学习的过程是为了找出或逼近真相</p></li><li><p>标记空间 / 输出空间</p></li><li><p>分类 classification：预测的是离散值</p></li><li><p>回归 regression：预测的是连续值</p></li><li><p>二分类：正类 positive class 反类 negative class</p></li><li><p>多分类问题</p></li><li><p>学习任务：</p><ul><li><p>监督 supervised learning 分类/回归</p></li><li><p>无监督 unsupervised learning 聚类</p></li></ul></li><li><p>泛化能力 generalization</p></li><li><p>样本服从 D分布，独立同分布采样，通过学习获得强泛化能力的模型</p></li><li><p>归纳偏好 inductivebias（偏好）：机器学习算法在学习过程中对某种类型假设的偏好</p></li><li><p>任何一个有效的机器学习算法必定有其归纳偏好，否则无法产生确定的学习结果</p></li><li><p>归纳偏好可看做学习算法自身在庞大的假设空间中对假设进行选择的启发式或价值观</p></li><li><p>奥卡姆剃刀原则 Occam’srazor：若有多个建设与观察一致，则选最简单的那个</p></li><li><p>没有免费的午餐定理 No Free Lunch Theorem NFL表明具体问题具体分析</p></li><li><p>BP back propagation 算法</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西瓜书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUPT成绩查询脚本</title>
    <link href="/2023/02/16/BUTP%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/02/16/BUTP%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<ul><li>采用微信接口进行成绩查询</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> schedule<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> tabulate <span class="hljs-keyword">import</span> tabulate<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fractionMap</span>(<span class="hljs-params">fraction</span>):<br>    <span class="hljs-keyword">if</span> fraction == <span class="hljs-string">&quot;优&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">90</span><br>    <span class="hljs-keyword">elif</span> fraction == <span class="hljs-string">&#x27;良&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">80</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(fraction)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getCourse</span>(<span class="hljs-params">token, term</span>):<br>    headers = &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>, <span class="hljs-string">&#x27;token&#x27;</span>: token&#125;<br>    r = requests.post(<span class="hljs-string">&quot;http://jwglweixin.bupt.edu.cn/bjyddx/student/termGPA?semester=&#123;&#125;&amp;type=1&quot;</span>.<span class="hljs-built_in">format</span>(term),<br>                      headers=headers)<br>    r = r.json()<br>    credit_sum = <span class="hljs-number">0</span><br>    avg_grade = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># print(r[&quot;data&quot;][0][&quot;achievement&quot;])</span><br>    <span class="hljs-built_in">list</span> = [[<span class="hljs-string">&quot;课程名&quot;</span>, <span class="hljs-string">&quot;成绩&quot;</span>, <span class="hljs-string">&quot;学分&quot;</span>]]<br>    <span class="hljs-keyword">for</span> course <span class="hljs-keyword">in</span> r[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;achievement&quot;</span>]:<br>        <span class="hljs-built_in">print</span>(course[<span class="hljs-string">&quot;courseName&quot;</span>] + <span class="hljs-string">&#x27; &#x27;</span> + course[<span class="hljs-string">&quot;fraction&quot;</span>] + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">str</span>(course[<span class="hljs-string">&quot;credit&quot;</span>]))<br>        <span class="hljs-built_in">list</span>.append([course[<span class="hljs-string">&quot;courseName&quot;</span>], course[<span class="hljs-string">&quot;fraction&quot;</span>], <span class="hljs-built_in">str</span>(course[<span class="hljs-string">&quot;credit&quot;</span>])])<br>        avg_grade = (avg_grade * credit_sum + fractionMap(course[<span class="hljs-string">&quot;fraction&quot;</span>]) * course[<span class="hljs-string">&quot;credit&quot;</span>]) / (credit_sum + course[<span class="hljs-string">&quot;credit&quot;</span>])<br>        credit_sum += course[<span class="hljs-string">&quot;credit&quot;</span>]<br>    <span class="hljs-comment"># print(tabulate(list, headers=&#x27;firstrow&#x27;, tablefmt=&#x27;grid&#x27;))</span><br>    <span class="hljs-built_in">print</span>(term + <span class="hljs-string">&#x27;加权平均分: &#x27;</span> + <span class="hljs-built_in">str</span>(avg_grade))<br>    <span class="hljs-keyword">return</span> [avg_grade, credit_sum]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPwdMd5</span>(<span class="hljs-params">mypwd</span>):<br>    pwd = mypwd.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    pwd = base64.b64encode(pwd)<br>    pwd = <span class="hljs-built_in">str</span>(pwd)<br>    pwd = pwd[<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> pwd<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getToken</span>(<span class="hljs-params">account, pwdmd5</span>):<br>    headers = &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;<br>    url = <span class="hljs-string">&quot;http://jwglweixin.bupt.edu.cn/bjyddx/login?userNo=&#123;&#125;&amp;pwd=&#123;&#125;&amp;encode=1&quot;</span>.<span class="hljs-built_in">format</span>(account, pwdmd5)<br>    <span class="hljs-built_in">print</span>(url)<br>    r = requests.post(url, headers=headers)<br>    <span class="hljs-built_in">print</span>(r.text)<br>    r = r.json()<br>    token = r[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;token&quot;</span>]<br>    <span class="hljs-keyword">return</span> token<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">job</span>():<br>    account = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;账号：&quot;</span>)<br>    mypwd = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;密码：&quot;</span>)<br><br>    pwdmd5 = getPwdMd5(mypwd)<br>    token = getToken(account, pwdmd5)<br>    terms = [<span class="hljs-string">&quot;2020-2021-1&quot;</span>, <span class="hljs-string">&quot;2020-2021-2&quot;</span>, <span class="hljs-string">&quot;2021-2022-1&quot;</span>, <span class="hljs-string">&quot;2021-2022-2&quot;</span>, <span class="hljs-string">&quot;2022-2023-1&quot;</span>]<br>    creditSum = <span class="hljs-number">0</span><br>    avgCourse = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> term <span class="hljs-keyword">in</span> terms:<br>        temp = getCourse(token, term)<br>        avgCourse = (avgCourse * creditSum + temp[<span class="hljs-number">0</span>] * temp[<span class="hljs-number">1</span>]) / (creditSum + temp[<span class="hljs-number">1</span>])<br>        creditSum += temp[<span class="hljs-number">1</span>]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;截止当前加权平均分为：&quot;</span> + <span class="hljs-built_in">str</span>(avgCourse))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最终加权平均分为：&quot;</span> + <span class="hljs-built_in">str</span>(avgCourse))<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./成绩.txt&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime()) + <span class="hljs-string">&quot;加权平均分：&quot;</span> + <span class="hljs-built_in">str</span>(avgCourse) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>job()<br><span class="hljs-comment"># schedule.every(10).minutes.do(job)</span><br><span class="hljs-comment"># while True:</span><br><span class="hljs-comment">#     schedule.run_pending()</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>BUPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
